<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Python 教程 for Junior</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">简介</a></li><li class="chapter-item expanded "><a href="00.引言/引言.html"><strong aria-hidden="true">1.</strong> Python 初识</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="00.引言/引言.html"><strong aria-hidden="true">1.1.</strong> 引言</a></li><li class="chapter-item expanded "><a href="01.Python简介/Python简介.html"><strong aria-hidden="true">1.2.</strong> Python简介</a></li><li class="chapter-item expanded "><a href="02.HelloWorld/HelloWorld.html"><strong aria-hidden="true">1.3.</strong> hello, world</a></li></ol></li><li class="chapter-item expanded "><a href="03.类型和变量/类型和变量.html"><strong aria-hidden="true">2.</strong> 一级</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="03.类型和变量/类型和变量.html"><strong aria-hidden="true">2.1.</strong> 类型和变量</a></li><li class="chapter-item expanded "><a href="04.运算符和表达式/运算符和表达式.html"><strong aria-hidden="true">2.2.</strong> 运算符和表达式</a></li><li class="chapter-item expanded "><a href="05.位运算/位运算.html"><strong aria-hidden="true">2.3.</strong> 位运算</a></li><li class="chapter-item expanded "><a href="06.常用内建函数/常用内建函数.html"><strong aria-hidden="true">2.4.</strong> 常用内建函数</a></li><li class="chapter-item expanded "><a href="07.海龟画图/海龟画图一.html"><strong aria-hidden="true">2.5.</strong> 海龟画图-第一部分</a></li><li class="chapter-item expanded "><a href="07.海龟画图/海龟画图二.html"><strong aria-hidden="true">2.6.</strong> 海龟画图-第二部分</a></li></ol></li><li class="chapter-item expanded "><a href="08.选择结构/三大结构.html"><strong aria-hidden="true">3.</strong> 二级</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="08.选择结构/三大结构.html"><strong aria-hidden="true">3.1.</strong> 三大结构</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="08.选择结构/选择结构.html"><strong aria-hidden="true">3.1.1.</strong> 选择结构</a></li><li class="chapter-item expanded "><a href="09.循环结构/循环结构.html"><strong aria-hidden="true">3.1.2.</strong> 循环结构</a></li></ol></li><li class="chapter-item expanded "><a href="10.高级数据类型/高级数据类型.html"><strong aria-hidden="true">3.2.</strong> 高级数据结构</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="11.字符串/字符串.html"><strong aria-hidden="true">3.2.1.</strong> 字符串</a></li><li class="chapter-item expanded "><a href="12.列表/列表.html"><strong aria-hidden="true">3.2.2.</strong> 列表</a></li><li class="chapter-item expanded "><a href="13.元组/元组.html"><strong aria-hidden="true">3.2.3.</strong> 元组</a></li><li class="chapter-item expanded "><a href="14.集合/集合.html"><strong aria-hidden="true">3.2.4.</strong> 集合</a></li><li class="chapter-item expanded "><a href="15.字典/字典.html"><strong aria-hidden="true">3.2.5.</strong> 字典</a></li></ol></li><li class="chapter-item expanded "><a href="16.推导式与函数/推导式与函数.html"><strong aria-hidden="true">3.3.</strong> 推导式与函数</a></li></ol></li><li class="chapter-item expanded "><a href="18.内置函数/内置函数.html"><strong aria-hidden="true">4.</strong> 三级</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="18.内置函数/内置函数.html"><strong aria-hidden="true">4.1.</strong> 内置函数</a></li><li class="chapter-item expanded "><a href="19.文件读写/文件读写.html"><strong aria-hidden="true">4.2.</strong> 文件读写</a></li><li class="chapter-item expanded "><a href="20.进制转换/进制转换.html"><strong aria-hidden="true">4.3.</strong> 进制转换</a></li><li class="chapter-item expanded "><a href="21.异常处理/异常处理.html"><strong aria-hidden="true">4.4.</strong> 异常处理</a></li><li class="chapter-item expanded "><a href="22.排序算法/排序算法.html"><strong aria-hidden="true">4.5.</strong> 排序算法</a></li><li class="chapter-item expanded "><a href="23.二分法查找/二分法查找.html"><strong aria-hidden="true">4.6.</strong> 二分法查找</a></li><li class="chapter-item expanded "><a href="25.常用内建模块/内建模块.html"><strong aria-hidden="true">4.7.</strong> 常用内建模块</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="25.常用内建模块/内建模块.html"><strong aria-hidden="true">4.7.1.</strong> 内建模块</a></li><li class="chapter-item expanded "><a href="25.常用内建模块/math.html"><strong aria-hidden="true">4.7.2.</strong> math</a></li><li class="chapter-item expanded "><a href="25.常用内建模块/time.html"><strong aria-hidden="true">4.7.3.</strong> time</a></li><li class="chapter-item expanded "><a href="25.常用内建模块/os.html"><strong aria-hidden="true">4.7.4.</strong> os</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="26.面向对象编程/类和对象.html"><strong aria-hidden="true">5.</strong> 高级</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="26.面向对象编程/类和对象.html"><strong aria-hidden="true">5.1.</strong> 面向对象编程</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="26.面向对象编程/类和对象.html"><strong aria-hidden="true">5.1.1.</strong> 类和对象</a></li><li class="chapter-item expanded "><a href="26.面向对象编程/类的继承.html"><strong aria-hidden="true">5.1.2.</strong> 类的继承</a></li><li class="chapter-item expanded "><a href="26.面向对象编程/自定义异常.html"><strong aria-hidden="true">5.1.3.</strong> 自定义异常</a></li></ol></li><li class="chapter-item expanded "><a href="27.模块和包/模块.html"><strong aria-hidden="true">5.2.</strong> 模块、包</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="27.模块和包/模块.html"><strong aria-hidden="true">5.2.1.</strong> 模块</a></li><li class="chapter-item expanded "><a href="27.模块和包/包.html"><strong aria-hidden="true">5.2.2.</strong> 包</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="Exam/习题.html"><strong aria-hidden="true">6.</strong> 习题</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Exam/习题.html"><strong aria-hidden="true">6.1.</strong> 习题1</a></li><li class="chapter-item expanded "><a href="Exam/习题2.html"><strong aria-hidden="true">6.2.</strong> 习题2</a></li><li class="chapter-item expanded "><a href="Exam/习题3.html"><strong aria-hidden="true">6.3.</strong> 习题3</a></li><li class="chapter-item expanded "><a href="Exam/习题4.html"><strong aria-hidden="true">6.4.</strong> 习题4</a></li></ol></li><li class="chapter-item expanded "><a href="进制转换.html">进制转换</a></li><li class="chapter-item expanded affix "><a href="附录/appendix.html">附录</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Python 教程 for Junior</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="简介introduction"><a class="header" href="#简介introduction">简介Introduction</a></h1>
<blockquote>
<p><strong>作者</strong>：孙老师</p>
<p><strong>说明</strong>：本课程为孙老师的<code>Python</code>的基础教程讲义，主要面向10岁以上的学生群体，课程的设计参考了<a href="https://www.cie.org.cn/">电子学会</a>的<code>Python</code>考级的设定，内有大量的计算机和编程的基础。帮助有意向去参与考级的学生能顺利通过每一级考试。
如果你是一名大学生，或者你已经掌握了其它编程语言，想学习<code>Python</code>，那么本课程并不适合你。</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="引言"><a class="header" href="#引言">引言</a></h1>
<h2 id="1-什么是编程"><a class="header" href="#1-什么是编程">1. 什么是编程</a></h2>
<p>编程的就是让计算机代码解决某个问题，对某个计算体系规定一定的运算方式，使计算体系按照该计算方式运行，并最终得到相应结果的过程。通俗地去理解，就是用某种计算机程序设计语言编写一个程序让计算机帮助我们完成某件工作、达到某种目的或解决某个问题。当程序员们把程序有机地结合到一起之后，再做一些深度的加工，就形成了我们常说的软件。</p>
<p>在互联网技术高速发展的今天，由计算机编写的程序或者软件已经和我们的生活方方面面有了很大的关系，对社会的发展起到很大的推动作用。比如，为了帮助人们更加快速地处理工作中的文档，Microsoft公司开发了Office办公软件；为了娱乐，很多游戏公司开发了各种各样的游戏软件，像大家比较熟悉的王者荣耀、吃鸡等；又或是为了满足远程的沟通需求，QQ、微信、钉钉等等不同的通讯软件也被开发了出来......</p>
<h2 id="2-计算机编程语言"><a class="header" href="#2-计算机编程语言">2. 计算机编程语言</a></h2>
<p>计算机编程语言是程序设计的最重要的工具，它是指计算机能够接受和处理的、具有一定语法规则的语言。从计算机诞生，计算机语言经历了机器语言、汇编语言和高级语言几个阶段。</p>
<h3 id="机器语言"><a class="header" href="#机器语言">机器语言</a></h3>
<p>机器语言指令是一种二进制代码,由操作码和操作数两部分组成,是机器能直接识别的程序语言或指令代码，无需经过翻译，每一操作码在计算机内部都有相应的电路来完成它，或指不经翻译即可为机器直接理解和接受的程序语言或指令代码。</p>
<p>它大概的样子如下(纯粹由孙老师胡乱编写的，理解意思即可)</p>
<pre><code class="language-shell">1011100111010001011010101001011010100001010001000101011001010101010
0111000101001001011101100101101010101010101010010101010100101001101
1011110101111110101000001101010101011000000001110101011001011011101
0000111111100010100010001111010010001110110000110101000101011001001
</code></pre>
<h3 id="汇编语言"><a class="header" href="#汇编语言">汇编语言</a></h3>
<p>汇编语言， 即第二代计算机语言,属于低级语言，用一些容易理解和记忆的缩写单词来代替一些特定的指令，例如：用<code>ADD</code>代表加法操作指令，<code>SUB</code>代表减法操作指令，<code>MOV</code>代表变量传递等等。然而计算机的硬件并不认识字母符号，这时候就需要一个专门的程序把这些字符变成计算机能够识别的二进制数或机器语言。但是由于各个机器的指令集是不同的，所以汇编语言要和特定的机器指令集一一对应对能正常运行。</p>
<p>下列是一段汇编语言的例子：</p>
<pre><code class="language-shell">MOV AX, X
    MOV BX, OFFSET X
    MOV CX, 9
 L1: INC   BX
       INC   BX
       CMP   AX, [BX]
       JAE   L2
       XCHG  AX, [BX]
 L2: LOOP L1
       MOV Y,  AX
</code></pre>
<h3 id="高级语言"><a class="header" href="#高级语言">高级语言</a></h3>
<p>高级语言是独立于机器的一种面向过程或者面向对象的计算机编程语言, 语法结构参照了数学语言而设计的, 读起来近似于日常的会话。 比如要把两个变量的值相加，用高级语言的表达为 <code>var1 + var2</code>。 所以高级语言比低级语言更具有可读性, 更容易被理解。</p>
<p>目前常见的高级语言有： C语言、 C++、 VB、 C#、 Java、 Python、 Go lang、 Delphi, PHP等等。</p>
<p>下列是一段高级语言的例子（Python）:</p>
<pre><code class="language-Python">_lenght = float(input(&quot;Please input the lenght of Square:&quot;))
_width = float(input(&quot;Please input the width of Square:&quot;))

_area = _length * _width

print(&quot;The area of the Square is %.2f&quot; %_area)
</code></pre>
<p>高级语言并不能直接被机器执行，而要经过一系列的编译或者解释的过程，转换成机器能够直接理解的机器语言之后，才能被运行。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="引言-1"><a class="header" href="#引言-1">引言</a></h1>
<h2 id="1-什么是编程-1"><a class="header" href="#1-什么是编程-1">1. 什么是编程</a></h2>
<p>编程的就是让计算机代码解决某个问题，对某个计算体系规定一定的运算方式，使计算体系按照该计算方式运行，并最终得到相应结果的过程。通俗地去理解，就是用某种计算机程序设计语言编写一个程序让计算机帮助我们完成某件工作、达到某种目的或解决某个问题。当程序员们把程序有机地结合到一起之后，再做一些深度的加工，就形成了我们常说的软件。</p>
<p>在互联网技术高速发展的今天，由计算机编写的程序或者软件已经和我们的生活方方面面有了很大的关系，对社会的发展起到很大的推动作用。比如，为了帮助人们更加快速地处理工作中的文档，Microsoft公司开发了Office办公软件；为了娱乐，很多游戏公司开发了各种各样的游戏软件，像大家比较熟悉的王者荣耀、吃鸡等；又或是为了满足远程的沟通需求，QQ、微信、钉钉等等不同的通讯软件也被开发了出来......</p>
<h2 id="2-计算机编程语言-1"><a class="header" href="#2-计算机编程语言-1">2. 计算机编程语言</a></h2>
<p>计算机编程语言是程序设计的最重要的工具，它是指计算机能够接受和处理的、具有一定语法规则的语言。从计算机诞生，计算机语言经历了机器语言、汇编语言和高级语言几个阶段。</p>
<h3 id="机器语言-1"><a class="header" href="#机器语言-1">机器语言</a></h3>
<p>机器语言指令是一种二进制代码,由操作码和操作数两部分组成,是机器能直接识别的程序语言或指令代码，无需经过翻译，每一操作码在计算机内部都有相应的电路来完成它，或指不经翻译即可为机器直接理解和接受的程序语言或指令代码。</p>
<p>它大概的样子如下(纯粹由孙老师胡乱编写的，理解意思即可)</p>
<pre><code class="language-shell">1011100111010001011010101001011010100001010001000101011001010101010
0111000101001001011101100101101010101010101010010101010100101001101
1011110101111110101000001101010101011000000001110101011001011011101
0000111111100010100010001111010010001110110000110101000101011001001
</code></pre>
<h3 id="汇编语言-1"><a class="header" href="#汇编语言-1">汇编语言</a></h3>
<p>汇编语言， 即第二代计算机语言,属于低级语言，用一些容易理解和记忆的缩写单词来代替一些特定的指令，例如：用<code>ADD</code>代表加法操作指令，<code>SUB</code>代表减法操作指令，<code>MOV</code>代表变量传递等等。然而计算机的硬件并不认识字母符号，这时候就需要一个专门的程序把这些字符变成计算机能够识别的二进制数或机器语言。但是由于各个机器的指令集是不同的，所以汇编语言要和特定的机器指令集一一对应对能正常运行。</p>
<p>下列是一段汇编语言的例子：</p>
<pre><code class="language-shell">MOV AX, X
    MOV BX, OFFSET X
    MOV CX, 9
 L1: INC   BX
       INC   BX
       CMP   AX, [BX]
       JAE   L2
       XCHG  AX, [BX]
 L2: LOOP L1
       MOV Y,  AX
</code></pre>
<h3 id="高级语言-1"><a class="header" href="#高级语言-1">高级语言</a></h3>
<p>高级语言是独立于机器的一种面向过程或者面向对象的计算机编程语言, 语法结构参照了数学语言而设计的, 读起来近似于日常的会话。 比如要把两个变量的值相加，用高级语言的表达为 <code>var1 + var2</code>。 所以高级语言比低级语言更具有可读性, 更容易被理解。</p>
<p>目前常见的高级语言有： C语言、 C++、 VB、 C#、 Java、 Python、 Go lang、 Delphi, PHP等等。</p>
<p>下列是一段高级语言的例子（Python）:</p>
<pre><code class="language-Python">_lenght = float(input(&quot;Please input the lenght of Square:&quot;))
_width = float(input(&quot;Please input the width of Square:&quot;))

_area = _length * _width

print(&quot;The area of the Square is %.2f&quot; %_area)
</code></pre>
<p>高级语言并不能直接被机器执行，而要经过一系列的编译或者解释的过程，转换成机器能够直接理解的机器语言之后，才能被运行。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python简介"><a class="header" href="#python简介">Python简介</a></h1>
<p>Python由荷兰数学和计算机科学研究学会的吉多·范罗苏姆于1990年代初设计，作为一门叫做ABC语言的替代品; 是一门简单，易学, 开源的高级语言。</p>
<ul>
<li>学习难度低，不需要太高的基础</li>
<li>解释型语言，可移植性高，不需要考虑机器的差异</li>
<li>代码规范性高，可读性强</li>
<li>面向对象语言，函数式编程</li>
<li>可粘合其它语言开发的系统，被称作“胶水语言”</li>
<li>生态圈强大，可应用的领域有软件开发、后端开发、数据科学、人工智能、机器学习、数据采集等</li>
</ul>
<p>在正式学习之前, 给各位同学提几个建议</p>
<ul>
<li>学习过程中，尽量用英语表达各种输出</li>
<li>多做练习</li>
<li>不要怕犯错，学会理解解释器抛出的各种异常信息</li>
<li>遇到问题时，先自己想办法找解决方案</li>
</ul>
<h2 id="安装python"><a class="header" href="#安装python">安装Python</a></h2>
<p>在开始学习Python编程之前，首先要在自己的计算机上安装Python的解释器环境。 Python的解释器有好多种，如IDLE、 VS Code、 Pycharm, Jupyter NoteBook等等。这里我们选择使用官方提供的解释器IDLE做为我们学习Python的环境。</p>
<h3 id="windows系统"><a class="header" href="#windows系统">Windows系统</a></h3>
<p>Python的官方网站为<a href="https://www.python.org/">python.org</a>, 在登录之后，点击Download，并选择Windows。</p>
<p><img src="01.Python%E7%AE%80%E4%BB%8B/./images/PythonHomePage.png" alt="Python Home Page" /></p>
<p>这里我们选择Python3.x版本， 因为2.0版本已经不再更新维护，未来3.0版才是主流版本。</p>
<p><img src="01.Python%E7%AE%80%E4%BB%8B/./images/ChooseVersion.png" alt="Choose Version" /></p>
<p>点击进入下一个页面之后，找到Files部分, 根据自己系统的版本选择32-bit还是64位的安装包。</p>
<p><img src="01.Python%E7%AE%80%E4%BB%8B/./images/ChooseFile.png" alt="Choose File" /></p>
<p>这里也提供了两个安装包的下载链接，可以点击下载:</p>
<p><a href="https://www.python.org/ftp/python/3.10.7/python-3.10.7.exe">32位Windows操作系统</a></p>
<p><a href="https://www.python.org/ftp/python/3.10.7/python-3.10.7-amd64.exe">64位Windows操作系统</a></p>
<details>
<summary>如何查看自己计算机系统版本是32位还是64位?</summary>
在计算机桌面下方的工具栏中点击开始菜单，在Windows系统文件夹下找到控制面板，并打开:
<image src="./images/StartMenu.png">
<p>在控制面板里，依次点击【系统和安全】-&gt;【系统】，就能打开系统信息面板查看自己系统的信息。</p>
<image src="./images/System.png">
<image src="./images/SystemSelection.png">
<image src="./images/SystemType.png">
</details>
<p>下载好Python的编译器安装文件之后，双击打开Python环境的安装向导，选择自定义安装，切记一定要勾选“Add Python 3.X to PATH”，否则需要手动添加环境变量，会比较麻烦。</p>
<p><img src="01.Python%E7%AE%80%E4%BB%8B/./images/BeginInstallation.png" alt="Begin Installation" /></p>
<p><img src="01.Python%E7%AE%80%E4%BB%8B/./images/InstallPIP.png" alt="InstallPIP" /></p>
<p><img src="01.Python%E7%AE%80%E4%BB%8B/./images/InstallLocation.png" alt="InstallLocation" /></p>
<p><img src="01.Python%E7%AE%80%E4%BB%8B/./images/CompleteInstallation.png" alt="Complete Installation" /></p>
<p>安装完成之后，打开Windows的<em><strong>命令提示符</strong></em>或者<em><strong>PowerShell</strong></em>, 输入<code>python -V</code>或者<code>python --version</code>，如果返回了Python解释器的版本，例如“Python 3.10.7”, 说明安装已经成功。</p>
<p><img src="01.Python%E7%AE%80%E4%BB%8B/./images/CheckVersion.png" alt="Check Version" /></p>
<h3 id="macos环境"><a class="header" href="#macos环境">MacOS环境</a></h3>
<p>MacOS系统是自带Python 2版本的，但是我们需要学习的是Python 3版本，可以参考上面的方法，在官方的<a href="https://www.python.org/downloads/macos/">下载页面</a>找到对应的版本下载，并安装即可。
需要注意的是，在MacOS的<em><strong>终端</strong></em>直接执行<code>python</code>，调用的是Python 2版本的解释器。想要调用Python 3，必须输入<code>python3</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第一个python程序-hello-world"><a class="header" href="#第一个python程序-hello-world">第一个Python程序： hello, world</a></h1>
<p><a href="02.HelloWorld/.././01.Python%E7%AE%80%E4%BB%8B/Python%E7%AE%80%E4%BB%8B.html">上一章节</a>，我们了解了Python的特性和生态，也学会了如何在自己的计算机上安装Python的官方解释器。接下来我们正式开启Python编程的学习。</p>
<p>但：</p>
<p><font size="4"><strong>所有的代码编写必须都要用英文输入法！！！</strong></font></p>
<p><font size="4"><strong>所有的代码编写必须都要用英文输入法！！！</strong></font></p>
<p><font size="4"><strong>所有的代码编写必须都要用英文输入法！！！</strong></font></p>
<p>重要的事情说三遍；除了字符串的内容，所有的编程语言必须用英文输入法编写代码，包括包围在字符串左右两边的引号（单引号和双引号）。</p>
<h2 id="idle"><a class="header" href="#idle">IDLE</a></h2>
<p>我们要使用的集成开发环境是官方提供的IDLE，在正式学习之后，要知道该怎么打开它。</p>
<p>点击 <strong>【开始】</strong> 菜单，找到安装的 <strong>【Python 3.x】</strong> 文件夹，点击 <strong>【IDLE】</strong> 打开它：</p>
<p><img src="02.HelloWorld/./images/FindIDLE.png" alt="FindIDLE" /></p>
<p>如下图，我们可以看到这个简单甚至简陋的Python自带的IDLE的界面；它会在本教程伴随我们一直到最后。</p>
<p><img src="02.HelloWorld/./images/IDLE.png" alt="IDLE" /></p>
<p>从IDLE的界面，我们可以看到Python的版本信息以及当前的运行环境信息，同时也有一些提示命令。
在上述信息的下方，我们看到<code>&gt;&gt;&gt;</code>这样的符号，这个是Python语句输入的提示符，它的后面会有一光标在不停地闪烁，表示我们在该位置可以输入命令或者代码。</p>
<h2 id="hello-world"><a class="header" href="#hello-world">hello, world</a></h2>
<p>几乎在学习所有编程语言的最初，都会让我们先学会写一个简单的程序输出<code>hello, world</code>这样一句话，因为这段代码是伟大的丹尼斯·里奇（C语言之父，和肯·汤普森一起开发了Unix操作系统）和布莱恩·柯尼汉（awk语言的发明者）在他们的不朽著作The <code>C Programming Language</code> 中写的第一段代码。Python也并不例外，但是在Python中，不需要像有些语言那样先构造一个复杂的语法结构，我们只需要下面一行代码就可以实现：</p>
<pre><code class="language-Python">print(&quot;hello, world&quot;)
</code></pre>
<p>IDLE给我们提供了两种编程环境，帮助我们去学习Python语言，它们分别是<em><strong>交互式环境</strong></em>和<em><strong>文本编辑环境</strong></em>，我们下面结合这两种编程环境的介绍，来完成我们在Python中的第一个程序。</p>
<h3 id="交互式环境"><a class="header" href="#交互式环境">交互式环境</a></h3>
<p>交互式环境的意思就是，我们输入了一行代码，敲击回车键之后，代码会马上被执行, 如果执行的代码有结果生成，那么这个结果会直接显示在窗口里。</p>
<p>我们打开IDLE之后所看到的界面就是一个交互式环境，我们可以在输入提示符之后，输入代码再回车(#后面的内容不需要输入)：</p>
<pre><code class="language-Python">&gt;&gt;&gt;print(&quot;hello, world&quot;) #输入完成后敲回车
#下面一行为输出的结果
hello, world
</code></pre>
<p><img src="02.HelloWorld/./images/Interactive.png" alt="Interactive" /></p>
<p>这里需要注意的是，我们只能在最后一个输入提示符<code>&gt;&gt;&gt;</code>之后输入代码，即使在这之前有很多个<code>&gt;&gt;&gt;</code>并没有我们输入的内容，就算是把光标移过去也是不可以的。</p>
<p>交互式环境的编程有很大的局限性，因为他每次只能写一行代码，或者是一个代码块，当我们要写的程序行数很多的时候就会很麻烦，一旦写的代码有错误，不能回去修改，只能重写。但是交互式编程并不是不可取的，它能够快速把代码执行的结果反馈出来，在这一点上是很便利的。</p>
<h3 id="文本编辑环境"><a class="header" href="#文本编辑环境">文本编辑环境</a></h3>
<p>文本编程是指在文本编程器中编写代码并保存成文件之后，通过编程器编译成可执行的程序文件，或者通过解释器直接执行该程序文件的一种编程方式，文本编程也可以被叫作脚本式编程或者文件式编程，这种编程方式要求代码必须编写成一个纯文本文件，不能含有除了代码之外的任何信息。所以它对编辑文本的工具软件是有要求的，比如Windows系统中自带的<em>记事本</em>就可以进行代码的编写，然而<em>写字板</em>或者Office套件中的<em>Word</em>就不可以，因为这两种软件保存的文件中包含了其它除代码之外的内容。</p>
<p>IDLE中同样提供了这样的文本编辑环境，可以根据下列步骤进行操作：</p>
<ol>
<li>
<p>在IDLE的菜单栏中，选择 <strong>【File】</strong>, 然后点击 <strong>【New File】</strong> 打开一个文件编辑窗口:
<img src="02.HelloWorld/./images/NewFile.png" alt="New File" /></p>
</li>
<li>
<p>在打开的文件编辑窗口之后，输入代码 <code>print(&quot;hello, world&quot;)</code>：
<img src="02.HelloWorld/./images/TXTCoding.png" alt="TXTCoding" /></p>
</li>
<li>
<p>完成代码编写之后，保存文件，在菜单栏中 <strong>【File】</strong>, 然后点击 <strong>【Save】</strong>，然后输入保存的文件名字，一定要注意 <strong>【保存类型】</strong> 一定是 <strong>Python files(<em>.py;</em>.pyw,*.pyi)</strong> :
<img src="02.HelloWorld/./images/SavingFile.png" alt="SavingFile" /></p>
</li>
<li>
<p>保存好文件之后，就可以运行程序了，在菜单栏中选择 <strong>【Run】</strong>, 然后点击 <strong>【Run Module】</strong> 就可以了，该操作的快捷键为 <strong>F5</strong>:
<img src="02.HelloWorld/./images/RunModule.png" alt="RunModule" /></p>
</li>
<li>
<p>运行完成之后，结果会输出在IDLE中：
<img src="02.HelloWorld/./images/ReturnResult.png" alt="Return Result" /></p>
</li>
</ol>
<p>文本式编程是一种比较灵活的编程方式，一旦我们编写完代码运行之后发现了错误，就可以重新打开文件去修改：</p>
<ol>
<li>
<p>在菜单栏中，选择 <strong>【File】</strong>，点击 <strong>【Open】</strong>:
<img src="02.HelloWorld/./images/OpenFile.png" alt="Open File" /></p>
</li>
<li>
<p>选择要打开的文件:
<img src="02.HelloWorld/./images/ChooseFile.png" alt="Choose File" /></p>
</li>
<li>
<p>修改代码，之后再运行即可：
<img src="02.HelloWorld/./images/EditCode.png" alt="Edit Code" /></p>
</li>
</ol>
<p>对于一个的程序员来讲，找到一个强大的集成开发环境是必不可少的先决条件。目前有几款比较流行的集成开发工具都支持Python编程，比如微软的<em><strong>Visual Studio Code</strong></em> (简称<em><strong>VS Code</strong></em>)，或者<a href="https://www.jetbrains.com/">JetBrains</a>的<em><strong>PyCharm</strong></em>， 这些都是很强大且专业的工具。</p>
<p>有兴趣的同学可以点击下列链接了解上述提到的工具：</p>
<p><a href="https://code.visualstudio.com/">VS Code下载链接</a></p>
<p><a href="https://www.jetbrains.com/pycharm/download/">Pycharm下载链接</a></p>
<h2 id="总结"><a class="header" href="#总结">总结</a></h2>
<p>我们已经把第一个Python程序运行起来了，同时出了解了两种不同的编程环境。同学们可以自由发挥，用<code>print</code>函数输出一些其它内容，注意要用引号引上。</p>
<p>可以尝试把下列代码通过文本式编程编写并运行，看看我们能看到什么？
注：两个<code>&quot;&quot;&quot;</code>之间的内容可以不用写， 且不要直接复制粘贴到交互式的环境中！</p>
<pre><code class="language-Python">&quot;&quot;&quot;
第一个海龟画图程序：
1. 注意语句的缩进
2. 可以把range后面括号里的值改成其它数值
3. 可以把left后面括号里的值改成其它数值
4. 可以把left替换成right
&quot;&quot;&quot;
import turtle as t

colors = ['red', 'green', 'orange', 'blue']

for i in range(100):
    t.color(colors[i%4])
    t.forward(i)
    t.left(90)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类型和变量"><a class="header" href="#类型和变量">类型和变量</a></h1>
<p>一个计算机程序是由<strong>算法</strong>+<strong>数据结构</strong>组成，在我们编写完程序之后，在运行它之前，它仅仅是一段静态的代码，只是步骤和方法的描述，并没有真正地帮我们解决问题。只有在运行起来之后，才能开始做事情，就像一副写在书上的《西红柿炒鸡蛋》的菜谱，我们光去看它是没有用的，只有我们买好原材料（西红柿和鸡蛋）之后，去厨房真正地去做它才能最终吃到好吃的西红柿炒鸡蛋。</p>
<p>细心的同学应该已经发现了，如果把程序比做菜谱，那么原材料（西红柿和鸡蛋）又应该是什么的比喻呢？<strong>实际上讲，我们编写的程序就是为了用来处理数据</strong>, 上一段中提到的原材料就是数据的比喻，而当程序运行起来并开始处理数据之后，它就从静态变为了动态，那么这个动态运行活动就叫做进程：</p>
<p><em><strong>进程 = 程序 + 数据</strong></em><br/>
<em><strong>process = program + data</strong></em><br/>
或者<br/>
<em><strong>进程 = 算法 + 数据结构 + 数据</strong></em><br/>
<em><strong>process = algorithm + data structure + data</strong></em></p>
<p>那么什么是数据呢？你可能第一个想到的就是数学里学到的数值，如1，2，3...43.23，50，1000等等， 其实你的理解并不是错的，只是仅仅列出了数据的其中一种类型。</p>
<p>计算机中的数据不仅仅是狭义上的数字，还可以是具有一定意义的文字，字母，数字符号的组合、图形、图像、音频、视频等等。总之，根据百度百科的解释，数据是事实和观察的结果，是对客观事物的逻辑归纳，是用来表示客观事物的未经加工的原始素材。</p>
<p>每一种编程语言都有自己内建的基本数据类型，所以我们学习Python的第一个重要的内容就是<strong>基本数据类型</strong>。</p>
<h2 id="基本数据类型basic-datatypes"><a class="header" href="#基本数据类型basic-datatypes">基本数据类型Basic DataTypes</a></h2>
<h3 id="整型int"><a class="header" href="#整型int">整型int</a></h3>
<p>整型，英文为<code>integer</code>，是指没有小数部分的数值型数据，比如1，2，3，100，44221等等，但是1.0， 2.0， 10.0这些数值则不是整型，因为它们都带有小数部分，即使他们和整数部分的值大小相等。一个<code>integer</code>是集合 Z = {..., -2, -1, 0, 1, 2, ...} 中的一个数。在Python中，用<code>int</code>来表示整型的类型名，它是Python中唯一的一个整型类型，可以处理任意大小的整数。</p>
<p>可以在IDLE中直接输入一个整型数据，再回车:</p>
<pre><code class="language-Python">&gt;&gt;&gt; 1
1
&gt;&gt;&gt; 2
2
&gt;&gt;&gt; 100
100
&gt;&gt;&gt; 888888888888888888888
888888888888888888888
</code></pre>
<p>Python中同样可以支持二进制、八进制和十六进制的表示法，如0b1000(二进制，换算成十进制为8)，0o742(八进制，换算成十进制为482)， 0xFAE(十六进制，换算成十进制为4014)。其中<code>0b</code>、<code>0o</code>和<code>0x</code>分别为二进制、八进制和十六进制的前缀，如果不写的话，二进制和八进制会被当做十进制处理，十六进制则会报错。</p>
<pre><code class="language-Python">&gt;&gt;&gt; 0b1000
8
&gt;&gt;&gt; 0o742
482
&gt;&gt;&gt; 0xFAE
4014
</code></pre>
<h3 id="浮点型float"><a class="header" href="#浮点型float">浮点型float</a></h3>
<p>浮点型，英文为<code>float</code>，是指具有小数部分的数值型数据，比如1.414、3.1415926、2.718281828459045、4.000等等。在Python中，用<code>float</code>来表示浮点型的类型名，它是Python中唯一的一个浮点型类型，可以处理任意精度的浮点数。</p>
<pre><code class="language-shell">&gt;&gt;&gt; 1.414
1.414
&gt;&gt;&gt; 3.1415926
3.1415926
&gt;&gt;&gt; 2.718281828459045
2.718281828459045
&gt;&gt;&gt; 4.000
4.0
</code></pre>
<p>Python中的浮点型支持十进制和指数型两种表示法，指数型也叫科学记数法，属于超纲内容，这里就不做过多介绍了，感兴趣的同学可以自行研究一下。</p>
<h3 id="字符串str"><a class="header" href="#字符串str">字符串str</a></h3>
<p>字符串，英文为<code>string</code>，是指由文字、字母、数字以及一系列符号组成的一串字符，这些字符由单引号或者双引号括起来，比如“abc”、‘banana’、‘1000’等等。在Python中，用<code>str</code>来表示字符串的类型名。需要特别注意的是，只要用引号括起来之后，就是字符串，即使里面的字符看起来看是一个整型或者浮点型。</p>
<pre><code class="language-Python">&gt;&gt;&gt; &quot;abc&quot;
'abc'
&gt;&gt;&gt; 'banana'
'banana'
&gt;&gt;&gt; '1000'
'1000'
</code></pre>
<p>如果在字符串中需要用到引号(<code>&quot;</code>或<code>'</code>)的话，可以用转义的方式(<code>\'</code>或<code>\&quot;</code>)，或者在需要用到单引号的时候，用双引号把字符串括起来，反之亦然:</p>
<pre><code class="language-Python">&gt;&gt;&gt; 'I\'m a student.'
&quot;I'm a student.&quot;
&gt;&gt;&gt; &quot;I\'m a student.&quot;
&quot;I'm a student.&quot;
</code></pre>
<h3 id="布尔型bool"><a class="header" href="#布尔型bool">布尔型bool</a></h3>
<p>布尔型，英文为boolean，用来描述真假的一种数据，也叫逻辑型，它只有两个值: <code>True</code> 和 <code>False</code>。这里要注意一定是只有首字母大写，如果写成了true、flase、TURE或者是FaLSe都是错误的。在Python中，用<code>bool</code>表示布尔型的类型名。</p>
<pre><code class="language-Python">&gt;&gt;&gt; True
True
&gt;&gt;&gt; False
False
</code></pre>
<p>如果输入错误，会报错，如输入<code>true</code>:</p>
<pre><code class="language-shell">Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
NameError: name 'true' is not defined
</code></pre>
<p>在Python中，<code>bool</code>类型其实是<code>int</code>类型的子类型，一般情况下，<code>False</code>就是<code>0</code>, <code>True</code>就是<code>1</code>；但是所有的非0的数值都可以认为是真逻辑值，这一点我们会在下一章节中详细说明。</p>
<h3 id="空值none"><a class="header" href="#空值none">空值None</a></h3>
<p>空值，英文为<code>None</code>，是Python中一个很特殊的类型，它只有一个值，即<code>None</code>，表示空对象，什么都没有。但是数据为空并不是空值，比如空字符串<code>&quot;&quot;</code>，它是字符串类型，并不是空值类型。在Python中，用<code>NoneType</code>表示空值的类型名。</p>
<pre><code class="language-Python">&gt;&gt;&gt; None
&gt;&gt;&gt; 
&gt;&gt;&gt; &quot;&quot;
''
</code></pre>
<p>空值并不是一个没有意义的类型，相反，需要用到它的地方有很多。比如，调用函数的时候，不想给某个参数传递值，但是这个参数没有默认的值，所以传值是必须的，那么就可以把空值传给它。关于这一点，我们以后遇到的时候，结合实际用法就可以理解得更好。</p>
<h2 id="变量variables"><a class="header" href="#变量variables">变量Variables</a></h2>
<p>在计算机编程中，变量就是一个数据的载体，也就是一块用来保存数据的内存空间，它可以被读取和修改。一个变量有两个最基本的要素:<strong>名字</strong>和<strong>类型</strong>。</p>
<p>我们可以把变量想像成一个用来存放数据的容器，像下图一样:</p>
<p><img src="03.%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8F%98%E9%87%8F/./images/variable.png" alt="Variables" /></p>
<p>他在内存中的表现是这样的:</p>
<svg width="380" height="255" xmlns="http://www.w3.org/2000/svg">
 <g>
  <title>Layer 1</title>
  <path stroke="#000" fill="#fff" stroke-width="3" d="m163.49998,41.5l185.00002,0l0,171.3948c-92.50001,0 -92.50001,65.30456 -185.00002,28.1997l0,-199.5945z" id="svg_2"/>
  <rect stroke="#000" fill="#fff" stroke-width="3" x="178.5" y="70.5" width="71" height="24" id="svg_3"/>
  <text fill="#000000" stroke="#000" stroke-width="0" x="227" y="27.5" id="svg_9" font-size="24" font-family="Noto Sans JP" text-anchor="start" xml:space="preserve">内存</text>
  <text fill="#000000" stroke="#000" stroke-width="0" x="177.5" y="63.5" id="svg_10" font-size="18" font-family="'Stick No Bills'" text-anchor="start" xml:space="preserve">存储单元</text>
  <text fill="#000000" stroke="#000" stroke-width="0" x="262.5" y="63.5" id="svg_11" font-size="18" font-family="'Stick No Bills'" text-anchor="start" xml:space="preserve">地址</text>
  <text fill="#000000" stroke="#000" stroke-width="0" x="255.5" y="87.5" id="svg_11" font-size="12" font-family="'Stick No Bills'" text-anchor="start" xml:space="preserve">0xADA43B01</text>
  <text fill="#000000" stroke="#000" stroke-width="0" x="255.5" y="116.5" id="svg_11" font-size="12" font-family="'Stick No Bills'" text-anchor="start" xml:space="preserve">0xADA43B02</text>
  <text fill="#000000" stroke="#000" stroke-width="0" x="255.5" y="144.5" id="svg_11" font-size="12" font-family="'Stick No Bills'" text-anchor="start" xml:space="preserve">0xADA43B03</text>
  <text fill="#000000" stroke="#000" stroke-width="0" x="255.5" y="171.5" id="svg_11" font-size="12" font-family="'Stick No Bills'" text-anchor="start" xml:space="preserve">0xADA43B04</text>
  <path stroke="#000" stroke-width="3" fill="#fff" d="m30.02751,73.32114l21.56375,-30.54866l86.43623,0l0,152.99999l-107.99998,0l0,-122.45133l0,0.00001z" id="svg_12"/>
  <text style="cursor: move;" fill="#000000" stroke="#0" stroke-width="3" x="56.5" y="27.5" id="svg_13" font-size="24" font-family="'Syne'" text-anchor="start" xml:space="preserve">程序</text>
  <text fill="#000000" stroke="#0" stroke-width="3" x="44.5" y="91.5" id="svg_16" font-size="18" font-family="'Stick No Bills'" text-anchor="start" xml:space="preserve">a = 1</text>
  <text fill="#000000" stroke="#0" stroke-width="3" x="189.5" y="87.5" id="svg_17" font-size="12" font-family="'Stick No Bills'" text-anchor="start" xml:space="preserve">00000001</text>
  <rect stroke="#000" fill="#fff" stroke-width="3" x="178.5" y="98.5" width="71" height="24" id="svg_1"/>
  <rect stroke="#000" fill="#fff" stroke-width="3" x="178.5" y="126.5" width="71" height="24" id="svg_4"/>
  <rect stroke="#000" fill="#fff" stroke-width="3" x="178.5" y="154.5" width="71" height="24" id="svg_5"/>
  <text xml:space="preserve" text-anchor="start" font-family="'Stick No Bills'" font-size="18" id="svg_6" y="197.5" x="204" stroke-width="0" stroke="#0" fill="#000000">......</text>
  <text xml:space="preserve" text-anchor="start" font-family="'Stick No Bills'" font-size="18" id="svg_7" y="197.5" x="273" stroke-width="0" stroke="#0" fill="#000000">......</text>
  <path transform="rotate(88.93 138.778 85.4919)" stroke="#0" id="svg_14" d="m132.57303,85.39116l6.20516,-41.88579l6.20516,41.88579l-3.10258,0l0,42.08734l-6.20516,0l0,-42.08734l-3.10258,0z" stroke-width="3" fill="#000000"/>
 </g>
</svg>
<p>上图中的<code>a</code>就是变量的名字，在Python中，变量的类型不是在声明它的时候给出，而且会根据我们赋给它的值变化，比如<code>a = 1</code>，这时变量<code>a</code>的类型是整型<code>int</code>，如果我们重新给它赋值<code>a=&quot;apple&quot;</code>，那它的类型就变成了字符串<code>str</code>；我们也可以通过一些内建函数来改变它的类型，这一点我们后面很快就会讲到。</p>
<h3 id="变量命名"><a class="header" href="#变量命名">变量命名</a></h3>
<p>每一个变量都需要提前定义，首先要给它取一个名字，方便我们在后面使用它。变量的命名是要遵循下列规则的：</p>
<ul>
<li>变量的名字由字母、下划线<code>_</code>和数字组成，但是不能以数字开头。这里的字母不单单是26个英文字母，它指的是在Unicode(也被称作万国码)字符集里的所有字母，包括中文、英文、日文、希腊字母、德文等等，范围非常广，但是像<code>@</code>、<code>#</code>、<code>$</code>这些字符是不能出现在变量名中的，我们强烈建议起名的时候只用英文字母。</li>
<li>变量的名字是大小写敏感的，比如<code>A</code>和<code>a</code>是两不同的变量。</li>
<li>变量的名字不要使用Python中已经保留的关键字，也不要用自定义的函数、类名。</li>
</ul>
<p>我们可以通过下面的方式查看Python中有哪些保留的关键字:</p>
<pre><code class="language-Python">&gt;&gt;&gt; import keyword
&gt;&gt;&gt; keyword.kwlist
['False', 'None', 'True', '__peg_parser__', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']
</code></pre>
<p>有关我自定义函数和类名的限制，我们以后会讲到。</p>
<h3 id="变量赋值"><a class="header" href="#变量赋值">变量赋值</a></h3>
<p>可以通过执行赋值表达式来修改变量中存储的值，Python中的赋值运算符为<code>=</code>，这个等号并不是我们数学上的<strong>等于</strong>，千万不要混淆。给变量赋值的语法为:</p>
<p><em><strong>变量 = 值</strong></em><br/>
<em><strong>变量 = 变量</strong></em><br/>
<em><strong>变量 = 表达式</strong></em></br>
<em><strong>变量 = 函数返回值</strong></em><br/></p>
<p>在赋值的时候，变量<strong>永远要写在左边</strong>，右边是要赋与它的值。</p>
<pre><code class="language-Python">&gt;&gt;&gt; a = 1 #直接用值给变量赋值
&gt;&gt;&gt; print(a)
1
&gt;&gt;&gt; b = a #用变量的值给变量赋值
&gt;&gt;&gt; print(b)
1
&gt;&gt;&gt; c = a + b #用表达式给变量赋值
&gt;&gt;&gt; print(c)
2
&gt;&gt;&gt; a = a + 1 #同样是用表达式给a赋值
&gt;&gt;&gt; print(a)
2
&gt;&gt;&gt; d = str(a) #用函数返回值给变量赋值
&gt;&gt;&gt; print(d)
'2'
</code></pre>
<p>看到上面的例子，你是不是对于<code>a = a + 1</code>不太理解？没关系，我来给你解释：</p>
<p>赋值表达式在执行过程中，是先要执行赋值符<code>=</code>右边的代码的，当右边的代码执行完并得到结果之后，就会把这个结果赋值给赋值符<code>=</code>左边的变量。所以在<code>a = a + 1</code>中，最初变量<code>a</code>存储的值为<code>1</code>，先是使用了变量<code>a</code>，把它加了1之后得到<code>2</code>，再把字面量值<code>2</code>重新赋值给了变量<code>a</code>。</p>
<p>总之，变量是一种方便使用的占位符，用于引用计算机的内存地址来存储值。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类型和变量-1"><a class="header" href="#类型和变量-1">类型和变量</a></h1>
<p>一个计算机程序是由<strong>算法</strong>+<strong>数据结构</strong>组成，在我们编写完程序之后，在运行它之前，它仅仅是一段静态的代码，只是步骤和方法的描述，并没有真正地帮我们解决问题。只有在运行起来之后，才能开始做事情，就像一副写在书上的《西红柿炒鸡蛋》的菜谱，我们光去看它是没有用的，只有我们买好原材料（西红柿和鸡蛋）之后，去厨房真正地去做它才能最终吃到好吃的西红柿炒鸡蛋。</p>
<p>细心的同学应该已经发现了，如果把程序比做菜谱，那么原材料（西红柿和鸡蛋）又应该是什么的比喻呢？<strong>实际上讲，我们编写的程序就是为了用来处理数据</strong>, 上一段中提到的原材料就是数据的比喻，而当程序运行起来并开始处理数据之后，它就从静态变为了动态，那么这个动态运行活动就叫做进程：</p>
<p><em><strong>进程 = 程序 + 数据</strong></em><br/>
<em><strong>process = program + data</strong></em><br/>
或者<br/>
<em><strong>进程 = 算法 + 数据结构 + 数据</strong></em><br/>
<em><strong>process = algorithm + data structure + data</strong></em></p>
<p>那么什么是数据呢？你可能第一个想到的就是数学里学到的数值，如1，2，3...43.23，50，1000等等， 其实你的理解并不是错的，只是仅仅列出了数据的其中一种类型。</p>
<p>计算机中的数据不仅仅是狭义上的数字，还可以是具有一定意义的文字，字母，数字符号的组合、图形、图像、音频、视频等等。总之，根据百度百科的解释，数据是事实和观察的结果，是对客观事物的逻辑归纳，是用来表示客观事物的未经加工的原始素材。</p>
<p>每一种编程语言都有自己内建的基本数据类型，所以我们学习Python的第一个重要的内容就是<strong>基本数据类型</strong>。</p>
<h2 id="基本数据类型basic-datatypes-1"><a class="header" href="#基本数据类型basic-datatypes-1">基本数据类型Basic DataTypes</a></h2>
<h3 id="整型int-1"><a class="header" href="#整型int-1">整型int</a></h3>
<p>整型，英文为<code>integer</code>，是指没有小数部分的数值型数据，比如1，2，3，100，44221等等，但是1.0， 2.0， 10.0这些数值则不是整型，因为它们都带有小数部分，即使他们和整数部分的值大小相等。一个<code>integer</code>是集合 Z = {..., -2, -1, 0, 1, 2, ...} 中的一个数。在Python中，用<code>int</code>来表示整型的类型名，它是Python中唯一的一个整型类型，可以处理任意大小的整数。</p>
<p>可以在IDLE中直接输入一个整型数据，再回车:</p>
<pre><code class="language-Python">&gt;&gt;&gt; 1
1
&gt;&gt;&gt; 2
2
&gt;&gt;&gt; 100
100
&gt;&gt;&gt; 888888888888888888888
888888888888888888888
</code></pre>
<p>Python中同样可以支持二进制、八进制和十六进制的表示法，如0b1000(二进制，换算成十进制为8)，0o742(八进制，换算成十进制为482)， 0xFAE(十六进制，换算成十进制为4014)。其中<code>0b</code>、<code>0o</code>和<code>0x</code>分别为二进制、八进制和十六进制的前缀，如果不写的话，二进制和八进制会被当做十进制处理，十六进制则会报错。</p>
<pre><code class="language-Python">&gt;&gt;&gt; 0b1000
8
&gt;&gt;&gt; 0o742
482
&gt;&gt;&gt; 0xFAE
4014
</code></pre>
<h3 id="浮点型float-1"><a class="header" href="#浮点型float-1">浮点型float</a></h3>
<p>浮点型，英文为<code>float</code>，是指具有小数部分的数值型数据，比如1.414、3.1415926、2.718281828459045、4.000等等。在Python中，用<code>float</code>来表示浮点型的类型名，它是Python中唯一的一个浮点型类型，可以处理任意精度的浮点数。</p>
<pre><code class="language-shell">&gt;&gt;&gt; 1.414
1.414
&gt;&gt;&gt; 3.1415926
3.1415926
&gt;&gt;&gt; 2.718281828459045
2.718281828459045
&gt;&gt;&gt; 4.000
4.0
</code></pre>
<p>Python中的浮点型支持十进制和指数型两种表示法，指数型也叫科学记数法，属于超纲内容，这里就不做过多介绍了，感兴趣的同学可以自行研究一下。</p>
<h3 id="字符串str-1"><a class="header" href="#字符串str-1">字符串str</a></h3>
<p>字符串，英文为<code>string</code>，是指由文字、字母、数字以及一系列符号组成的一串字符，这些字符由单引号或者双引号括起来，比如“abc”、‘banana’、‘1000’等等。在Python中，用<code>str</code>来表示字符串的类型名。需要特别注意的是，只要用引号括起来之后，就是字符串，即使里面的字符看起来看是一个整型或者浮点型。</p>
<pre><code class="language-Python">&gt;&gt;&gt; &quot;abc&quot;
'abc'
&gt;&gt;&gt; 'banana'
'banana'
&gt;&gt;&gt; '1000'
'1000'
</code></pre>
<p>如果在字符串中需要用到引号(<code>&quot;</code>或<code>'</code>)的话，可以用转义的方式(<code>\'</code>或<code>\&quot;</code>)，或者在需要用到单引号的时候，用双引号把字符串括起来，反之亦然:</p>
<pre><code class="language-Python">&gt;&gt;&gt; 'I\'m a student.'
&quot;I'm a student.&quot;
&gt;&gt;&gt; &quot;I\'m a student.&quot;
&quot;I'm a student.&quot;
</code></pre>
<h3 id="布尔型bool-1"><a class="header" href="#布尔型bool-1">布尔型bool</a></h3>
<p>布尔型，英文为boolean，用来描述真假的一种数据，也叫逻辑型，它只有两个值: <code>True</code> 和 <code>False</code>。这里要注意一定是只有首字母大写，如果写成了true、flase、TURE或者是FaLSe都是错误的。在Python中，用<code>bool</code>表示布尔型的类型名。</p>
<pre><code class="language-Python">&gt;&gt;&gt; True
True
&gt;&gt;&gt; False
False
</code></pre>
<p>如果输入错误，会报错，如输入<code>true</code>:</p>
<pre><code class="language-shell">Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
NameError: name 'true' is not defined
</code></pre>
<p>在Python中，<code>bool</code>类型其实是<code>int</code>类型的子类型，一般情况下，<code>False</code>就是<code>0</code>, <code>True</code>就是<code>1</code>；但是所有的非0的数值都可以认为是真逻辑值，这一点我们会在下一章节中详细说明。</p>
<h3 id="空值none-1"><a class="header" href="#空值none-1">空值None</a></h3>
<p>空值，英文为<code>None</code>，是Python中一个很特殊的类型，它只有一个值，即<code>None</code>，表示空对象，什么都没有。但是数据为空并不是空值，比如空字符串<code>&quot;&quot;</code>，它是字符串类型，并不是空值类型。在Python中，用<code>NoneType</code>表示空值的类型名。</p>
<pre><code class="language-Python">&gt;&gt;&gt; None
&gt;&gt;&gt; 
&gt;&gt;&gt; &quot;&quot;
''
</code></pre>
<p>空值并不是一个没有意义的类型，相反，需要用到它的地方有很多。比如，调用函数的时候，不想给某个参数传递值，但是这个参数没有默认的值，所以传值是必须的，那么就可以把空值传给它。关于这一点，我们以后遇到的时候，结合实际用法就可以理解得更好。</p>
<h2 id="变量variables-1"><a class="header" href="#变量variables-1">变量Variables</a></h2>
<p>在计算机编程中，变量就是一个数据的载体，也就是一块用来保存数据的内存空间，它可以被读取和修改。一个变量有两个最基本的要素:<strong>名字</strong>和<strong>类型</strong>。</p>
<p>我们可以把变量想像成一个用来存放数据的容器，像下图一样:</p>
<p><img src="03.%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8F%98%E9%87%8F/./images/variable.png" alt="Variables" /></p>
<p>他在内存中的表现是这样的:</p>
<svg width="380" height="255" xmlns="http://www.w3.org/2000/svg">
 <g>
  <title>Layer 1</title>
  <path stroke="#000" fill="#fff" stroke-width="3" d="m163.49998,41.5l185.00002,0l0,171.3948c-92.50001,0 -92.50001,65.30456 -185.00002,28.1997l0,-199.5945z" id="svg_2"/>
  <rect stroke="#000" fill="#fff" stroke-width="3" x="178.5" y="70.5" width="71" height="24" id="svg_3"/>
  <text fill="#000000" stroke="#000" stroke-width="0" x="227" y="27.5" id="svg_9" font-size="24" font-family="Noto Sans JP" text-anchor="start" xml:space="preserve">内存</text>
  <text fill="#000000" stroke="#000" stroke-width="0" x="177.5" y="63.5" id="svg_10" font-size="18" font-family="'Stick No Bills'" text-anchor="start" xml:space="preserve">存储单元</text>
  <text fill="#000000" stroke="#000" stroke-width="0" x="262.5" y="63.5" id="svg_11" font-size="18" font-family="'Stick No Bills'" text-anchor="start" xml:space="preserve">地址</text>
  <text fill="#000000" stroke="#000" stroke-width="0" x="255.5" y="87.5" id="svg_11" font-size="12" font-family="'Stick No Bills'" text-anchor="start" xml:space="preserve">0xADA43B01</text>
  <text fill="#000000" stroke="#000" stroke-width="0" x="255.5" y="116.5" id="svg_11" font-size="12" font-family="'Stick No Bills'" text-anchor="start" xml:space="preserve">0xADA43B02</text>
  <text fill="#000000" stroke="#000" stroke-width="0" x="255.5" y="144.5" id="svg_11" font-size="12" font-family="'Stick No Bills'" text-anchor="start" xml:space="preserve">0xADA43B03</text>
  <text fill="#000000" stroke="#000" stroke-width="0" x="255.5" y="171.5" id="svg_11" font-size="12" font-family="'Stick No Bills'" text-anchor="start" xml:space="preserve">0xADA43B04</text>
  <path stroke="#000" stroke-width="3" fill="#fff" d="m30.02751,73.32114l21.56375,-30.54866l86.43623,0l0,152.99999l-107.99998,0l0,-122.45133l0,0.00001z" id="svg_12"/>
  <text style="cursor: move;" fill="#000000" stroke="#0" stroke-width="3" x="56.5" y="27.5" id="svg_13" font-size="24" font-family="'Syne'" text-anchor="start" xml:space="preserve">程序</text>
  <text fill="#000000" stroke="#0" stroke-width="3" x="44.5" y="91.5" id="svg_16" font-size="18" font-family="'Stick No Bills'" text-anchor="start" xml:space="preserve">a = 1</text>
  <text fill="#000000" stroke="#0" stroke-width="3" x="189.5" y="87.5" id="svg_17" font-size="12" font-family="'Stick No Bills'" text-anchor="start" xml:space="preserve">00000001</text>
  <rect stroke="#000" fill="#fff" stroke-width="3" x="178.5" y="98.5" width="71" height="24" id="svg_1"/>
  <rect stroke="#000" fill="#fff" stroke-width="3" x="178.5" y="126.5" width="71" height="24" id="svg_4"/>
  <rect stroke="#000" fill="#fff" stroke-width="3" x="178.5" y="154.5" width="71" height="24" id="svg_5"/>
  <text xml:space="preserve" text-anchor="start" font-family="'Stick No Bills'" font-size="18" id="svg_6" y="197.5" x="204" stroke-width="0" stroke="#0" fill="#000000">......</text>
  <text xml:space="preserve" text-anchor="start" font-family="'Stick No Bills'" font-size="18" id="svg_7" y="197.5" x="273" stroke-width="0" stroke="#0" fill="#000000">......</text>
  <path transform="rotate(88.93 138.778 85.4919)" stroke="#0" id="svg_14" d="m132.57303,85.39116l6.20516,-41.88579l6.20516,41.88579l-3.10258,0l0,42.08734l-6.20516,0l0,-42.08734l-3.10258,0z" stroke-width="3" fill="#000000"/>
 </g>
</svg>
<p>上图中的<code>a</code>就是变量的名字，在Python中，变量的类型不是在声明它的时候给出，而且会根据我们赋给它的值变化，比如<code>a = 1</code>，这时变量<code>a</code>的类型是整型<code>int</code>，如果我们重新给它赋值<code>a=&quot;apple&quot;</code>，那它的类型就变成了字符串<code>str</code>；我们也可以通过一些内建函数来改变它的类型，这一点我们后面很快就会讲到。</p>
<h3 id="变量命名-1"><a class="header" href="#变量命名-1">变量命名</a></h3>
<p>每一个变量都需要提前定义，首先要给它取一个名字，方便我们在后面使用它。变量的命名是要遵循下列规则的：</p>
<ul>
<li>变量的名字由字母、下划线<code>_</code>和数字组成，但是不能以数字开头。这里的字母不单单是26个英文字母，它指的是在Unicode(也被称作万国码)字符集里的所有字母，包括中文、英文、日文、希腊字母、德文等等，范围非常广，但是像<code>@</code>、<code>#</code>、<code>$</code>这些字符是不能出现在变量名中的，我们强烈建议起名的时候只用英文字母。</li>
<li>变量的名字是大小写敏感的，比如<code>A</code>和<code>a</code>是两不同的变量。</li>
<li>变量的名字不要使用Python中已经保留的关键字，也不要用自定义的函数、类名。</li>
</ul>
<p>我们可以通过下面的方式查看Python中有哪些保留的关键字:</p>
<pre><code class="language-Python">&gt;&gt;&gt; import keyword
&gt;&gt;&gt; keyword.kwlist
['False', 'None', 'True', '__peg_parser__', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']
</code></pre>
<p>有关我自定义函数和类名的限制，我们以后会讲到。</p>
<h3 id="变量赋值-1"><a class="header" href="#变量赋值-1">变量赋值</a></h3>
<p>可以通过执行赋值表达式来修改变量中存储的值，Python中的赋值运算符为<code>=</code>，这个等号并不是我们数学上的<strong>等于</strong>，千万不要混淆。给变量赋值的语法为:</p>
<p><em><strong>变量 = 值</strong></em><br/>
<em><strong>变量 = 变量</strong></em><br/>
<em><strong>变量 = 表达式</strong></em></br>
<em><strong>变量 = 函数返回值</strong></em><br/></p>
<p>在赋值的时候，变量<strong>永远要写在左边</strong>，右边是要赋与它的值。</p>
<pre><code class="language-Python">&gt;&gt;&gt; a = 1 #直接用值给变量赋值
&gt;&gt;&gt; print(a)
1
&gt;&gt;&gt; b = a #用变量的值给变量赋值
&gt;&gt;&gt; print(b)
1
&gt;&gt;&gt; c = a + b #用表达式给变量赋值
&gt;&gt;&gt; print(c)
2
&gt;&gt;&gt; a = a + 1 #同样是用表达式给a赋值
&gt;&gt;&gt; print(a)
2
&gt;&gt;&gt; d = str(a) #用函数返回值给变量赋值
&gt;&gt;&gt; print(d)
'2'
</code></pre>
<p>看到上面的例子，你是不是对于<code>a = a + 1</code>不太理解？没关系，我来给你解释：</p>
<p>赋值表达式在执行过程中，是先要执行赋值符<code>=</code>右边的代码的，当右边的代码执行完并得到结果之后，就会把这个结果赋值给赋值符<code>=</code>左边的变量。所以在<code>a = a + 1</code>中，最初变量<code>a</code>存储的值为<code>1</code>，先是使用了变量<code>a</code>，把它加了1之后得到<code>2</code>，再把字面量值<code>2</code>重新赋值给了变量<code>a</code>。</p>
<p>总之，变量是一种方便使用的占位符，用于引用计算机的内存地址来存储值。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="运算符和表达式"><a class="header" href="#运算符和表达式">运算符和表达式</a></h1>
<p>运算符是用来组成表达式的重要元素，会对表达式的结果产生影响。</p>
<p>表达式可以直接用来执行，并通过运算会得到一个结果，但是这个结果马上就会补缓存释放且不再存在，所以在编程过程中，表达式要配合变量来使用。</p>
<h2 id="运算符-operators"><a class="header" href="#运算符-operators">运算符 Operators</a></h2>
<p>我们这里提到的运算符不仅仅是在数学中学到的<em>加、减、乘、除</em>， Python提供了大量的强大的运算符来帮助我们进行运算，这里我们先介绍下面三种类型的运算符（按优先级排列）：</p>
<h3 id="算术运算符-arithmetic-operator"><a class="header" href="#算术运算符-arithmetic-operator">算术运算符 Arithmetic Operator</a></h3>
<table><thead><tr><th align="left">运算符</th><th align="left">说明</th></tr></thead><tbody>
<tr><td align="left"><code>**</code></td><td align="left">幂运算（指数运算）</td></tr>
<tr><td align="left"><code>+</code>  <code>-</code></td><td align="left">正负号（正号可省略）</td></tr>
<tr><td align="left"><code>*</code>  <code>/</code>  <code>%</code>  <code>//</code></td><td align="left">乘、除、模（取余）、整除</td></tr>
<tr><td align="left"><code>+</code>  <code>-</code></td><td align="left">加、减</td></tr>
</tbody></table>
<h3 id="位运算符-bit-operator"><a class="header" href="#位运算符-bit-operator">位运算符 Bit Operator</a></h3>
<table><thead><tr><th align="left">运算符</th><th align="left">说明</th></tr></thead><tbody>
<tr><td align="left"><code>~</code></td><td align="left">按位取反</td></tr>
<tr><td align="left"><code>>>  </code>&nbsp;&nbsp;<code><<</code></td><td align="left">右移&nbsp;&nbsp;左移</td></tr>
<tr><td align="left"><code>&amp;</code></td><td align="left">按位与</td></tr>
<tr><td align="left"><code>^</code>&nbsp;&nbsp;<code>|</code></td><td align="left">按位异或、按位或</td></tr>
</tbody></table>
<h3 id="关系运算符比较运算符relational-operator"><a class="header" href="#关系运算符比较运算符relational-operator">关系运算符（比较运算符）Relational Operator</a></h3>
<table><thead><tr><th align="left">运算符</th><th align="left">说明</th></tr></thead><tbody>
<tr><td align="left"><code>&lt;=</code>  <code>&lt;</code>  <code>&gt;=</code>  <code>&gt;</code></td><td align="left">小于等于、小于、大于等于、大于</td></tr>
<tr><td align="left"><code>==</code>  <code>!=</code></td><td align="left">等于、不等于</td></tr>
</tbody></table>
<h3 id="逻辑运行符-logic-operator"><a class="header" href="#逻辑运行符-logic-operator">逻辑运行符 Logic Operator</a></h3>
<table><thead><tr><th align="left">运算符</th><th align="left">说明</th></tr></thead><tbody>
<tr><td align="left"><code>not</code></td><td align="left">逻辑非</td></tr>
<tr><td align="left"><code>and</code></td><td align="left">逻辑与</td></tr>
<tr><td align="left"><code>or</code></td><td align="left">逻辑或</td></tr>
</tbody></table>
<p>需要说明的是，上述前三种运算符的优先级为: <strong>算术运算符</strong>&gt;<strong>位运算符</strong>&gt;<strong>比较运算符</strong>&gt;<strong>逻辑运行符</strong>，而的位运行符中的按位取反<code>~</code>的优先级和正负号一样，低于幂运算<code>**</code>，高于其它算术运算符。</p>
<p>完整的运算符列表以及优先级可查看<a href="04.%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F/../%E9%99%84%E5%BD%95/appendix.html#%E5%AE%8C%E6%95%B4%E8%BF%90%E7%AE%97%E7%AC%A6">附录-完整运算符</a></p>
<h2 id="表达式-expression"><a class="header" href="#表达式-expression">表达式 Expression</a></h2>
<p>表达式是由字面量的值、变量等等与运算符组成的运算式，每一个表达式最终都会等到一个确切的字面量的值。</p>
<p>有关字面量的解释，可以查看<a href="04.%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F/../%E9%99%84%E5%BD%95/appendix.html#%E5%AD%97%E9%9D%A2%E9%87%8F">附录-字面量</a></p>
<p>在Python中，常用的表达式有<em>算术表达式</em>、<em>关系表达式</em>（或者叫<em>比较表达式</em>）和<em>逻辑表达式</em>。</p>
<h3 id="算术表达式-arithmetic-expression"><a class="header" href="#算术表达式-arithmetic-expression">算术表达式 Arithmetic Expression</a></h3>
<p>Python中的算术表达式和数学中算式很像，只是我们不需要在后面再写个等号并给出结果。</p>
<pre><code class="language-Python">&gt;&gt;&gt;  1 + 1
2
&gt;&gt;&gt;  1 - 1
0
&gt;&gt;&gt;  1 * 2
2
</code></pre>
<p><strong><code>Python</code>中的除法运算<code>/</code>得到的结果一定是一个浮点型的数值:</strong></p>
<pre><code class="language-Python">&gt;&gt;&gt;  10 / 5
2.0
</code></pre>
<p>Python中的整除和取余分别用来得到数学中除法运算的<strong>商</strong>和<strong>余数</strong>，比如：</p>
<p>\[10 \div 3 = 3 \ldots 1\]</p>
<p>取余运算<code>%</code>和整除运算<code>//</code>不仅仅适用于整型数值，也适用于浮点型数值，只要在参与运算的数值里，有一个浮点型，那么结果一点是一个浮点型数值。</p>
<pre><code class="language-Python">&gt;&gt;&gt; 10 // 3 
3
&gt;&gt;&gt; 10 % 3
1
&gt;&gt;&gt; 10.0 // 3
3.0
&gt;&gt;&gt; 10.0 % 3
1.0
&gt;&gt;&gt; 18.32 // 2.51
7.0
&gt;&gt;&gt; 18.32 % 2.51
0.7500000000000018
</code></pre>
<p>注: 至于上面的余数为什么出现了<code>0.7500000000000018</code>，我们后面会讲到。</p>
<p>在使用算术表达式的时候，一这要注意<a href="04.%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F.html#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6">运算符</a>的优先级关系，如果搞不清楚优先级，可以使用圆括号来确保运算的执行顺序。</p>
<p>比如在数学中的:</p>
<p>\[\lbrace[(3 + 4) \times 5-6]+7 \rbrace \times 8\]</p>
<p>应该写成:</p>
<pre><code class="language-Python">&gt;&gt;&gt; (((3 + 4) * 5 - 6 ) + 7) * 8
288
</code></pre>
<p>这一点同样适用于关系表达式和逻辑表达式。</p>
<p>在Python中，字符串也能进行加法<code>+</code>和乘法<code>*</code>运算，加法运算只能发生在两个字符串之间,运算结果为两个字符串连接在一起之后的新字符串；而乘法运算是只能由字符串和整型参与，比如<code>&quot;abc&quot; * 2</code>，结果为<code>'abcabc'</code></p>
<pre><code class="language-Python">&gt;&gt;&gt; &quot;abc&quot; + &quot;def&quot;
'abcdef'
&gt;&gt;&gt; &quot;def&quot; + &quot;abc&quot;
'defabc'
&gt;&gt;&gt; &quot;a&quot; * 10
'aaaaaaaaaa'
</code></pre>
<h3 id="关系表达式-ralational-expression"><a class="header" href="#关系表达式-ralational-expression">关系表达式 Ralational Expression</a></h3>
<p>关系表达式，也可以被叫做比较表达式，通过关系运算符将两个值连接到一起得到的一种表达式，用来运算这一关系是否成立，一个关系表达式的结果只有两个值<code>True</code>和<code>False</code>。</p>
<p>在使用关系表达式的时候，要注意数据的类型，一般情况下，整型和浮点型之间的比较没有限制，也可以和布尔型进行比较（基本不会用到），但是它们都不能与字符串进行比较:</p>
<pre><code class="language-Python">&gt;&gt;&gt; 3 &gt; 2
True
&gt;&gt;&gt; 4 &lt; 2
False
&gt;&gt;&gt; 5.3 &gt; 3
True
&gt;&gt;&gt; True &gt; False
True
&gt;&gt;&gt; False &gt; -1
True
</code></pre>
<p>字符串之间则是按照字节逐个去比较的，比如下面三个字符串<code>'16'</code>、<code>'161'</code>和<code>'8'</code>，先比较第一个字符，分别为<code>'1'</code>、<code>'1'</code>、<code>'8'</code>，其中<code>'8'</code>比其它两个都大，所以<code>'8'</code>是三个中最大的字符串；在其余两个字符串中，前面两个字节均为<code>'1'</code>和<code>'6'</code>，所以还要继续比较下一个字节的大小，但是第一个字符串只有两个字节，而第二个字符串还有第三个字节，所以第二个字符串比第一个字符串要大。根据以上分析，下面三个字符串的大小顺序为<code>'8'&gt;'161'&gt;'16'</code>。</p>
<svg width="260" height="160" xmlns="http://www.w3.org/2000/svg">
 <g>
  <title>Layer 1</title>
  <rect stroke="#000f0f" id="svg_8" height="36" width="78" y="62" x="11" fill="none"/>
  <rect stroke="#000f0f" id="svg_11" height="36" width="78" y="62" x="91" fill="none"/>
  <rect stroke="#000f0f" id="svg_12" height="36" width="78" y="62" x="171" fill="none"/>
  <rect stroke="#000f0f" id="svg_13" height="36" width="78" y="10" x="11" fill="none"/>
  <rect stroke="#000f0f" id="svg_14" height="36" width="78" y="10" x="91" fill="none"/>
  <rect stroke="#000f0f" id="svg_16" height="36" width="78" y="115" x="11" fill="none"/>
  <text stroke="#000f0f" xml:space="preserve" text-anchor="start" font-family="'Stick No Bills'" font-size="18" stroke-width="0" id="svg_19" y="34.5" x="49" fill="#000000">1</text>
  <text transform="matrix(1.42566 0 0 1 -65.3354 4)" stroke="#000f0f" xml:space="preserve" text-anchor="start" font-family="'Stick No Bills'" font-size="18" id="svg_20" y="29.5" x="130.70143" stroke-width="0" fill="#000000">6</text>
  <text stroke="#000f0f" xml:space="preserve" text-anchor="start" font-family="'Stick No Bills'" font-size="18" stroke-width="0" id="svg_21" y="87.5" x="49" fill="#000000">1</text>
  <text transform="matrix(1.42566 0 0 1 -65.3354 4)" stroke="#000f0f" xml:space="preserve" text-anchor="start" font-family="'Stick No Bills'" font-size="18" id="svg_22" y="82.5" x="130.70143" stroke-width="0" fill="#000000">6</text>
  <text xml:space="preserve" text-anchor="start" font-family="'Stick No Bills'" font-size="18" id="svg_24" y="86.5" x="204" stroke-width="0" stroke="#000f0f" fill="#000000">1</text>
  <text xml:space="preserve" text-anchor="start" font-family="'Stick No Bills'" font-size="18" stroke-width="0" id="svg_25" y="138.5" x="46" stroke="#000f0f" fill="#000000">8</text>
 </g>
</svg>
<pre><code class="language-Python">&gt;&gt;&gt; '16' &lt; '161'
True
&gt;&gt;&gt; '161' &gt; '8'
False
</code></pre>
<p>两个字符串的大小是根据它们在字符集中的位置判断的，暂时我们只需要下表即可。</p>
<table><thead><tr><th align="left">字符</th><th align="left">位置</th></tr></thead><tbody>
<tr><td align="left"><code>'0'</code>~<code>'9'</code></td><td align="left">48~57</td></tr>
<tr><td align="left"><code>'A'</code>~<code>'Z'</code></td><td align="left">65~90</td></tr>
<tr><td align="left"><code>'a'</code>~<code>'z'</code></td><td align="left">97~122</td></tr>
</tbody></table>
<p>从上表可以看出，即使字母<code>a</code>是小写的，但是它并不“小”，在字符串中，它要大于大写字母<code>A</code>。当我们不确定某个字符在字符集中的位置的时候，可以调用函数<code>ord()</code>来查看，有关这一内建函数，我们会在后面章节详细学习:</p>
<pre><code class="language-Python">&gt;&gt;&gt; ord('A')
65
</code></pre>
<h3 id="逻辑表达式-logic-expression"><a class="header" href="#逻辑表达式-logic-expression">逻辑表达式 Logic Expression</a></h3>
<p>当我们用两个关系表达式和逻辑运算符组成一个逻辑表达式时，它的结果也是只有两个<code>True</code>和<code>False</code>:</p>
<pre><code class="language-Python">&gt;&gt;&gt; 5 &gt; 3 and 4 &lt; 6
True
&gt;&gt;&gt; 5 &gt; 6 or 6 &lt; 7
True
&gt;&gt;&gt; 7 &gt; 4 and 3 &lt; 1
False
&gt;&gt;&gt; not (5 &gt; 6)
True
</code></pre>
<p>对于关系表达式，也可以多个值一起比较，但不建议用，在这里还是建义大家用逻辑表达式来代替:</p>
<pre><code class="language-Python">&gt;&gt;&gt; 5 &lt; 6 &gt; 2
True
&gt;&gt;&gt; 5 &lt; 6 and 6 &gt; 2 #与上式等价
True
</code></pre>
<p>假如，假和爸爸去看电影，检票员说：”你们两个必须都有票才能进“，那么这里用的就是<code>and</code>，如果检票员说：”你们两个只要有一发张票就可以进入“，那么这里用的就是<code>or</code>。</p>
<p>我们可以用下表来熟悉两个关系表达式的结果在逻辑表达式中的运算情况</p>
<table><thead><tr><th align="left">表达式a</th><th align="left">表达式b</th><th align="left"><code>and</code>运算</th><th align="left"><code>or</code>运算</th><th align="left"><code>not a</code>运算</th></tr></thead><tbody>
<tr><td align="left"><code>True</code></td><td align="left"><code>True</code></td><td align="left"><code>True</code></td><td align="left"><code>True</code></td><td align="left"><code>False</code></td></tr>
<tr><td align="left"><code>True</code></td><td align="left"><code>False</code></td><td align="left"><code>False</code></td><td align="left"><code>True</code></td><td align="left"><code>False</code></td></tr>
<tr><td align="left"><code>False</code></td><td align="left"><code>True</code></td><td align="left"><code>False</code></td><td align="left"><code>True</code></td><td align="left"><code>True</code></td></tr>
<tr><td align="left"><code>False</code></td><td align="left"><code>False</code></td><td align="left"><code>False</code></td><td align="left"><code>False</code></td><td align="left"><code>True</code></td></tr>
</tbody></table>
<p>在Python中，还有一种特别有意思的概念，也是我们接下来要讲的:<em>短路逻辑</em>，它的意思可以理解成在逻辑表达式中，运算符右边部分的运算被短路了:</p>
<p>在<code>a and b</code>表达式中，如果<code>a</code>的值为<code>True</code>，那么结果为<code>b</code>的值，否则结果直接为<code>a</code>的值</p>
<pre><code class="language-Python">&gt;&gt;&gt; 5 and 6
6
&gt;&gt;&gt; 5 &lt; 4 and 6 &gt; 1 #这里关系表达式“6 &gt; 1”被短路了，并没有进行运算
False
&gt;&gt;&gt; False and 6 #这里6被短路了，并没有被运算
False
</code></pre>
<p>在<code>a or b</code>表达式中，如果<code>a</code>的值为<code>True</code>，那么结果为<code>a</code>的值，否则结果直接为<code>b</code>的值</p>
<pre><code class="language-Python">&gt;&gt;&gt; 5 or 6  #这里6被短路了，并没有被运算
5
&gt;&gt;&gt; 5 &gt; 4 or 6 &lt; 1 #这里关系表达式“6 &gt; 1”被短路了，并没有进行运算
True
&gt;&gt;&gt; False or 6
6
</code></pre>
<p>在上一章节，我们提到过，任何非<code>0</code>数值均可被认为是真逻辑值，这一说法可以扩展到其它基本类型:</p>
<table><thead><tr><th align="left">类型</th><th align="left">假逻辑值</th><th align="left">真逻辑值</th></tr></thead><tbody>
<tr><td align="left"><code>int</code></td><td align="left"><code>0</code></td><td align="left"><code>非0整数</code></td></tr>
<tr><td align="left"><code>float</code></td><td align="left"><code>0.0</code>、<code>0.00</code>等等</td><td align="left"><code>非0.0浮点数</code></td></tr>
<tr><td align="left"><code>str</code></td><td align="left"><code>''</code></td><td align="left"><code>非空字符串</code></td></tr>
<tr><td align="left"><code>NoneType</code></td><td align="left"><code>None</code></td><td align="left">无</td></tr>
</tbody></table>
<pre><code class="language-Python">&gt;&gt;&gt; '' and True
''
&gt;&gt;&gt; None and False
&gt;&gt;&gt; 
</code></pre>
<h2 id="表达式与变量"><a class="header" href="#表达式与变量">表达式与变量</a></h2>
<p>在本章节开篇时，我们提到，表达式的结果被输出之后就会被缓存释放了，所以为了后面继续使用表达式运算出来的结果，需要配合变量来使用。</p>
<pre><code class="language-Python">&gt;&gt;&gt; a = 5 + 7
&gt;&gt;&gt; print(a)
12
&gt;&gt;&gt; b = 4 &gt; 3 and 5 &lt; 1
&gt;&gt;&gt; print(b)
False
&gt;&gt;&gt; c = a and b
&gt;&gt;&gt; print(c)
False
</code></pre>
<p>有关变量的详细内容，如果还有不清楚的地方，可以回到上一章节中复习：<a href="04.%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F/.././03.%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8F%98%E9%87%8F/%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8F%98%E9%87%8F.html#%E5%8F%98%E9%87%8Fvariables">变量</a>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="位运算"><a class="header" href="#位运算">位运算</a></h1>
<p>程序中的所有数在计算机内存中都是以二进制的形式储存的。位运算就是直接对整数在内存中的二进制位进行操作。所以要先了解二进制。</p>
<p>另:本章节详细分析部分有一定难度，建议只学习位运算符的使用方法即可。</p>
<h2 id="二进制"><a class="header" href="#二进制">二进制</a></h2>
<p>17世纪至18世纪的德国数学家莱布尼茨，是世界上第一个提出二进制记数法的人。用二进制记数，只用<code>0</code>和<code>1</code>两个符号，无需其他符号。这一计数方法充分结合了数字电子电路系统的高低电平，在一些系统中，高电平表示<code>1</code>，低电平表示<code>0</code>，而有的系统则是高电平表示<code>1</code>，低电平表示<code>2</code>。这也是为什么低级语言编写的程序不能跨平台使用的原因。下面两个图可以简单表示两种不同系统的高低电平情况:</p>
<p><img src="05.%E4%BD%8D%E8%BF%90%E7%AE%97/./images/high-low%20level1.png" alt="高电平1，低电平0" />
<img src="05.%E4%BD%8D%E8%BF%90%E7%AE%97/./images/high-low%20level2.png" alt="高电平0，低电平1" /></p>
<h3 id="进制转换"><a class="header" href="#进制转换">进制转换</a></h3>
<p><strong>十进制转二进制</strong></p>
<p>一个十进制数转换为二进制数要分整数部分和小数部分分别转换，最后再组合到一起。</p>
<p>整数部分采用 &quot;除2取余，逆序排列&quot;法。具体做法是：用2整除十进制整数，可以得到一个商和余数；再用2去除商，又会得到一个商和余数，如此进行，直到商为小于1时为止，然后把先得到的余数作为二进制数的低位有效位，后得到的余数作为二进制数的高位有效位，依次排列起来。例：125:</p>
<p><img src="05.%E4%BD%8D%E8%BF%90%E7%AE%97/./images/integertobinary.webp" alt="Integer to Binary" /></p>
<p>经过运算，十进制的<code>125</code>，转换成二进制之后为<code>1111101</code>。</p>
<p>小数部分要使用“乘2取整法”。即用十进制的小数乘以2并取走结果的整数(必是 0或1)，然后再用剩下的小数重复刚才的步骤，直到剩余的小数为0时停止，最后将每次得到的整数部分按先后顺序从左到右排列即得到所对应二进制小数。例如，将十进制小数 0.8125 转换成二进制小数过程如下:</p>
<p><img src="05.%E4%BD%8D%E8%BF%90%E7%AE%97/./images/floattobinary.webp" alt="Float to Binary" /></p>
<p><strong>二进制转十进制</strong></p>
<p>二进制转换成十进制是要按位进行\(2^{x-1}\)运算，再加到一起，比如:</p>
<p>\[(111111)_2 = 2^5 + 2^4 + 2^3 + 2^2 + 2^1 + 2^0 = 63\]</p>
<p>或:</p>
<p>\[(101011)_2 = 2^5 + 2^3 + 2^1 + 2^0 = 43\]</p>
<h2 id="位运算-bitwise"><a class="header" href="#位运算-bitwise">位运算 Bitwise</a></h2>
<table><thead><tr><th align="left">运算符</th><th align="left">说明</th></tr></thead><tbody>
<tr><td align="left"><code>~</code></td><td align="left">按位取反</td></tr>
<tr><td align="left"><code>>></code>&nbsp;&nbsp;<code><<</code></td><td align="left">右移&nbsp;&nbsp;左移</td></tr>
<tr><td align="left"><code>&amp;</code></td><td align="left">按位与</td></tr>
<tr><td align="left"><code>^</code>&nbsp;&nbsp;<code>|</code></td><td align="left">按位异或、按位或</td></tr>
</tbody></table>
<h3 id="按位取反"><a class="header" href="#按位取反">按位取反</a></h3>
<p>按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1:</p>
<pre><code class="language-Python">&gt;&gt;&gt;~6
-7
&gt;&gt;&gt;~-8
7
</code></pre>
<p><code>~x</code> 类似于 <code>-x-1</code>，但是实际情况远远要复杂得多，有兴趣的同学可以查看附录进行学习<a href="05.%E4%BD%8D%E8%BF%90%E7%AE%97/../%E9%99%84%E5%BD%95/appendix.html#%E6%8C%89%E4%BD%8D%E5%8F%96%E5%8F%8D">附录-按位取反</a></p>
<h3 id="左移右移"><a class="header" href="#左移右移">左移、右移</a></h3>
<p>位运算中，左移<code>n</code>位相当于原数整除<code>2n</code>，左移<code>n</code>位相当于原数乘以<code>2n</code>，但是位移运算效率更高。</p>
<pre><code class="language-Python">&gt;&gt;&gt;15&gt;&gt;2
3
&gt;&gt;&gt;15&lt;&lt;2
60
</code></pre>
<p>假设我们的一台简易计算机只用一个字节(byte，即8位)来存储数值，那么<code>15</code>的二进制应该为<code>0000 1111</code>，所以左移2位之后变为<code>0000 0011</code>，即<code>3</code>; 左移2位之后变成<code>0011 1100</code>，即<code>60</code>。</p>
<h3 id="按位与"><a class="header" href="#按位与">按位与</a></h3>
<p>按位与运算是将两个数值的二进制按位进行逻辑与运算，只有同时为<code>1</code>时才能得到<code>1</code>，否则结果都是<code>0</code>。</p>
<pre><code class="language-Python">&gt;&gt;&gt;15 &amp; 24
8
</code></pre>
<table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody>
<tr><td>15:</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td></tr>
<tr><td>24:</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>&amp;</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td></tr>
</tbody></table>
<h3 id="按位或"><a class="header" href="#按位或">按位或</a></h3>
<p>按位或运算是将两个数值的二进制按位进行逻辑或运算，只有同时为<code>0</code>时才能得到<code>0</code>，否则结果都是<code>1</code>。</p>
<pre><code class="language-Python">&gt;&gt;&gt;15 | 24
31
</code></pre>
<table><thead><tr><th></th><th></th><th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th></tr></thead><tbody>
<tr><td>15:</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr><td>24:</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr><td>|</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody></table>
<h3 id="按位异或"><a class="header" href="#按位异或">按位异或</a></h3>
<p>按位异或运算是将两个数值的二进制按位进行逻辑异或运算，当值相同是得到<code>0</code>，不同时则得到<code>1</code>。</p>
<pre><code class="language-Python">&gt;&gt;&gt;15 | 24
23
</code></pre>
<table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody>
<tr><td>15:</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td></tr>
<tr><td>24:</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>^</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td></tr>
</tbody></table>
<h2 id="总结-1"><a class="header" href="#总结-1">总结</a></h2>
<p>位运算是计算机编程中很重要的一种运算方式，这里我们暂时了解这些就足够了。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="常用内建函数"><a class="header" href="#常用内建函数">常用内建函数</a></h1>
<p>在今后的学习过程中，我们会用到很多内建函数，比如标准的输入输出，类型转换等等。内建函数实现了一些常用的功能，可以直接拿来使用。</p>
<table><thead><tr><th align="left">函数名</th><th align="left">功能</th><th align="left">返回值</th></tr></thead><tbody>
<tr><td align="left"><code>print()</code></td><td align="left">向终端输出信息</td><td align="left">无</td></tr>
<tr><td align="left"><code>input()</code></td><td align="left">通过终端输入数据并返回结果</td><td align="left">有</td></tr>
<tr><td align="left"><code>int()</code></td><td align="left">将参数中的值转换成整型并返回结果</td><td align="left">有</td></tr>
<tr><td align="left"><code>float()</code></td><td align="left">将参数中的值转换成浮点型并返回结果</td><td align="left">有</td></tr>
<tr><td align="left"><code>str()</code></td><td align="left">将参数中的值转换成字符串并返回结果</td><td align="left">有</td></tr>
<tr><td align="left"><code>eval()</code></td><td align="left">将参数中字符串转换成一段可执行的表达式并返回结果</td><td align="left">有</td></tr>
<tr><td align="left"><code>chr()</code></td><td align="left">返回整型参数在Uncode 中对应的字符</td><td align="left">有</td></tr>
<tr><td align="left"><code>ord()</code></td><td align="left">返回字符参数在Uncode 中对应的码位</td><td align="left">有</td></tr>
</tbody></table>
<h2 id="print"><a class="header" href="#print">print()</a></h2>
<p>我们在<a href="06.%E5%B8%B8%E7%94%A8%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0/../02.HelloWorld/HelloWorld.html">hello, world</a>中已经使用过了<code>print()</code>函数:</p>
<pre><code class="language-Python">&gt;&gt;&gt;print(&quot;hello, world!&quot;)
hello, world!
</code></pre>
<p><code>print()</code>函数的功能就是将参数的内容打印出来:</p>
<ol>
<li>对于实际的值，原样打印，字符串要用引号（如上）</li>
</ol>
<pre><code class="language-Python">&gt;&gt;&gt; print(1)
1
&gt;&gt;&gt; print(1.4)
1.4
&gt;&gt;&gt; print(True)
True
</code></pre>
<ol start="2">
<li>对于变量，打印变量内存储的值</li>
</ol>
<pre><code class="language-Python">&gt;&gt;&gt; a = 4
&gt;&gt;&gt; print(a)
4
&gt;&gt;&gt; name = &quot;Chris&quot;
&gt;&gt;&gt; print(name)
Chris
</code></pre>
<ol start="3">
<li>也可以打印函数返回的值</li>
</ol>
<pre><code class="language-Python">&gt;&gt;&gt; print(chr(65))
A
</code></pre>
<p><code>print()</code>函数是默认以<code>\n</code>结束，也就是说，当打印完信息之后自动会换行，如果想要不自动换行，可以给参数<code>end</code>传一个别的值:</p>
<pre><code class="language-Python">&gt;&gt;&gt;print(123);print(456)
123
456
&gt;&gt;&gt;print(123, end = &quot;$&quot;);print(456)
123$456
</code></pre>
<p><code>print()</code>函数也可以打印多段值，默认用<code>' '</code>隔开，如果想要换成其它分隔符，可以给参数<code>sep</code>传入其它值:</p>
<pre><code class="language-Python">&gt;&gt;&gt; a = 'A'
&gt;&gt;&gt; b = 'B'
&gt;&gt;&gt; c = 'C'
&gt;&gt;&gt; print(a,b,c)
A B C
&gt;&gt;&gt; print(a,b,c,sep = &quot;&amp;&quot;)
A&amp;B&amp;C
</code></pre>
<h3 id="占位符"><a class="header" href="#占位符">占位符</a></h3>
<p>在用<code>print()</code>函数向终端输出信息时，可以使用占位符来格式化：</p>
<table><thead><tr><th>占位符</th><th>描述</th><th>说明</th></tr></thead><tbody>
<tr><td><code>%d</code></td><td>整型占位符</td><td>无</td></tr>
<tr><td><code>%f</code></td><td>浮点型占位符</td><td>默认保留小数点后6位，如果要自定义保留<code>n</code> 位，可以写成<code>%.nf</code>，结果会四舍五入</td></tr>
<tr><td><code>%s</code></td><td>字符串占位符</td><td>无</td></tr>
</tbody></table>
<pre><code class="language-Python">&gt;&gt;&gt; print(&quot;%s is a student.&quot; %&quot;Tom&quot;)
Tom is a student.
&gt;&gt;&gt; name = &quot;Jerry&quot;
&gt;&gt;&gt; print(&quot;%s is a student.&quot; %name)
Jerry is a student.

&gt;&gt;&gt; age = 10
&gt;&gt;&gt; print(&quot;He is %d years old.&quot; %age)
He is 10 years old.

&gt;&gt;&gt; height = 1.46
&gt;&gt;&gt; print(&quot;His height is %.1f.&quot; %height)
His height is 1.5.

#有多个占位符时，需要用括号
&gt;&gt;&gt; print(&quot;%s is a student. He is %d years old. His height is %.1f.&quot; %(name, age, height))
Jerry is a student. He is 10 years old. His height is 1.5.

#如果不填充占位符，那么就会原样输出。
&gt;&gt;&gt; print(&quot;%s is a student. He is %d years old. His height is %.1f.&quot;)
%s is a student. He is %d years old. His height is %.1f.
</code></pre>
<h2 id="input"><a class="header" href="#input">input()</a></h2>
<p><code>input()</code>函数可以接收标准输入的数据，并且把数据以字符串格式返回，括号里的参数会被输出到终端作为提示用，这里参数的用法和<code>print()</code>一致:</p>
<pre><code class="language-Python">&gt;&gt;&gt; input()
# 下面一行是输入的内容，在输入时会有光标闪烁
1
# 下面一行是input()函数返回的值
'1'
&gt;&gt;&gt; input(&quot;Input a value:&quot;)
# 先输出提示的参数，然后再在后面输入内容，在输入时会有光标闪烁
Input a value:1
'1'
</code></pre>
<p>由于<code>input()</code>是有返回值的函数，所以当我们输入了值之后，如果没有把返回的值赋值给变量，那么这个值会马上被缓存释放，并不再存在，所以我们要用一个变量来接收这个返回值:</p>
<pre><code class="language-Python">&gt;&gt;&gt; a = input(&quot;Input a:&quot;)
# 下面一行是输入的内容，在输入时会有光标闪烁
Input a:1
&gt;&gt;&gt; print(a)
'1'
</code></pre>
<p>练习: 从终端输入两个值，分别赋值给变量<code>a</code>和<code>b</code>，并尝试进行计算下列算式，查看结果:</p>
<pre><code class="language-Python">&gt;&gt;&gt; a = input(&quot;Input a:&quot;)
Input a: #输入值给a
&gt;&gt;&gt; b = input(&quot;Input b:&quot;)
Input b: #输入值给b

#尝试下列算式：
&gt;&gt;&gt; a + b
&gt;&gt;&gt; a - b
&gt;&gt;&gt; a * b
&gt;&gt;&gt; a / b
</code></pre>
<h2 id="int和float"><a class="header" href="#int和float">int()和float()</a></h2>
<p>假如你已经尝试了上述代码，给<code>a</code> 赋值了<code>1</code>，给<code>b</code> 赋值了<code>2</code>，那么你会发现加法运算的结果是<code>'12'</code>，而其它运算都报了错误:</p>
<pre><code class="language-shell">Traceback (most recent call last):
  File &quot;&lt;pyshell#71&gt;&quot;, line 1, in &lt;module&gt;
    a-b
TypeError: unsupported operand type(s) for -: 'str' and 'str'
...
TypeError: can't multiply sequence by non-int of type 'str'
...
TypeError: unsupported operand type(s) for /: 'str' and 'str'
</code></pre>
<p>相信细心的同学已经想到了原因:用<code>input()</code>函数通过终端输入的内容都会以字符串的形式返回出来，但是字符串与字符串之间并没有<code>-、*、/</code>的运算，而<code>+</code>运算只是把两个字符串连接到一起。</p>
<p>为了能够进行数学运算，我们需要用到<code>int()</code>和<code>float()</code>将返回的字符串转换成数值：</p>
<ul>
<li>int(): 将输入的参数转换成整型，可以输入的参数为&lt;<em><strong>整型、浮点型和整数型的字符串</strong></em>&gt;</li>
</ul>
<pre><code class="language-Python">&gt;&gt;&gt; int(1)
1
&gt;&gt;&gt; int(1.5)
1
&gt;&gt;&gt; int(&quot;32&quot;)
32
&gt;&gt;&gt; int(&quot;2.2&quot;)
Traceback (most recent call last):
  File &quot;&lt;pyshell#74&gt;&quot;, line 1, in &lt;module&gt;
    int(&quot;2.2&quot;)
ValueError: invalid literal for int() with base 10: '2.2'

# int()是有返回值的函数，需要用变量接收返回值:
&gt;&gt;&gt; a = int(&quot;32&quot;)
&gt;&gt;&gt; print(a)
32
</code></pre>
<ul>
<li>float():将输入的参数转换成浮点型，可以输入的参数为&lt;<em><strong>整型、浮点型和数值型的字符串</strong></em>&gt;</li>
</ul>
<pre><code class="language-Python">&gt;&gt;&gt; float(3)
3.0
&gt;&gt;&gt; float(1.2)
1.2
&gt;&gt;&gt; float(&quot;2.2&quot;)
2.2
&gt;&gt;&gt; float(&quot;2.2.2&quot;)
...
   Traceback (most recent call last):
      File &quot;&lt;pyshell#78&gt;&quot;, line 1, in &lt;module&gt;
        float(&quot;2.2.2&quot;)
   ValueError: could not convert string to float: '2.2.2' 

# float()是有返回值的函数，需要用变量接收返回值:
&gt;&gt;&gt; a = float(&quot;1.5&quot;)
&gt;&gt;&gt; print(a)
1.5
</code></pre>
<p>函数之间是可以嵌套的:</p>
<pre><code class="language-Python">&gt;&gt;&gt; a = int(float(&quot;2.2&quot;))
&gt;&gt;&gt; print(a)
2
</code></pre>
<p>练习: 重新练习下面练习题，从终端输入两个值，分别赋值给变量<code>a</code>和<code>b</code>，并尝试进行计算下列算式，查看结果
要求：1. 第一次尝试给 <code>a</code>和<code>b</code> 分别输入整型
2. 第二次尝试给 <code>a</code>和<code>b</code> 分别输入浮点型</p>
<pre><code class="language-Python">&gt;&gt;&gt; # input a 代码，由学生练习时填写
&gt;&gt;&gt; # input b 代码，由学生练习时填写
#尝试下列算式：
&gt;&gt;&gt; a + b
&gt;&gt;&gt; a - b
&gt;&gt;&gt; a * b
&gt;&gt;&gt; a / b
</code></pre>
<h2 id="str"><a class="header" href="#str">str()</a></h2>
<p><code>str()</code>用来将输入的参数转换成字符串并返回:</p>
<pre><code class="language-Python">&gt;&gt;&gt; str(1)
'1'
&gt;&gt;&gt; a = str(1)
&gt;&gt;&gt; print(a)
&gt;&gt;&gt; a
'1'
</code></pre>
<p>在IDLE中，用交互环境直接输入变量名字，会打印出该变量的值，这个和 <code>print()</code>是有区别的，如果用<code>print()</code>打印出来的是用户能理解的数据，而直接输入变量名字，打印出来的是解释器能理解的数据。但是在文本编程环境中，只能用<code>print()</code>函数。</p>
<h2 id="eval"><a class="header" href="#eval">eval()</a></h2>
<p><code>eval()</code> 函数用来执行一个字符串表达式，并返回表达式的值。</p>
<pre><code class="language-Python">&gt;&gt;&gt; a = 5
&gt;&gt;&gt; b = eval(&quot;a + 5&quot;)
&gt;&gt;&gt; print(6)
b
</code></pre>
<p>如果字符串表达式中用到的变量不存在，就会报错:</p>
<pre><code class="language-Python">&gt;&gt;&gt; c = eval(&quot;d + 3&quot;)
Traceback (most recent call last):
  File &quot;&lt;pyshell#85&gt;&quot;, line 1, in &lt;module&gt;
    c = eval(&quot;d + 3&quot;)
  File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt;
NameError: name 'd' is not defined. Did you mean: 'id'?
</code></pre>
<h2 id="chr和ord"><a class="header" href="#chr和ord">chr()和ord()</a></h2>
<p>我们可以将这两个函数理解成字典，<code>chr()</code>和<code>ord()</code>的功能是正好相反的，<code>chr()</code>是根据数值查找字符，<code>ord()</code>是根据字符查找它所在位置。</p>
<pre><code class="language-Python">&gt;&gt;&gt; chr(65)
'A'
&gt;&gt;&gt; ord('A')
65
&gt;&gt;&gt; ord(&quot;我&quot;)
25105
</code></pre>
<h2 id="函数的参数"><a class="header" href="#函数的参数">函数的参数</a></h2>
<p>通过上面内建函数的学习，我们发现在调用函数时需要在<code>()</code>给出一个值，这个值就是参数。</p>
<p>也许你已经在数学中学习过了有关未知数的概念，那么你对参数已经有了初步的接触，如下面的方程：</p>
<p>\[5x+(4 \times 5)-19=46\]</p>
<p>我们可以经过解方程得到\(x\)的值为9，然而这里的\(x\)是一个固定的值，在解方程之前它只是个未知数，只有解开方程之后才知道它的值是多少。</p>
<p>然而，<code>Python</code>中参数更像是初中要学习的函数里的定义域:</p>
<p>\[ y=x^2+2x+1 \]</p>
<p>或者</p>
<p>\[ f(x)=x^2+2x+1 \]</p>
<p>这里的\(x\)是一个变化的值，随着\(x\)的变化，\(y\)或者函数\(f(x)\)的值也会变化。在编程领域，这里的\(x\)定义域可以理解成参数(parameters)。</p>
<p>此处我们先对<code>位置参数</code>和<code>默认值参数</code>简单介绍一下，首先需要知道的是，函数的参数可以有零个和多个：</p>
<ol>
<li>
<p>当函数<code>f</code>没有参数时，在调用时只需要写出<code>f()</code>即可，括号内不需要给出任何值。</p>
</li>
<li>
<p>当函数<code>f</code>有一到多个位置参数时，有三种调用方式，假设函数为<code>f(a, b, c)</code>:</p>
<ul>
<li>按顺序传参数，比如<code>f(a, b, c)</code>；</li>
<li>传值时，按名字传参数，比如<code>f(b=1, a=5, c=4)</code>，如果写在最前面的参数不是位置<code>1</code>的参数，那么其它参数必要都要按名字传值；</li>
<li>最前面参数按顺序传参时，排在后面的参数可以按名字传，比如<code>f(1, c=5, b=10)</code>。</li>
</ul>
</li>
<li>
<p>当函数<code>f</code>中，有默认值参数时，根据<code>Python</code>语法，默认值一定会写在位置参数之后，调用方式除第<code>2</code>点中的三种之外，还有另外一种方式为，假设函数为<code>f(a, b=5, c=7)</code>：</p>
<ul>
<li>不给默认值参数传值，调用时直接写<code>f(1)</code>；</li>
<li>当不需要给第二个参数传值时，可以写作<code>f(1, c=7)</code>。</li>
</ul>
</li>
</ol>
<h2 id="返回值"><a class="header" href="#返回值">返回值</a></h2>
<p>调用一个有返回值的函数会生成一个值，我们通常可以将这个返回值赋值给某个变量，或者将函数的调用作为为表达式的一部分。</p>
<p>例如：</p>
<pre><code class="language-Python">&gt;&gt;&gt; a = int('5')
&gt;&gt;&gt; b = int('5') + 7
</code></pre>
<p>在 <code>Python</code> 中，直接执行有返回值的函数不会有错误发生，但是这个返回值只在缓存里短暂地保留，稍后很快就会被释放。可以将函数比喻成一只母鸡，输入的参数值比喻成虫子，而接受返回值的变量或者表达式可以比喻成篮子；母鸡吃了虫子之后，就会下蛋；如果没有篮子接受这颗蛋，它就会碎掉；所以为了保护鸡蛋的完整，需要有篮子接住它。</p>
<p><img src="06.%E5%B8%B8%E7%94%A8%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0/./images/IMG_0108.jpg" alt="hen" /></p>
<p>基于上述原因，我们在调用有返回值函数时要配合变量或者表达式来使用，不要做无用的调用。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="海龟画图-第一部分"><a class="header" href="#海龟画图-第一部分">海龟画图-第一部分</a></h1>
<p>海龟画图(Turtle Graphics)是<code>Python</code>的内建模块，它移植于LOGO语言，这门语言是在1967年由Seymour Papert， Wally Feurzig和Cynthia Solomon 为了专门给儿童学习编程发明出来的，它的特色就是通过编程指挥一个小海龟（Turtle） 在屏幕上绘图。<br>
在 Python 中，海龟绘图提供了一个实体“海龟”形象（带有画笔的小机器动物），假定它在地板上平铺的纸张上画出线条形成各种图形。</p>
<p>我们先通过下面简单代码对海龟画图有个初步认识</p>
<pre><code class="language-Python">import turtle as t

&quot;&quot;&quot;
author: 孙老师
功能: 画一个正方形
&quot;&quot;&quot;

t.pensize(3)

t.pencolor(&quot;red&quot;)
t.forward(100)
t.left(90)

t.pencolor(&quot;green&quot;)
t.forward(100)
t.left(90)

t.pencolor(&quot;orange&quot;)
t.forward(100)
t.left(90)

t.pencolor(&quot;blue&quot;)
t.forward(100)
t.left(90)
</code></pre>
<p>运行上述代码之后，弹出绘画窗口，并画出一个正方形：</p>
<div align="center">
<img name="square" src="07.海龟画图/./images/square.png" width="350"/>
</div>
<!--![square](./images/rectangle.png)-->
<h2 id="导入模块"><a class="header" href="#导入模块">导入模块</a></h2>
<p>由于<code>turtle</code>是<code>Python</code>中的内置模块，在使用之前需要先用<code>import</code>关键字来导入，导入模块有三个方式：</p>
<pre><code class="language-Python"># 方式1：导入模块
import turtle
# 方式2：导入模块并起一个别名
import turtle as t
# 方式3：批量导入资源
from turtle import *
</code></pre>
<ul>
<li>使用第一种方式时，在调用模块中的资源时，用<code>turtle.</code>的方式即可，例如<code>turtle.forward(100)</code>。</li>
<li>使用第二种方式时，在调用模块中的资源时，用<code>t.</code>的方式即可，例如<code>t.forward(100)</code>。</li>
<li>使用第三种方式时，可以直接用资源的名字调用，不需要加任何前缀，例如<code>forward(100)</code>。</li>
</ul>
<p><strong>这里我们建议用第二种方式；不建议用第一种方式的原因是有些模块的名字会很长，在编写代码时应用起来不太方便；而对于第三种方式而言，需要特别注意不要从不同模块导入有相同名字的资源，也不要编写同名的自定义函数，所以在初期学习阶段并不建议。</strong></p>
<h2 id="海龟的属性"><a class="header" href="#海龟的属性">海龟的属性</a></h2>
<p>在让海龟画图之前，首先要了解海龟的三个属性，分别为：<em><strong>位置</strong></em>、<em><strong>方向</strong></em>和<em><strong>颜色</strong></em>。</p>
<h3 id="位置"><a class="header" href="#位置">位置</a></h3>
<p>在Python中，海龟的位置是由<code>x</code>和<code>y</code>两个信息组成的，它们分别表示海龟横纵坐标。我们以画布的最中心点为原点，分别在水平和垂直的方向画两条线，这样就画出类似于数学中的平面坐标系，如下图：</p>
<div align="center">
<img name="coord" src="07.海龟画图/./images/coord.png" width="350">
</div>
<!--![coord](./images/coord.png)-->
<p>平面坐标系把整个画布分成了四个部分，也叫四个象限：</p>
<ul>
<li>第一象限：位于坐标系的右上，<code>x</code>和<code>y</code>的值均为正数；</li>
<li>第二象限：位于坐标系的左上，<code>x</code>为负数，<code>y</code>为正数；</li>
<li>第三象限：位于坐标系的左下，<code>x</code>和<code>y</code>的值均为负数；</li>
<li>第四象限：位于坐标系的左上，<code>x</code>为正数，<code>y</code>为负数。</li>
</ul>
<p>坐标的表示方式为<code>(x,y)</code>，如<code>(100,100)</code>、<code>(-43,32)</code>等。</p>
<h3 id="方向"><a class="header" href="#方向">方向</a></h3>
<p>这里提到的方向指的就是<strong>绝对方向</strong>：</p>
<ul>
<li>0°：水平向右</li>
<li>90°：垂直向上</li>
<li>180°：水平向左</li>
<li>270°：垂直向下</li>
</ul>
<p>即，只要当海龟的箭头指向水平向左，那边它的绝对方向就是<code>180°</code>。</p>
<div align="center">
<img name="direction" src="07.海龟画图/./images/direction.png" width="350">
</div>
<!--![direction](./images/direction.png)-->
<p>需要提醒的是，水平向右的绝对方向为<code>0°</code>是模块中默认的情况，我们可以调用<code>mode()</code>函数来设置垂直向上的绝对方向为<code>0°</code>。请查看<a href="07.%E6%B5%B7%E9%BE%9F%E7%94%BB%E5%9B%BE/../%E9%99%84%E5%BD%95/appendix.html#%E6%B5%B7%E9%BE%9F%E7%9A%84%E7%BB%9D%E5%AF%B9%E9%9B%B6%E5%BA%A6">海龟的绝对零度</a>进行详细的学习，我们在学习本章过程中以默认的情况为主。</p>
<h3 id="颜色"><a class="header" href="#颜色">颜色</a></h3>
<p>海龟的颜色分为画笔颜色和填充颜色，画笔颜色决定海龟在画图时线条的颜色，而当海龟在绘制之后，会形成一个平面图形，如果调用了填充函数，会给这个平面图形填充颜色，那么海龟的填充颜色影响的就是这个平面图形内的颜色。</p>
<p>如下图所示，在绘制完等边三角形之后，我们将海龟称动到了坐标为<code>(100, 100)</code>的位置，可以很清楚看到，海龟的外面一圈为<code>红色</code>， 而内部为<code>绿色</code>，这里外面的一圈就是画笔颜色，内部为填充颜色。所以，这只海龟所绘制的等边三角形的线条为<code>红色</code>，而内部填充的为<code>绿色</code>：</p>
<div align="center">
<img name="colors" src="07.海龟画图/./images/colors.png" width="350">
</div>
<!--![colors](./images/colors.png)-->
<h2 id="海龟和它的分身"><a class="header" href="#海龟和它的分身">海龟和它的分身</a></h2>
<p>在导入海龟之后，可以直接让海龟去画图，如下:</p>
<pre><code class="language-python">import turtle as t
t.circle(100)
</code></pre>
<p>这里我们直接用的模块的别名<code>t</code>来画的这个图形；除此之外，也可以用<code>Pen()</code>函数给海龟创建一个影分身来作画。调用这个函数时不需要传递任何参数，并且要注意第一个字母<code>P</code>要大写：</p>
<pre><code class="language-Python">import turtle as t
p1 = t.Pen()
p2 = t.Pen()

p1.pu()
p1.goto(100,100)
p1.pd()

p2.pu()
p2.goto(-100,100)
p2.pd()

t.showturtle()
</code></pre>
<div align="center">
<img name="pen" src="07.海龟画图/./images/pen.png" width="350">
</div>
<!--![pen](./images/pen.png)-->
<p>在创建了分身之后，并不影响我们继续使用别名<code>t</code>去调用海龟的函数让他作画，在上述代码中，我们在创建好两个影分身并移动它们之后，调用了<code>showturtle()</code>函数让海龟本体也显示出来了，此时可以进行绘画的画笔就有了三个。</p>
<h2 id="让海龟去画图一"><a class="header" href="#让海龟去画图一">让海龟去画图(一)</a></h2>
<p>所谓的海龟画图，就是能用调用海龟画图模块<code>turtle</code>的函数，让小海龟在画布上移动画出线条，形成平面图形的过程。所以我们需要掌握主要内容就是如何去调用<code>turtle</code>模块的函数。</br></p>
<p>我们可以根据海龟的属性将海龟的功能分为几个不同的类型：</p>
<p><em><strong>方向</strong></em></p>
<table><thead><tr><th align="left">函数名</th><th align="left">功能</th></tr></thead><tbody>
<tr><td align="left"><code>setheading()</code>,<code>seth()</code></td><td align="left">设置海龟的绝对方向</td></tr>
<tr><td align="left"><code>left()</code>,<code>lt()</code></td><td align="left">向左转动海龟，改变其方向</td></tr>
<tr><td align="left"><code>right()</code>,<code>rt()</code></td><td align="left">向右转动海龟，改变其方向</td></tr>
</tbody></table>
<p><em><strong>位置</strong></em></p>
<table><thead><tr><th align="left">函数名</th><th align="left">功能</th></tr></thead><tbody>
<tr><td align="left"><code>dot()</code></td><td align="left">画出一个点</td></tr>
<tr><td align="left"><code>goto()</code>,<code>setpos()</code>,<code>setposition()</code></td><td align="left">设置海龟的坐标，让海龟从当前位置直接移动到指定坐标</td></tr>
<tr><td align="left"><code>pos()</code>,<code>position()</code></td><td align="left">获取当前海龟的坐标</td></tr>
<tr><td align="left"><code>up()</code>, <code>penup()</code>, <code>pu()</code></td><td align="left">抬笔，海龟移动时不会留下痕迹</td></tr>
<tr><td align="left"><code>down()</code>, <code>pendown()</code>, <code>pd()</code></td><td align="left">落笔，海龟移动时会留下痕迹</td></tr>
<tr><td align="left"><code>forward()</code>, <code>fd()</code></td><td align="left">延着海龟面对的方向向前移动</td></tr>
<tr><td align="left"><code>backward()</code>, <code>bk()</code></td><td align="left">背对海龟面对的方向移动</td></tr>
<tr><td align="left"><code>circle()</code></td><td align="left">让海龟画圆或者画一段弧线，也可以画出正多边形</td></tr>
<tr><td align="left"><code>home()</code></td><td align="left">让海龟的位置回到(0,0)坐标</td></tr>
</tbody></table>
<p><em><strong>颜色</strong></em></p>
<table><thead><tr><th align="left">函数名</th><th align="left">功能</th></tr></thead><tbody>
<tr><td align="left"><code>pencolor()</code></td><td align="left">改变画笔的颜色</td></tr>
<tr><td align="left"><code>fillcolor()</code></td><td align="left">设置填充颜色</td></tr>
<tr><td align="left"><code>begin_fill()</code></td><td align="left">开始填充</td></tr>
<tr><td align="left"><code>end_fill()</code></td><td align="left">结束填充</td></tr>
<tr><td align="left"><code>color()</code></td><td align="left">改变画笔和填充颜色</td></tr>
<tr><td align="left"><code>bgcolor()</code></td><td align="left">改变画布的背景颜色</td></tr>
</tbody></table>
<p><em><strong>画笔与画布控制</strong></em></p>
<table><thead><tr><th align="left">函数名</th><th align="left">功能</th></tr></thead><tbody>
<tr><td align="left"><code>setup()</code></td><td align="left">设置主窗口的尺寸和位置</td></tr>
<tr><td align="left"><code>speed()</code></td><td align="left">改变海龟画图的速度</td></tr>
<tr><td align="left"><code>pensize()</code></td><td align="left">改变画笔的大小，单位为像素</td></tr>
<tr><td align="left"><code>hideturtle()</code>, <code>ht()</code></td><td align="left">隐藏画笔</td></tr>
<tr><td align="left"><code>showturtle()</code>, <code>st()</code></td><td align="left">显示画笔</td></tr>
<tr><td align="left"><code>reset()</code></td><td align="left">重置海龟的状态，并清除画布</td></tr>
</tbody></table>
<p>下面我们对每个函数逐一介绍：</p>
<h3 id="改变海龟的方向"><a class="header" href="#改变海龟的方向">改变海龟的方向</a></h3>
<p>我们可以从<code>相对</code>和<code>绝对</code>两个概念去改变海龟的方向：</p>
<h4 id="设置绝对方向"><a class="header" href="#设置绝对方向">设置绝对方向</a></h4>
<p>可以调用<code>setheading()</code>函数来改变海龟的绝对方向，这个函数接收一个数值型的值；<code>seth()</code>是<code>setheading()</code>的简写，二者用其一即可。</br>
海龟的初始方向为<code>0°</code>,调用了<code>setheading(45)</code>之后，海龟的方向就会变成<code>45°</code>。</p>
<pre><code class="language-python">import turtle as t
t.seth(45)
</code></pre>
<div align="center">
<img name="seth" src="07.海龟画图/./images/seth.png" width="350">
</div>
<!--![seth](./images/seth.png)-->
<h4 id="向左转left和向右转right"><a class="header" href="#向左转left和向右转right">向左转<code>left()</code>和向右转<code>right()</code></a></h4>
<p>让海龟向左或向右转，都是基于当前的方向，所以这种方向的改变是相对的，如果当前海龟的绝对方向为<code>45°</code>，向左转了<code>90°</code>之后，绝对方向就变成了<code>135°</code>：</p>
<pre><code class="language-python">import turtle as t
t.seth(45)
t.left(90)
</code></pre>
<div align="center">
<img name="left" src="07.海龟画图/./images/left.png" width="350">
</div>
<!--![left](./images/left.png)-->
<p><code>right()</code>同理。两个函数都接收数值型参数。</p>
<h3 id="对海龟位置的操作"><a class="header" href="#对海龟位置的操作">对海龟位置的操作</a></h3>
<h4 id="在画布上画上一个点-dot"><a class="header" href="#在画布上画上一个点-dot">在画布上画上一个点 <code>dot()</code></a></h4>
<p><code>dot()</code>函数可以让海龟在画布上画上一个点，它有两个参数<code>size</code>和<code>color</code>:</p>
<ul>
<li><code>size</code> 表示点的粗细，如果没给定一个值，那么画出的点的粗细取<code>pensize*2</code>和<code>pensize+4</code>之间的最大值。</li>
<li><code>color</code>表示点的颜色，传参数的要求和<code>pencolor</code>一下致。</li>
</ul>
<pre><code class="language-python">import turtle as t
p = t.Pen()
p.pu()
p.goto(100, 100)
p.pd()
p.pensize(10)
p.dot()
t.dot(20, 'red')
</code></pre>
<div align="center">
<img name="dot" src="07.海龟画图/./images/dot.png" width="350">
</div>
<!--![dot](./images/dot.png)-->
<h4 id="让海龟直接移动指定位置"><a class="header" href="#让海龟直接移动指定位置">让海龟直接移动指定位置</a></h4>
<p>在本章节的<code>海龟的属性-位置</code>部分介绍了画布的四个象限的分配情况，以及如何根据坐标来表达海龟在画布中的位置，基于对这两个知识点的理解，我们可以调用<code>goto()</code>,<code>setpos()</code>,<code>setposition()</code>这三个函数改移到海龟到指定的坐标位置，这三个函数实现在的功能是一样的，调用时都需要传递两个参数<code>x</code>和<code>y</code>，分别代表目标坐标的横纵坐标；我们这里介绍其中的<code>goto()</code>即可：</p>
<pre><code class="language-python">import turtle as t
t.goto(100, 100)
</code></pre>
<div align="center">
<img name="goto" src="07.海龟画图/./images/goto.png" width="350">
</div>
<!--![goto](./images/goto.png)-->
<p>除了<code>goto()</code>之外，也可以调用<code>setx()</code>和<code>sety()</code>来单独设置海龟的横、纵坐标，这两个函数都只需要传入一上数值型参数即可。</p>
<h4 id="抬笔与落笔"><a class="header" href="#抬笔与落笔">抬笔与落笔</a></h4>
<p>我们已经发现，海龟在画布上移动会画出线条，但是有些线条并不是想要画出图形的一部分，这时我们可以调用抬笔功能，当海龟移动到指定位置后，再调用落笔功能继续作画：</p>
<ul>
<li><code>penup()、pu()、up()</code> 抬笔，三个函数功能一致，无参数。</li>
<li><code>pendown()、pd()、down()</code>落笔，三个函数功能一致，无参数。</li>
</ul>
<pre><code class="language-python">import turtle as t
t.goto(100, 100)
t.pu()
t.goto(-100, 100)
t.pd()
t.goto(-100, 0)
</code></pre>
<div align="center">
<img name="pupd" src="07.海龟画图/./images/pupd.png" width="350">
</div>
<h4 id="获取海龟的位置"><a class="header" href="#获取海龟的位置">获取海龟的位置</a></h4>
<p><code>pos()</code>或<code>position()</code>函数可以返回当前海龟所在位置的坐标：</p>
<pre><code class="language-python">import turtle as t
p = t.position()
print(p)
</code></pre>
<p>执行上述代码之后，print函数会在终端打印如下内容：</p>
<pre><code class="language-python">(0.00,0.00)
</code></pre>
<h4 id="前进-forward--后退-backward"><a class="header" href="#前进-forward--后退-backward">前进 forward , 后退 backward</a></h4>
<p>我们可以用<code>forward()</code>和<code>backward()</code>函数控制海龟前进和后退，这两个函数都要求在被调用时传入一个数值型的参数，表示海龟前进或者后退的距离。<br/>
需要特别注意的是，海龟的移动受到两个因素的影响：海龟的方向和传入参数的正负。</p>
<pre><code class="language-python">import turtle as t
p1 = t.Pen()
p2 = t.Pen()
p3 = t.Pen()
p4 = t.Pen()

p1.pu()
p1.goto(0, 200)
p1.pd()
p1.forward(100)
p1.write(&quot;p1&quot;, font=('Arial', 18))

p2.pu()
p2.goto(0, 100)
p2.pd()
p2.forward(-100)
p2.write(&quot;p2&quot;, font=('Arial', 18))

p3.pu()
p3.goto(0, -100)
p3.pd()
p3.backward(100)
p3.write(&quot;p3&quot;, font=('Arial', 18))

p4.pu()
p4.goto(0, -200)
p4.pd()
p4.backward(-100)
p4.write(&quot;p4&quot;, font=('Arial', 18))
</code></pre>
<div align="center">
<img name="fdbk" src="07.海龟画图/./images/fdbk.png" width="350">
</div>
<!--![fdbk](./images/fdbk.png)-->
<h4 id="画出一个圆弧"><a class="header" href="#画出一个圆弧">画出一个圆弧</a></h4>
<p><code>circle</code>是海龟画图模块中较复杂的一个函数，它可以画布上画出圆弧，在<code>turtle</code>模块中的定义如下：</p>
<pre><code class="language-python">circle(radius, extent=None, steps=None)
</code></pre>
<p>这三个参数分别为：</p>
<ul>
<li><code>radius</code> -- 一个数值</li>
<li><code>extent</code> -- 一个数值 (或 <code>None</code>)</li>
<li><code>steps</code> -- 一个整型数 (或 <code>None</code>)</li>
</ul>
<p>这个函数的功能为绘制一个<code>radius</code>指定半径的圆。圆心在海龟左边<code>radius</code>个单位；<code>extent</code>为一个夹角，用来决定绘制圆的一部分。如未指定 <code>extent</code>则绘制整个圆。如果<code>extent</code>不是完整圆周，则以当前画笔位置为一个端点绘制圆弧。如果<code>radius</code>为正值则朝逆时针方向绘制圆弧，否则朝顺时针方向。最终海龟的朝向会依据<code>extent</code>的值而改变。</p>
<p>圆实际是以其内切正多边形来近似表示的，其边的数量由<code>steps</code>指定。如果未指定边数则会自动确定为一个弧度为<code>extent</code>的圆弧。在指定了<code>steps</code>之后，海龟会将该圆弧内切成<code>steps</code>条连接的等长线段，如果该圆弧为一个完整的圆，那么绘制出来的则为一个正<code>steps</code>边形。</p>
<p>调用这个函数会复杂一些，这里建议同学可以回到常用内建函数一章中的<a href="07.%E6%B5%B7%E9%BE%9F%E7%94%BB%E5%9B%BE/../06.%E5%B8%B8%E7%94%A8%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0/%E5%B8%B8%E7%94%A8%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0.html#%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0">函数的参数</a>部分进行复习。</p>
<ul>
<li><strong>画出完整的圆：</strong></li>
</ul>
<pre><code class="language-python">import turtle as t
t.circle(80)
t.circle(-100)
</code></pre>
<div align="center">
<img name="circle" src="07.海龟画图/./images/circle.png" width="350">
</div>
<p>如上图，首先我们可以根据海龟所在的位置可以判断，海龟是沿着圆的弧线移动画出的圆，其次，根据上面代码，第一个圆的半径是正数，那么画完之后，它位于海龟的左侧，另一个圆的半径为负数，那么这个圆位于了海龟的右侧。</p>
<ul>
<li><strong>画出一段圆弧</strong></li>
</ul>
<pre><code class="language-python">import turtle as t
t.circle(100, 90) #或者 t.circle(100, extent=90)
</code></pre>
<div align="center">
<img name="extent" src="07.海龟画图/./images/extent.png" width="350">
</div>
<p><strong>在一段画圆弧时，海龟的方向会随着移动而发生改变的，只有当所画的圆弧正好为一个完整的圆时，海龟才会回到画弧之前所面对的方向。</strong></p>
<ul>
<li><strong>内切圆弧</strong></li>
</ul>
<pre><code class="language-python">import turtle as t
t.circle(100, 120, 3)
</code></pre>
<div align="center">
<img name="it" src="07.海龟画图/./images/internally_tangent.png" width="350">
</div>
<p>结合代码，我们可以从上图中观察到，海龟在<code>120</code>度的圆弧均匀地点了<code>3</code>个点，在将相临的两点连接之后，把外面的圆弧给舍弃了，最后保留了三个等长的线段。所以基于这一特点，我们可以在完整的圆内内切出正多边形。</p>
<pre><code class="language-python">import turtle as t
t.circle(100, None, 5) # 或者 t.circle(100, steps=5)
</code></pre>
<div align="center">
<img name="polygon" src="07.海龟画图/./images/polygon.png" width="350">
</div>
<p>可以通过改变海龟的绝对方向和半径的正负来改变出正多边形的方向，大家可以自行尝试下列代码：</p>
<pre><code class="language-python">import turtle as t
t.circle(-100, None, 5) # 或者 t.circle(-100, steps=5)
</code></pre>
<pre><code class="language-python">import turtle as t
t.seth(60)
t.circle(-100, None, 5) # 或者 t.circle(-100, steps=5)
</code></pre>
<h4 id="回归原点"><a class="header" href="#回归原点">回归原点</a></h4>
<p>当海龟移动到原点之外的其它位置之后，我们可以调用<code>home()</code>函数让海龟立即回到原点位置，并重置它的绝对方向为初始方向，调用这个函数不需要传递参数。</p>
<pre><code class="language-python">import turtle as t
t.circle(100, 120)
t.home()
</code></pre>
<div align="center">
<img name="home" src="07.海龟画图/./images/home.png" width="350">
</div>
<p>如果直接调用<code>goto(0, 0)</code>，也可以回归到原点，但是它的绝对方向不会被重置，继续保持回归前一刻所面对的方向。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="海龟画图-第二部分"><a class="header" href="#海龟画图-第二部分">海龟画图-第二部分</a></h1>
<h2 id="让海龟去画图二"><a class="header" href="#让海龟去画图二">让海龟去画图(二)</a></h2>
<h3 id="让海龟涂上颜色"><a class="header" href="#让海龟涂上颜色">让海龟涂上颜色</a></h3>
<h4 id="改变画笔的颜色"><a class="header" href="#改变画笔的颜色">改变画笔的颜色</a></h4>
<p>画笔的默认颜色为黑色，可以调用<code>pencolor()</code>改变画笔的颜色，这个函数的参数有很多格式，我们先只学习最简单的格式，即传入有实际颜色涵义的英文字符串，如：</p>
<pre><code class="language-text">&quot;red&quot; &quot;green&quot; &quot;yellow&quot; &quot;blue&quot; &quot;orange&quot; &quot;grey&quot; &quot;cyan&quot; &quot;white&quot; &quot;brown&quot; &quot;black&quot;...
</code></pre>
<pre><code class="language-python">import turtle as t
t.forward(100)
t.pu()
t.goto(0, 100)
t.pencolor(&quot;red&quot;)
t.pd()
t.forward(100)
</code></pre>
<div align="center">
<img name="pencolor" src="07.海龟画图/./images/pencolor.png" width="350">
</div>
<p>我们让海龟先移动了<code>100px</code>，然后抬笔将海龟移动到坐标<code>(0, 100)</code>的位置，改变画笔的颜色为<code>red</code>，再让海龟向前移动了<code>100px</code>，画出红色的线。</p>
<h4 id="填充颜色"><a class="header" href="#填充颜色">填充颜色</a></h4>
<p>在海龟画出一个平面图形之后，可以给这个图形填充颜色，需要调用下面两个函数来实现：</p>
<ul>
<li><code>begin_fill()</code>表示开始填充，需要在要填充的形状之前调用，无参数。</li>
<li><code>end_fill()</code>表示结束填充，在<code>turtle</code>模块中，这个函数才是实际用来填充的函数，也无参数。</li>
</ul>
<p>能够被填充的图形是由写在上述两个函数之间的代码所绘制的。</p>
<p>填充的颜色默认为黑色，需要改变填充颜色时，可以调用<code>fillcolor()</code>实现，所需传入的参数同<code>pencolor()</code>。</p>
<p>强调一下，被填充的是什么颜色只与在<code>end_fill()</code>函数之前最后一次调用<code>fillcolor()</code>所设置的颜色有关。</p>
<p>我们以下面代码为例:</p>
<pre><code class="language-python">import turtle as t
t.fillcolor(&quot;red&quot;) # 设置填充颜色为red
t.begin_fill()
t.circle(100)
t.fillcolor(&quot;blue&quot;) # 设置填充颜色为blue，替换第一次设置的red
t.end_fill()
t.fillcolor(&quot;yellow&quot;) # 设置填充颜色为yellow，只对之后的填充生效，并不影响已经结束填充的图形
</code></pre>
<div align="center">
<img name="fillcolor" src="07.海龟画图/./images/fillcolor.png" width="350">
</div>
<h4 id="同时改变画笔和填充颜色"><a class="header" href="#同时改变画笔和填充颜色">同时改变画笔和填充颜色</a></h4>
<p><code>color()</code>函数可以同时设置画笔和填充的颜色, 允许输入 0 至 3 个参数，这里我们只学习其中两种:</p>
<ul>
<li><code>color(&quot;red&quot;,&quot;blue&quot;)</code> 设置画笔颜色为<code>red</code>，填充颜色为<code>blue</code>。</li>
<li><code>color(&quot;yellow&quot;)</code> 设置画笔与填充颜色均为<code>yellow</code>。</li>
</ul>
<pre><code class="language-python">import turtle as t
t.color(&quot;yellow&quot;)
</code></pre>
<h4 id="设置画布的颜色"><a class="header" href="#设置画布的颜色">设置画布的颜色</a></h4>
<p>海龟画图的画布为白色，如果想设置成其它颜色，可以调用<code>bgcolor()</code>实现，颜色参数的格式同<code>pencolor()</code>.</p>
<pre><code class="language-python">import turtle as t
t.bgcolor(&quot;yellow&quot;)
</code></pre>
<div align="center">
<img name="bgcolor" src="07.海龟画图/./images/bgcolor.png" width="350">
</div>
<h3 id="画笔与画在控制"><a class="header" href="#画笔与画在控制">画笔与画在控制</a></h3>
<h4 id="设置画布大小和位置"><a class="header" href="#设置画布大小和位置">设置画布大小和位置</a></h4>
<p><code>setup()</code>函数可以设置主窗口的大小和位置，它有四个参数：</p>
<pre><code class="language-Python">import turtle as t
t.setup(width=0.5, height=0.75, startx=None, starty=None)
</code></pre>
<ul>
<li>width -- 如为一个整型数值，表示大小为多少像素，如为一个浮点数值，则表示屏幕的占比；默认为屏幕的 50%</li>
<li>height -- 如为一个整型数值，表示高度为多少像素，如为一个浮点数值，则表示屏幕的占比；默认为屏幕的 75%</li>
<li>startx -- 如为正值，表示初始位置距离屏幕左边缘多少像素，负值表示距离右边缘，None 表示窗口水平居中</li>
<li>starty -- 如为正值，表示初始位置距离屏幕上边缘多少像素，负值表示距离下边缘，None 表示窗口垂直居中</li>
</ul>
<pre><code class="language-Python">import turtle as t
t.setup(300, 300, 0, 0)
</code></pre>
<p><img src="07.%E6%B5%B7%E9%BE%9F%E7%94%BB%E5%9B%BE/./images/setup.png" alt="setup" /></p>
<h4 id="设置海龟绘制速度"><a class="header" href="#设置海龟绘制速度">设置海龟绘制速度</a></h4>
<p>海龟模块中<code>speed()</code>函数可以设置绘制速度，这个函数只能接收<code>0~10</code>之间的整数，当传入<code>0</code>时，海龟的绘制速度是最快的，其次速度值从<code>1</code>到<code>10</code>，画线和海龟转向的动画效果逐级加快；如果输入数值大于<code>10</code>或小于<code>0.5</code>则速度设为<code>0</code>。 </br>
也可以传入速度字符串设置绘制速度，速度字符串与速度值的对应关系如下:</p>
<ul>
<li>&quot;fastest&quot;: 0 最快</li>
<li>&quot;fast&quot;: 10 快</li>
<li>&quot;normal&quot;: 6 正常</li>
<li>&quot;slow&quot;: 3 慢</li>
<li>&quot;slowest&quot;: 1 最慢</li>
</ul>
<pre><code class="language-python">import turtle as t
t.speed(0)
t.speed(&quot;normal&quot;)
</code></pre>
<h4 id="设置画笔的粗细"><a class="header" href="#设置画笔的粗细">设置画笔的粗细</a></h4>
<p>画笔的默认为1px，调用<code>pensize()</code>函数可以设置画笔所画线条的粗细。</p>
<pre><code class="language-Python">import turtle as t
t.forward(100)
</code></pre>
<div align="center">
<img name="pensize1" src="07.海龟画图/./images/pensize1.png" width="350">
</div>
<!--![pensize1](./images/pensize1.png)-->
<pre><code class="language-Python">import turtle as t
t.pensize(5)
t.pencolor(&quot;red&quot;)
t.forward(100)
</code></pre>
<div align="center">
<img name="pensize5" src="07.海龟画图/./images/pensize5.png" width="350">
</div>
<!--![pensize5](./images/pensize5.png)-->
<h4 id="隐藏与显示画笔"><a class="header" href="#隐藏与显示画笔">隐藏与显示画笔</a></h4>
<p>在上面的学习过程中所示的图片中，可以看到海龟一直显示在画布上，可以调用<code>hideturtle()</code>使海龟不可见，隐藏之后在绘制复杂图形时可以显著加快绘制速度。</p>
<pre><code class="language-python">import turtle as t
t.hideturtle() # 或 t.ht()
</code></pre>
<p>如果想重新让海龟显示在画布上，可以调用<code>showturtle()</code>:</p>
<pre><code class="language-python">import turtle as t
t.showturtle() # 或 t.st()
</code></pre>
<h4 id="重置所有"><a class="header" href="#重置所有">重置所有</a></h4>
<p><code>reset()</code>可以重置海龟的所有状态，并从画布中消除所有绘制的图形。</p>
<pre><code class="language-python">import turtle as t
t.color(&quot;yellow&quot;)
t.seth(100)
t.goto(100, 100)
t.reset()
</code></pre>
<div align="center">
<img name="reset" src="07.海龟画图/./images/reset.png" width="350">
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="编程中的三大结构"><a class="header" href="#编程中的三大结构">编程中的三大结构</a></h1>
<p>Python是一种高级、通用、解释性的编程语言，它支持多种编程范式，包括过程式、面向对象和函数式编程。在Python中，程序的控制结构主要由三大基本结构构成：顺序结构、选择结构和循环结构。这三大结构为程序提供了基本的控制流程，使得程序能够按照特定的方式执行。在本文中，我们将深入探讨这三大结构的使用方法、示例和最佳实践。</p>
<h2 id="顺序结构"><a class="header" href="#顺序结构">顺序结构</a></h2>
<p>顺序结构是程序执行的默认结构，代码按照从上到下的顺序执行，每一行代码都会被依次执行。在Python中，大多数代码都是按照顺序结构编写的。以下是一个简单的顺序结构的示例：</p>
<pre><code class="language-python">print(&quot;这是第一行&quot;)
print(&quot;这是第二行&quot;)
print(&quot;这是第三行&quot;)
</code></pre>
<p>在这个例子中，代码会按照从上到下的顺序执行，依次输出每一行的内容。顺序结构是程序的基础，是编写代码的最简单形式。</p>
<p>下图为顺序结构的流程图</p>
<div align="center">
<img name="sequential" src="08.选择结构/./images/sequential.png" width="250"/>
</div>
<h2 id="选择结构if-语句"><a class="header" href="#选择结构if-语句">选择结构（if 语句）</a></h2>
<p>选择结构也叫分支结构，允许程序根据条件的真假选择性地执行不同的代码块。在Python中，使用<code>if</code>语句来实现选择结构。基本的<code>if</code>语句结构如下：</p>
<pre><code class="language-python">if 条件:
    # 如果条件为真，执行这里的代码块
else:
    # 如果条件为假，执行这里的代码块
</code></pre>
<p><code>elif</code>（else if的缩写）关键字可以用于处理多个条件的情况：</p>
<pre><code class="language-python">if 条件1:
    # 如果条件1为真，执行这里的代码块
elif 条件2:
    # 如果条件1为假，但条件2为真，执行这里的代码块
else:
    # 如果所有条件都为假，执行这里的代码块
</code></pre>
<p>选择结构使得程序能够根据不同的条件执行不同的代码路径，实现分支逻辑。</p>
<div align="center">
<img name="selection" src="08.选择结构/./images/selection.png" width="250"/>
</div>
<h3 id="示例演示"><a class="header" href="#示例演示">示例演示：</a></h3>
<p>考虑一个简单的示例，根据用户的年龄判断其所属的年龄段：</p>
<pre><code class="language-python">user_age = int(input(&quot;请输入您的年龄：&quot;))

if user_age &lt; 0:
    print(&quot;年龄不能为负数&quot;)
elif 0 &lt;= user_age &lt; 18:
    print(&quot;您是未成年人&quot;)
elif 18 &lt;= user_age &lt; 65:
    print(&quot;您是成年人&quot;)
else:
    print(&quot;您是老年人&quot;)
</code></pre>
<p>在这个例子中，通过<code>if</code>语句判断用户所属的年龄段并输出相应的信息。</p>
<h2 id="循环结构"><a class="header" href="#循环结构">循环结构</a></h2>
<p>循环结构允许程序重复执行特定的代码块，直到满足退出条件。Python中主要有两种循环结构：<code>for</code>循环和<code>while</code>循环。</p>
<div align="center">
<img name="loop" src="08.选择结构/./images/loop.png" width="250"/>
</div>
<h3 id="for-循环"><a class="header" href="#for-循环">for 循环</a></h3>
<p><code>for</code>循环用于遍历可迭代对象，每次迭代执行相同的代码块。基本语法如下：</p>
<pre><code class="language-python">for 变量 in 可迭代对象:
    # 执行这里的代码块
</code></pre>
<p>例如，遍历一个列表：</p>
<pre><code class="language-python">fruits = [&quot;苹果&quot;, &quot;香蕉&quot;, &quot;橙子&quot;]
for fruit in fruits:
    print(fruit)
</code></pre>
<p><code>for</code>循环会依次将列表中的元素赋值给<code>fruit</code>变量，并执行相应的代码块。这种循环适用于已知迭代次数的情况。</p>
<h3 id="while-循环"><a class="header" href="#while-循环">while 循环</a></h3>
<p><code>while</code>循环用于在条件为真的情况下重复执行代码块，直到条件变为假。基本语法如下：</p>
<pre><code class="language-python">while 条件:
    # 执行这里的代码块
</code></pre>
<p>例如，计算一个数的阶乘：</p>
<pre><code class="language-python">number = 5
factorial = 1

while number &gt; 0:
    factorial *= number
    number -= 1

print(&quot;5的阶乘是:&quot;, factorial)
</code></pre>
<p><code>while</code>循环会在每次迭代前检查条件，只有在条件为真时才执行循环体。这种循环适用于未知迭代次数的情况。</p>
<h3 id="示例演示-1"><a class="header" href="#示例演示-1">示例演示：</a></h3>
<p>考虑一个简单的示例，使用<code>while</code>循环输出斐波那契数</p>
<p>列的前十个数字：</p>
<pre><code class="language-python">a, b = 0, 1
count = 0

while count &lt; 10:
    print(a, end=&quot; &quot;)
    a, b = b, a + b
    count += 1
</code></pre>
<p>在这个例子中，使用<code>while</code>循环输出斐波那契数列的前十个数字，直到<code>count</code>达到10为止。</p>
<h2 id="结构的嵌套和组合"><a class="header" href="#结构的嵌套和组合">结构的嵌套和组合</a></h2>
<p>在实际的程序中，三大结构通常会被灵活地嵌套和组合使用，以满足更复杂的逻辑需求。例如，可以在循环结构中嵌套选择结构，或者在选择结构中嵌套循环结构，以实现更丰富的功能。</p>
<h3 id="示例演示-2"><a class="header" href="#示例演示-2">示例演示：</a></h3>
<p>考虑一个简单的示例，使用嵌套结构判断一个数是否为质数：</p>
<pre><code class="language-python">num = int(input(&quot;请输入一个整数：&quot;))

if num &gt; 1:
    for i in range(2, int(num/2)+1):
        if (num % i) == 0:
            print(num, &quot;不是质数&quot;)
            break
    else:
        print(num, &quot;是质数&quot;)
else:
    print(num, &quot;不是质数&quot;)
</code></pre>
<p>通过嵌套使用<code>if</code>语句和<code>for</code>循环，判断用户输入的整数是否为质数。</p>
<h2 id="总结与最佳实践"><a class="header" href="#总结与最佳实践">总结与最佳实践</a></h2>
<ul>
<li><strong>清晰的代码结构：</strong> 为了提高代码的可读性，建议使用适当的缩进和空格，使代码结构清晰。</li>
<li><strong>合理使用注释：</strong> 对于复杂的逻辑或特殊情况，使用注释来解释代码的意图，提高代码的可维护性。</li>
<li><strong>谨慎使用嵌套：</strong> 避免过度嵌套，以保持代码的简洁和可读性。过深的嵌套结构可能会导致代码难以理解和维护。</li>
<li><strong>利用函数封装逻辑：</strong> 对于重复使用的逻辑，考虑将其封装成函数，提高代码的模块化和复用性。</li>
<li><strong>灵活使用三大结构：</strong> 根据具体问题的需求，灵活使用顺序结构、选择结构和循环结构，构建清晰且高效的程序。</li>
</ul>
<p>通过深入理解和熟练运用顺序结构、选择结构和循环结构，程序员能够更加灵活地设计和实现各种算法和应用，使得代码具有更好的可读性、可维护性和可扩展性。这三大结构为Python程序提供了强大的控制能力，使得开发者能够应对不同的编程场景，创造出高效且功能强大的应用程序。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="编程中的三大结构-1"><a class="header" href="#编程中的三大结构-1">编程中的三大结构</a></h1>
<p>Python是一种高级、通用、解释性的编程语言，它支持多种编程范式，包括过程式、面向对象和函数式编程。在Python中，程序的控制结构主要由三大基本结构构成：顺序结构、选择结构和循环结构。这三大结构为程序提供了基本的控制流程，使得程序能够按照特定的方式执行。在本文中，我们将深入探讨这三大结构的使用方法、示例和最佳实践。</p>
<h2 id="顺序结构-1"><a class="header" href="#顺序结构-1">顺序结构</a></h2>
<p>顺序结构是程序执行的默认结构，代码按照从上到下的顺序执行，每一行代码都会被依次执行。在Python中，大多数代码都是按照顺序结构编写的。以下是一个简单的顺序结构的示例：</p>
<pre><code class="language-python">print(&quot;这是第一行&quot;)
print(&quot;这是第二行&quot;)
print(&quot;这是第三行&quot;)
</code></pre>
<p>在这个例子中，代码会按照从上到下的顺序执行，依次输出每一行的内容。顺序结构是程序的基础，是编写代码的最简单形式。</p>
<p>下图为顺序结构的流程图</p>
<div align="center">
<img name="sequential" src="08.选择结构/./images/sequential.png" width="250"/>
</div>
<h2 id="选择结构if-语句-1"><a class="header" href="#选择结构if-语句-1">选择结构（if 语句）</a></h2>
<p>选择结构也叫分支结构，允许程序根据条件的真假选择性地执行不同的代码块。在Python中，使用<code>if</code>语句来实现选择结构。基本的<code>if</code>语句结构如下：</p>
<pre><code class="language-python">if 条件:
    # 如果条件为真，执行这里的代码块
else:
    # 如果条件为假，执行这里的代码块
</code></pre>
<p><code>elif</code>（else if的缩写）关键字可以用于处理多个条件的情况：</p>
<pre><code class="language-python">if 条件1:
    # 如果条件1为真，执行这里的代码块
elif 条件2:
    # 如果条件1为假，但条件2为真，执行这里的代码块
else:
    # 如果所有条件都为假，执行这里的代码块
</code></pre>
<p>选择结构使得程序能够根据不同的条件执行不同的代码路径，实现分支逻辑。</p>
<div align="center">
<img name="selection" src="08.选择结构/./images/selection.png" width="250"/>
</div>
<h3 id="示例演示-3"><a class="header" href="#示例演示-3">示例演示：</a></h3>
<p>考虑一个简单的示例，根据用户的年龄判断其所属的年龄段：</p>
<pre><code class="language-python">user_age = int(input(&quot;请输入您的年龄：&quot;))

if user_age &lt; 0:
    print(&quot;年龄不能为负数&quot;)
elif 0 &lt;= user_age &lt; 18:
    print(&quot;您是未成年人&quot;)
elif 18 &lt;= user_age &lt; 65:
    print(&quot;您是成年人&quot;)
else:
    print(&quot;您是老年人&quot;)
</code></pre>
<p>在这个例子中，通过<code>if</code>语句判断用户所属的年龄段并输出相应的信息。</p>
<h2 id="循环结构-1"><a class="header" href="#循环结构-1">循环结构</a></h2>
<p>循环结构允许程序重复执行特定的代码块，直到满足退出条件。Python中主要有两种循环结构：<code>for</code>循环和<code>while</code>循环。</p>
<div align="center">
<img name="loop" src="08.选择结构/./images/loop.png" width="250"/>
</div>
<h3 id="for-循环-1"><a class="header" href="#for-循环-1">for 循环</a></h3>
<p><code>for</code>循环用于遍历可迭代对象，每次迭代执行相同的代码块。基本语法如下：</p>
<pre><code class="language-python">for 变量 in 可迭代对象:
    # 执行这里的代码块
</code></pre>
<p>例如，遍历一个列表：</p>
<pre><code class="language-python">fruits = [&quot;苹果&quot;, &quot;香蕉&quot;, &quot;橙子&quot;]
for fruit in fruits:
    print(fruit)
</code></pre>
<p><code>for</code>循环会依次将列表中的元素赋值给<code>fruit</code>变量，并执行相应的代码块。这种循环适用于已知迭代次数的情况。</p>
<h3 id="while-循环-1"><a class="header" href="#while-循环-1">while 循环</a></h3>
<p><code>while</code>循环用于在条件为真的情况下重复执行代码块，直到条件变为假。基本语法如下：</p>
<pre><code class="language-python">while 条件:
    # 执行这里的代码块
</code></pre>
<p>例如，计算一个数的阶乘：</p>
<pre><code class="language-python">number = 5
factorial = 1

while number &gt; 0:
    factorial *= number
    number -= 1

print(&quot;5的阶乘是:&quot;, factorial)
</code></pre>
<p><code>while</code>循环会在每次迭代前检查条件，只有在条件为真时才执行循环体。这种循环适用于未知迭代次数的情况。</p>
<h3 id="示例演示-4"><a class="header" href="#示例演示-4">示例演示：</a></h3>
<p>考虑一个简单的示例，使用<code>while</code>循环输出斐波那契数</p>
<p>列的前十个数字：</p>
<pre><code class="language-python">a, b = 0, 1
count = 0

while count &lt; 10:
    print(a, end=&quot; &quot;)
    a, b = b, a + b
    count += 1
</code></pre>
<p>在这个例子中，使用<code>while</code>循环输出斐波那契数列的前十个数字，直到<code>count</code>达到10为止。</p>
<h2 id="结构的嵌套和组合-1"><a class="header" href="#结构的嵌套和组合-1">结构的嵌套和组合</a></h2>
<p>在实际的程序中，三大结构通常会被灵活地嵌套和组合使用，以满足更复杂的逻辑需求。例如，可以在循环结构中嵌套选择结构，或者在选择结构中嵌套循环结构，以实现更丰富的功能。</p>
<h3 id="示例演示-5"><a class="header" href="#示例演示-5">示例演示：</a></h3>
<p>考虑一个简单的示例，使用嵌套结构判断一个数是否为质数：</p>
<pre><code class="language-python">num = int(input(&quot;请输入一个整数：&quot;))

if num &gt; 1:
    for i in range(2, int(num/2)+1):
        if (num % i) == 0:
            print(num, &quot;不是质数&quot;)
            break
    else:
        print(num, &quot;是质数&quot;)
else:
    print(num, &quot;不是质数&quot;)
</code></pre>
<p>通过嵌套使用<code>if</code>语句和<code>for</code>循环，判断用户输入的整数是否为质数。</p>
<h2 id="总结与最佳实践-1"><a class="header" href="#总结与最佳实践-1">总结与最佳实践</a></h2>
<ul>
<li><strong>清晰的代码结构：</strong> 为了提高代码的可读性，建议使用适当的缩进和空格，使代码结构清晰。</li>
<li><strong>合理使用注释：</strong> 对于复杂的逻辑或特殊情况，使用注释来解释代码的意图，提高代码的可维护性。</li>
<li><strong>谨慎使用嵌套：</strong> 避免过度嵌套，以保持代码的简洁和可读性。过深的嵌套结构可能会导致代码难以理解和维护。</li>
<li><strong>利用函数封装逻辑：</strong> 对于重复使用的逻辑，考虑将其封装成函数，提高代码的模块化和复用性。</li>
<li><strong>灵活使用三大结构：</strong> 根据具体问题的需求，灵活使用顺序结构、选择结构和循环结构，构建清晰且高效的程序。</li>
</ul>
<p>通过深入理解和熟练运用顺序结构、选择结构和循环结构，程序员能够更加灵活地设计和实现各种算法和应用，使得代码具有更好的可读性、可维护性和可扩展性。这三大结构为Python程序提供了强大的控制能力，使得开发者能够应对不同的编程场景，创造出高效且功能强大的应用程序。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="选择结构"><a class="header" href="#选择结构">选择结构</a></h1>
<h2 id="引言-2"><a class="header" href="#引言-2">引言</a></h2>
<p>在Python编程语言中，<code>if</code>是选择结构最主要的语句，它是一项基本而强大的控制结构，用于根据特定条件的真假执行不同的代码块。这是一种编写灵活和适应性强的程序逻辑的关键工具。本章将深入探讨<code>if</code>语句的各个方面，包括基本语法、多分支结构、条件表达式、嵌套结构、缩进的重要性以及通过示例演示其实际用法。</p>
<p>试想以下场景：</p>
<ul>
<li>如果到了18周岁，就可以开车了</li>
<li>如果周末不下雨，就约同学去骑行，否则就在家写作业</li>
<li>给学生的数学成绩分为优、良、中、差</li>
<li>去市场买菜的时候，比较哪家又好又便宜就买那家</li>
</ul>
<p>这些问题都需要用选择结构去解决。</p>
<h2 id="基本语法结构"><a class="header" href="#基本语法结构">基本语法结构</a></h2>
<h3 id="二元分支结构"><a class="header" href="#二元分支结构">二元分支结构</a></h3>
<p><code>if</code>语句二元分支结构的基本语法结构如下：</p>
<pre><code class="language-python">if 条件:
    # 如果条件为真，执行这里的代码块
</code></pre>
<p>或</p>
<pre><code class="language-python">if 条件:
    # 如果条件为真，执行这里的代码块
else:
    # 如果条件为假，执行这里的代码块
</code></pre>
<p>第一种结构中，当<code>条件</code>满足时，也就是这个表达式返回<code>True</code>或者本身就是个<code>真值</code>，则会执行<code>:</code>下面一行被缩进的代码，否则什么都不做。但是在第二种结构中，有了<code>else</code>语句，那么当<code>条件</code>不成立时，就行执行<code>else:</code>以下被缩进的语句；这里<code>else</code>的后面不需要写出条件表达式。</p>
<h4 id="示例演示-6"><a class="header" href="#示例演示-6">示例演示</a></h4>
<ul>
<li>如果到了18周岁，就可以开车了</li>
</ul>
<pre><code class="language-python">age = int(input(&quot;请输入你的年龄:&quot;))

if age &gt;= 18:
    print(&quot;你可以开车了!&quot;)
</code></pre>
<pre><code class="language-shell"># 第一次执行，输入19，会打印出&quot;你可以开车了!&quot;
请输入你的年龄:19
你可以开车了!
# 第二次执行，输入17，什么都不会打印
请输入你的年龄:17
</code></pre>
<ul>
<li>如果周末不下雨，就约同学去骑行，否则就在家写作业</li>
</ul>
<pre><code class="language-python">weather = input(&quot;请输入明天的天气:&quot;)

if weather != 'rain':
    print(&quot;约同学去骑行&quot;)
else
    print(&quot;在家写作业&quot;)
</code></pre>
<pre><code class="language-shell"># 第一次执行，输入sunshine，会打印出&quot;约同学去骑行&quot;
请输入明天的天气:sunshine
约同学去骑行
# 第二次执行，输入rain，会打印出&quot;在家写作业&quot;
请输入明天的天气:rain
在家写作业
</code></pre>
<h3 id="多分支结构"><a class="header" href="#多分支结构">多分支结构</a></h3>
<p><code>if</code>语句可以扩展为多分支结构，通过使用<code>elif</code>（else if的缩写）关键字，可以处理多个条件。例如：</p>
<pre><code class="language-python">if 条件1:
    # 如果条件1为真，执行这里的代码块
elif 条件2:
    # 如果条件1为假，但条件2为真，执行这里的代码块
......
elif 条件n:
    # 如果条件1~n-1为假，但条件n为真，执行这里的代码块
else:
    # 如果所有条件都为假，执行这里的代码块
</code></pre>
<p>这种结构允许程序根据多个条件进行逻辑分支，更灵活地处理各种情况。</p>
<h4 id="示例演示-7"><a class="header" href="#示例演示-7">示例演示</a></h4>
<ul>
<li>给学生的数学成绩分为优、良、中、差</li>
</ul>
<pre><code class="language-python">score = int(input(&quot;请输入你的成绩:&quot;))

if score &gt;= 90:
    print(&quot;成绩:优&quot;)
elif score &gt;= 80:
    print(&quot;成绩:良&quot;)
elif score &gt;= 60:
    print(&quot;成绩:中&quot;)
else:
    print(&quot;成绩:差&quot;)
</code></pre>
<h3 id="条件表达式"><a class="header" href="#条件表达式">条件表达式</a></h3>
<p>条件通常是表达式，可以是比较运算、逻辑运算、成员运算等返回布尔值的操作。例如：</p>
<pre><code class="language-python">x = 10
if x &gt; 0:
    print(&quot;x 是正数&quot;)
else:
    print(&quot;x 不是正数&quot;)
</code></pre>
<p>在这个例子中，条件是<code>x &gt; 0</code>，如果这个条件为真，就执行<code>print(&quot;x 是正数&quot;)</code>，否则执行<code>print(&quot;x 不是正数&quot;)</code>。条件表达式的灵活性使得<code>if</code>语句可以适应各种判断场景。</p>
<p>也可以直接使用<code>bool</code>类型的值：</p>
<pre><code class="language-python">flag = True

if flag:
    print(&quot;flag 是真值&quot;)
</code></pre>
<h3 id="嵌套结构"><a class="header" href="#嵌套结构">嵌套结构</a></h3>
<p><code>if</code>语句可以嵌套在其他<code>if</code>语句内，形成更复杂的条件结构。这样的嵌套结构使得程序能够更细致地处理各种情况。例如：</p>
<pre><code class="language-python">x = 5
if x &gt; 0:
    if x % 2 == 0:
        print(&quot;x 是正偶数&quot;)
    else:
        print(&quot;x 是正奇数&quot;)
else:
    print(&quot;x 不是正数&quot;)
</code></pre>
<p>在这个例子中，外层<code>if</code>语句检查<code>x</code>是否为正数，如果是，进一步嵌套的<code>if</code>语句判断<code>x</code>是否为偶数或奇数。嵌套结构可根据具体问题的复杂性灵活运用，但需要注意避免过度嵌套，以保持代码的可读性。</p>
<h2 id="缩进的重要性"><a class="header" href="#缩进的重要性">缩进的重要性</a></h2>
<p>在Python中，缩进是一种语法结构，而不仅仅是代码格式。它决定了代码块的开始和结束，是Python语言独有的特点。因此，要确保同一代码块的缩进相同，否则会导致语法错误或逻辑错误。例如：</p>
<pre><code class="language-python">if 条件:
    # 代码块 A
    if 另一个条件:
        # 代码块 B
    else:
        # 代码块 C
else:
    # 代码块 D
</code></pre>
<p>在这个例子中，代码块 <code>B</code> 和代码块 <code>C</code> 同属于外层的<code>if</code>语句，因此它们的缩进相同。与之相反，代码块 <code>D</code> 是属于外层的<code>else</code>语句的，所以它的缩进与<code>else</code>语句一致。</p>
<h2 id="示例演示-8"><a class="header" href="#示例演示-8">示例演示</a></h2>
<p>为了更全面地理解<code>if</code>语句的实际应用，考虑以下示例：一个简单的登录系统。用户需要输入用户名和密码，程序会根据预设的用户名和密码进行验证，根据验证结果给出相应的提示。</p>
<pre><code class="language-python"># 预设的用户名和密码
correct_username = &quot;user123&quot;
correct_password = &quot;pass456&quot;
# 用户输入
input_username = input(&quot;请输入用户名：&quot;)
input_password = input(&quot;请输入密码：&quot;)
success = message = None

# 登录验证
if username == correct_username and password == correct_password:
    success, message = True, &quot;登录成功&quot;
else:
    success, message = False, &quot;用户名或密码错误&quot;

if success:
    print(message)
else:
    print(message)
</code></pre>
<p>在这个示例中，<code>authenticate</code>函数接受用户输入的用户名和密码，与预设的正确用户名和密码进行比较，返回验证结果。主程序根据验证结果使用<code>if</code>语句输出相应的提示信息。这个简单的示例展示了<code>if</code>语句在实际应用中的作用，根据条件的真假执行不同的代码块。</p>
<h2 id="实际场景的应用"><a class="header" href="#实际场景的应用">实际场景的应用</a></h2>
<h3 id="数据处理与分析"><a class="header" href="#数据处理与分析">数据处理与分析</a></h3>
<p>在数据处理与分析的场景中，<code>if</code>语句常用于根据数据的特征或条件执行不同的数据处理步骤。例如：</p>
<pre><code class="language-python">if data_type == &quot;numeric&quot;:
    # 执行数值型数据处理
    process_numeric_data(data)
elif data_type == &quot;text&quot;:
    # 执行文本型数据处理
    process_text_data(data)
else:
    # 执行其他数据处理
    process_other_data(data)
</code></pre>
<h3 id="用户权限管理"><a class="header" href="#用户权限管理">用户权限管理</a></h3>
<p>在用户权限管理中，<code>if</code>语句可以根据用户的角色或权限级别来控制其对系统资源的访问。例如：</p>
<pre><code class="language-python">if user_role == &quot;admin&quot;:
    # 执行管理员权限的操作
    perform_admin_actions()
elif user_role == &quot;user&quot;:
    # 执行普通用户权限的操作
    perform_user_actions()
else:
    # 执行其他角色的操作
    perform_generic_actions()
</code></pre>
<h3 id="程序异常处理"><a class="header" href="#程序异常处理">程序异常处理</a></h3>
<p>在程序中，<code>if</code>语句通常用于处理异常情况。例如，在文件读取时，可以使用<code>if</code>语句检查文件是否存在：</p>
<pre><code class="language-python">file_path = &quot;example.txt&quot;

if os.path.exists(file_path):
    with open(file_path, 'r') as file:
        # 执行文件读取操作
        content = file.read()
else:
    print(&quot;文件不存在，无法读取。&quot;)
</code></pre>
<h2 id="总结-2"><a class="header" href="#总结-2">总结</a></h2>
<p><code>if</code>语句是Python中一项基本而强大的控制结构，通过它，程序能够根据不同的条件采取不同的行动，使得代码更灵活、可读性更强。理解其基本语法、多分支结构、条件表达式、嵌套结构和缩进的重要性，能够帮助开发者更有效地使用<code>if</code>语句构建复杂的程序逻辑。</p>
<p>在实际应用中，<code>if</code>语句通常用于处理用户输入、业务逻辑判断、状态管理等方面。它的灵活性使得程序可以根据不同的情况执行不同的代码块，从而满足各种需求。在编写代码时，务必注意缩进，因为它不仅仅是格式规范，更是Python语法的一部分。通过合理使用<code>if</code>语句，可以写出结构清晰、逻辑严谨的代码，提高代码的可维护性和可读性。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="循环"><a class="header" href="#循环">循环</a></h1>
<p>在 Python 中，循环是一种重要的控制结构，用于重复执行一组语句。Python 提供了两种主要的循环结构：for 循环和 while 循环。</p>
<h2 id="for-循环-2"><a class="header" href="#for-循环-2">for 循环</a></h2>
<p><code>for</code> 循环是 Python 中用于迭代访问序列元素的重要工具。通过 <code>for</code> 循环，你能够方便地遍历列表、元组、字符串等可迭代对象的元素，执行特定的代码块。
<code>for</code> 循环的基本语法如下：</p>
<pre><code class="language-python">for 变量 in 可迭代对象:
    # 执行这里的代码块
else:
    # 执行这里的代码块
</code></pre>
<ul>
<li><strong>变量：</strong> 在每次迭代中，可迭代对象中的一个元素会被赋值给变量。你可以使用这个变量在代码块中进行操作。</li>
<li><strong>可迭代对象：</strong> 任何可以被迭代的对象，例如列表、元组、字符串等。<code>for</code> 循环会按顺序迭代可迭代对象中的元素。</li>
<li><strong>else:</strong> 循环结束之后执行的代码。</li>
<li>循环语句同样有缩进的要求。</li>
</ul>
<p>下面是一个简单的例子，演示如何使用 <code>for</code> 循环遍历列表中的元素：</p>
<pre><code class="language-python">for i in range(5):
    print(i)
else:
    print(&quot;end&quot;)
</code></pre>
<p>这段代码会输出：</p>
<pre><code>0
1
2
3
4
end
</code></pre>
<h3 id="执行过程"><a class="header" href="#执行过程">执行过程</a></h3>
<p><code>for</code> 循环的工作原理是，它会依次取出可迭代对象中的每个元素，并将元素赋值给指定的变量，然后执行循环体中的代码块。这个过程会一直持续，直到可迭代对象中的所有元素都被访问完。</p>
<p>让我们通过一个简单的例子来理解 <code>for</code> 循环的工作原理：</p>
<pre><code class="language-python">
for num in range(1, 6):
    square = num ** 2
    print(f&quot;{num} 的平方是 {square}&quot;)
</code></pre>
<p>这段代码会输出：</p>
<pre><code>1 的平方是 1
2 的平方是 4
3 的平方是 9
4 的平方是 16
5 的平方是 25
</code></pre>
<p>在每次迭代中，<code>num</code> 变量都被赋值为 <code>numbers</code> 列表中的一个元素，然后计算平方并输出。</p>
<h3 id="range-函数与-for-循环结合"><a class="header" href="#range-函数与-for-循环结合"><code>range()</code> 函数与 <code>for</code> 循环结合</a></h3>
<p><code>range()</code> 函数是 Python 中常用的生成数字序列的函数。结合 <code>for</code> 循环，<code>range()</code> 可以用于指定循环的次数或遍历一定范围的数字。<code>range()</code> 的基本语法如下：</p>
<pre><code class="language-python">range(start, stop, step)
</code></pre>
<p>三个参数只可能为整型数值</p>
<ul>
<li><strong>start</strong> 序列起始值，默认为 0，可选值。</li>
<li><strong>stop</strong> 序列终止值，不包含在序列中。</li>
<li><strong>step</strong> 步长，即两个相邻数字之间的差值，默认为 1；也为可选值。</li>
</ul>
<p>根据上面的说明，range 函数可以大致有三种调用方式：</p>
<ol>
<li><code>range(stop):</code>从0开始到<code>stop-1</code>结束，循环<code>stop</code>次；</li>
<li><code>range(start, stop):</code>从 <code>start</code>开始到<code>stop-1</code>结束，循环<code>stop-start</code>次；</li>
<li><code>range(start, stop, step):</code>从 <code>start</code>开始到<code>stop-1</code>结束,每次循环步长为<code>step</code>, 如果<code>step</code>为正数，需要满足<code>stop&gt;start</code>，否则要求<code>stop&lt;start</code>。</li>
</ol>
<p>这里可以用数学中区间来描述<code>start</code>与<code>stop</code>的范围 <code>[start, stop)</code>，即左闭右开。</p>
<h4 id="示例演示-9"><a class="header" href="#示例演示-9">示例演示</a></h4>
<details>
<summary>利用 for 循环计算从1加到100的总和。</summary>
<pre>
<code class="language-Python">
summ = 0
for i in range(1, 101):
    summ += i
print(f"1到100的总和为{summ}")
</code>
</pre>
</details>
<details>
<summary>利用 for 循环打印出1-20以内所有的奇数。</summary>
<pre>
<code class="language-Python">
"""
利用步长
"""
for i in range(1, 21, 2):
    print(i)
</code>
<code class="language-Python">
"""
利用if条件语句与 for循环语句的嵌套
"""
for i in range(21):
    if i % 2 == 1:
        print(i)
</code>
</pre>
</details>
<details>
<summary>依次输入期末考试的各科成绩，总计算出平均值。</summary>
<pre>
<code class="language-Python">
n = int(input("输入学科数量:"))
score = 0
for i in range(n):
    x = int(input("输入第%d科成绩:" %(i+1)))
    score = score + x
print("平均成绩为：%.2f" %(score/n))
</code>
</pre>
</details>
<h3 id="嵌套循环"><a class="header" href="#嵌套循环">嵌套循环</a></h3>
<p><code>for</code> 循环可以嵌套在其他 <code>for</code> 循环内，形成嵌套循环。嵌套循环在处理二维结构（例如二维列表）或需要遍历多个维度的情况下非常有用。以下是一个简单的例子：</p>
<pre><code class="language-python">for i in range(3):
    for j in range(2):
        print(f&quot;({i}, {j})&quot;)
</code></pre>
<p>这段代码会输出：</p>
<pre><code>(0, 0)
(0, 1)
(1, 0)
(1, 1)
(2, 0)
(2, 1)
</code></pre>
<h4 id="示例演示-10"><a class="header" href="#示例演示-10">示例演示</a></h4>
<p>利用 for 循环的嵌套，打印出乘法口诀表。</p>
<pre><code class="language-python">for i in range(1, 10):
    for j in range(1, i+1):
        print(f'{j}x{i}={i*j}', end=&quot; &quot;)
    print(&quot;&quot;)
</code></pre>
<h2 id="while-循环-2"><a class="header" href="#while-循环-2">while 循环</a></h2>
<p><code>while</code> 循环是 Python 中的一种迭代结构，用于重复执行一组语句，直到指定的条件不再满足。它提供了一种灵活的方式来处理需要多次执行的任务。</p>
<p><code>while</code> 循环的基本语法如下：</p>
<pre><code class="language-python">while 条件:
    # 循环体
    # 在每次迭代中，当条件为真时，执行循环体
</code></pre>
<p><code>条件</code> 是一个表达式，当这个表达式的值为真时，循环体将会被执行。当条件为假时，循环结束。</p>
<h3 id="示例演示-11"><a class="header" href="#示例演示-11">示例演示</a></h3>
<p>以下是一个简单的示例，演示了 <code>while</code> 循环的基本用法：</p>
<pre><code class="language-python">count = 0

while count &lt; 5:
    print(f&quot;Count: {count}&quot;)
    count += 1
</code></pre>
<p>在这个例子中，<code>count</code> 初始化为 0。<code>while count &lt; 5:</code> 表达式检查 <code>count</code> 是否小于 5，如果是真，则执行循环体。在每次循环中，打印 <code>count</code> 的值，并将 <code>count</code> 增加 1。当 <code>count</code> 达到 5 时，循环结束。</p>
<h3 id="循环中的-else-语句"><a class="header" href="#循环中的-else-语句">循环中的 else 语句</a></h3>
<p><code>while</code> 循环也支持 <code>else</code> 语句，它在循环条件变为假时执行，除非循环被中断。以下是一个使用 <code>else</code> 的示例：</p>
<pre><code class="language-python">count = 0

while count &lt; 5:
    print(f&quot;Count: {count}&quot;)
    count += 1
else:
    print(&quot;Loop completed.&quot;)
</code></pre>
<p>在这个例子中，当 <code>count</code> 不再小于 5 时，<code>else</code> 语句将被执行，输出 <code>Loop completed.</code>。</p>
<h3 id="无限循环"><a class="header" href="#无限循环">无限循环</a></h3>
<p>无限循环也叫死循环，在某些情况下，需要一直循环下去来保证程序不间断的运行下去，在 Python 中可以使用 <code>while True:</code> 或者 <code>while 1:</code>实现无限循环。</p>
<pre><code class="language-python">while True:
    # 无限循环
    print(&quot;I am looping.&quot;)
</code></pre>
<h2 id="循环控制"><a class="header" href="#循环控制">循环控制</a></h2>
<p>在 Python 编程语言中，<code>break</code> 和 <code>continue</code> 是两个用于控制循环执行的关键字。它们分别用于中断循环和跳过当前迭代，使程序更加灵活和高效。</p>
<ul>
<li><strong>break：</strong> 完全中断循环，跳出循环体。</li>
<li><strong>continue：</strong> 跳过当前迭代，继续下一次迭代。</li>
</ul>
<p>如果有循环嵌套，这两个关键字只在其所处的那一层循环发生作用，不会影响该层循环的外部和内部循环。</p>
<h3 id="break-关键字"><a class="header" href="#break-关键字">break 关键字</a></h3>
<p><code>break</code> 是一个用于中断循环的关键字。当 <code>break</code> 语句被执行时，循环会立即终止，程序将跳出循环体，继续执行循环之后的代码。</p>
<pre><code class="language-python">while 条件:
    # 循环体
    if 某个条件:
        break  # 中断循环
    # 循环体的其余部分
</code></pre>
<pre><code class="language-python">for 变量 in 可迭代对象:
    # 循环体
    if 某个条件:
        break  # 中断循环
    # 循环体的其余部分
</code></pre>
<p>让我们通过一个简单的示例来说明 <code>break</code> 的用法。假设我们要在一个列表中查找某个特定的元素：</p>
<blockquote>
<p>A博物馆由于展出的内容比较受欢迎，所以在参观高峰的展出期间采取限流的文案保证馆内不会过于拥挤。具体文案是，参观人员在馆外排队依次进入，管理人员每隔5分钟打开隔离带开放观众进入，同时会进行计数，当本次进入人员达到20人时，会关闭隔离带，其它观众需要等待下一轮开放。</p>
</blockquote>
<pre><code class="language-python">count = 0
while True:
    count = count + 1
    print(&quot;进入%d位观众。&quot; % count)
    if count == 20:
        break
else:
    print(&quot;停止进入&quot;)
</code></pre>
<p>上述代码的<code>else</code>部分不会执行，这是因为<code>break</code>是中断整个循环，<code>else</code>也属于循环的一部分。</p>
<pre><code>进入1位观众。
进入2位观众。
进入3位观众。
进入4位观众。
进入5位观众。
进入6位观众。
进入7位观众。
进入8位观众。
进入9位观众。
进入10位观众。
进入11位观众。
进入12位观众。
进入13位观众。
进入14位观众。
进入15位观众。
进入16位观众。
进入17位观众。
进入18位观众。
进入19位观众。
进入20位观众。
</code></pre>
<h3 id="continue-关键字"><a class="header" href="#continue-关键字">continue 关键字</a></h3>
<p><code>continue</code> 是一个用于跳过当前迭代的关键字。当 <code>continue</code> 语句被执行时，循环会跳过当前迭代的剩余部分，直接进入下一次迭代。</p>
<pre><code class="language-python">while 条件:
    # 循环体
    if 某个条件:
        continue  # 跳过当前迭代
    # 循环体的其余部分
</code></pre>
<pre><code class="language-python">for 变量 in 可迭代对象:
    # 循环体
    if 某个条件:
        continue  # 跳过当前迭代
    # 循环体的其余部分
</code></pre>
<blockquote>
<p>某个连队在训练过程中，为了加强战士执行命令的效率，进行一种特殊的训练方式，教官先说出一个1-9之间的数字，然后战士们开始报数，当报到与这个数有关的数字时，该名战士就不要报数，然后下一个战士从下一个数字继续报数。
假设一个连队有150人，请用程序模拟出这个连队的报数情况。
提示：与这个数有关的数字有两种，第一种为个位上的数字为这个数，第二种为这个数的倍数。</p>
</blockquote>
<pre><code class="language-python">print(&quot;请教官说出一个1-9之间任意数字&quot;)
n = int(input(&quot;数字为:&quot;))
print(&quot;开始报数&quot;)
for i in range(1, 151):
    if i % 10 == n  or i % n  == 0:
        continue
    print(i, end=' ')
</code></pre>
<h3 id="使用场景"><a class="header" href="#使用场景">使用场景</a></h3>
<ul>
<li><strong>跳过不满足条件的迭代：</strong> 在循环中，当某个条件不满足时，使用 <code>continue</code> 跳过当前迭代。</li>
<li><strong>处理特殊情况：</strong> 在处理数据时，遇到特殊情况可使用 <code>continue</code> 避免执行不必要的代码。</li>
</ul>
<p><code>break</code> 和 <code>continue</code> 是 Python 中控制循环执行的两个关键字。它们提供了在循环中灵活控制流程的手段，使得程序在面对不同情况时能够更加高效、清晰地执行。合理使用 <code>break</code> 和 <code>continue</code> 可以使代码更具可读性和可维护性。在编写循环时，根据具体需求选择使用 <code>break</code> 或 <code>continue</code>，能够更好地实现代码的逻辑。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="高级数据类型"><a class="header" href="#高级数据类型">高级数据类型</a></h1>
<p>在<a href="10.%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/../03.%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8F%98%E9%87%8F/%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8F%98%E9%87%8F.html">类型和变量</a>一章中，我们介绍了<code>Python</code>中的基本数据类型，除字符串之外，它们都是不能再被再被可视化分割的最小单元。而<code>Python</code>中同样也提供了高级数据类型，用以存储多个的数据到一个对象中，这些高级数据类型根据结构来分成下面几类：</p>
<h3 id="序列sequence"><a class="header" href="#序列sequence">序列sequence</a></h3>
<pre><code>- 字符串 str
- 列表 list
- 元组 tuple
- range
</code></pre>
<h3 id="集合set"><a class="header" href="#集合set">集合set</a></h3>
<pre><code>- 集合 set
</code></pre>
<h3 id="映射mapping"><a class="header" href="#映射mapping">映射mapping</a></h3>
<pre><code>- 字典 dict
</code></pre>
<h2 id="基本操作"><a class="header" href="#基本操作">基本操作</a></h2>
<p>高级数据类型的基本操作主要包括一系列对数据进行处理和管理的操作，这些操作通常涵盖了数据的增<code>insert</code>、删<code>delete</code>、改<code>update</code>、查<code>index/slice/key</code>，以及其内置方法的调用。</p>
<ul>
<li>创建：高级数据类型在使用之前需要先创建，可以使用声明变量的方式创建，也可以用推导式；</li>
<li>增：增加新的数据到一个高级数据类型中；</li>
<li>删：从高级数据类型中删除数据、或者删除整个高级数据类型；</li>
<li>改：修改高级数据类型其中一个数据的值</li>
<li>查：查找高级数据类型中的数据，主要有索引，切片和键值对查找；</li>
<li>内置方法调用：每种高级数据类型都内置了多个方法用于操作自身。</li>
<li><code>Python</code>中内置函数的调用。</li>
</ul>
<h2 id="基本数据类型-vs-高级数据类型"><a class="header" href="#基本数据类型-vs-高级数据类型">基本数据类型 vs 高级数据类型：</a></h2>
<h3 id="可变性"><a class="header" href="#可变性"><strong>可变性</strong></a></h3>
<h4 id="基本数据类型不可变"><a class="header" href="#基本数据类型不可变">基本数据类型（不可变）：</a></h4>
<ul>
<li>包括整数（int）、浮点数（float）、布尔值（bool）、字符串（str）、元组（tuple）等。</li>
<li>一旦创建，对象的值不能被修改。</li>
<li>操作不会改变原始对象，而是创建新的对象。</li>
</ul>
<pre><code class="language-python">&gt;&gt;&gt; x = 5  # 整数是不可变的
&gt;&gt;&gt; y = x  # 创建了一个新的变量 y，但是 x 和 y 都指向相同的对象
&gt;&gt;&gt; y += 2  # 修改 y，但是 x 不受影响
&gt;&gt;&gt; print(x, y) 
5 7
</code></pre>
<h4 id="高级数据类型可变"><a class="header" href="#高级数据类型可变">高级数据类型（可变）：</a></h4>
<ul>
<li>包括列表（list）、集合（set）、字典（dict）、自定义类实例等。</li>
<li>对象的值可以在原地被修改。</li>
<li>操作会影响原始对象。</li>
</ul>
<pre><code class="language-python">&gt;&gt;&gt; my_list = [1, 2, 3]  # 列表是可变的
&gt;&gt;&gt; other_list = my_list  # 创建了一个新的变量 other_list，但是两者指向同一个列表对象
&gt;&gt;&gt; other_list.append(4)  # 修改了原始列表
&gt;&gt;&gt; print(my_list, other_list) 
[1, 2, 3, 4] [1, 2, 3, 4]
</code></pre>
<h3 id="复制行为"><a class="header" href="#复制行为"><strong>复制行为</strong></a></h3>
<h4 id="基本数据类型"><a class="header" href="#基本数据类型">基本数据类型：</a></h4>
<ul>
<li>复制基本数据类型时，实际上是创建了一个新的对象，原始对象保持不变。</li>
</ul>
<pre><code class="language-python">&gt;&gt;&gt; x = 10
&gt;&gt;&gt; y = x  # 创建了一个新的变量 y，但是 x 和 y 都指向相同的对象
&gt;&gt;&gt; y += 5
&gt;&gt;&gt; print(x, y)  
10 15
</code></pre>
<h4 id="高级数据类型-1"><a class="header" href="#高级数据类型-1">高级数据类型：</a></h4>
<ul>
<li>复制可变对象时，创建了一个新的变量，但是两者仍然指向相同的对象。</li>
</ul>
<pre><code class="language-python">&gt;&gt;&gt; my_list = [1, 2, 3]
&gt;&gt;&gt; other_list = my_list  # 创建了一个新的变量 other_list，但是两者指向同一个列表对象
&gt;&gt;&gt; other_list.append(4)
&gt;&gt;&gt; print(my_list, other_list)  
[1, 2, 3, 4] [1, 2, 3, 4]
</code></pre>
<h3 id="性能和内存占用"><a class="header" href="#性能和内存占用"><strong>性能和内存占用</strong></a></h3>
<ul>
<li>基本数据类型通常更轻量，因为它们是不可变的，不需要考虑变化的可能性。</li>
<li>高级数据类型需要更多的内存和处理资源，特别是在进行频繁的修改、添加或删除元素时。</li>
</ul>
<h3 id="使用场景-1"><a class="header" href="#使用场景-1"><strong>使用场景</strong></a></h3>
<ul>
<li>基本数据类型适用于简单的数据表示和数值计算，以及需要保持数据不变性的情况。</li>
<li>高级数据类型适用于需要灵活性、可变性和复杂数据结构的情况，如列表、集合、字典等。</li>
</ul>
<p>选择基本数据类型还是高级数据类型取决于问题的要求，对性能和内存的需求，以及数据的特性。在实际编程中，这两者通常都有其独特的用途和优势。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="字符串"><a class="header" href="#字符串">字符串</a></h1>
<p>字符串或串<code>String</code>是由数字、字母、各种特殊字符组成的一串字符。一般记为 <code>s=&quot;a1a2···an&quot;(n&gt;=0)</code>。它是编程语言中表示文本的数据类型。在程序设计中，字符串为符号或数值的一个连续序列，如符号串（一串字符）或二进制数字串（一串二进制数字）。</p>
<p><code>Python</code>中的字符串是一种非常重要且灵活的数据类型，它用于表示文本信息，并且在<code>Python</code>编程中被广泛使用。字符串在<code>Python</code>中被视为不可变的序列，这意味着一旦创建了字符串，就不能再对其进行修改。</p>
<h3 id="字符串的基本特性"><a class="header" href="#字符串的基本特性">字符串的基本特性</a></h3>
<ul>
<li>
<p><strong>不可变性:</strong> 字符串一旦创建，就不能被修改。可以创建新的字符串来实现修改的效果。</p>
</li>
<li>
<p><strong>序列性:</strong> 字符串是一个由字符组成的序列，可以通过索引和切片来访问字符串中的字符或子串。</p>
</li>
<li>
<p><strong>Unicode支持:</strong> <code>Python</code>的字符串是<code>Unicode</code>字符串，支持多种语言的字符集，因此可以处理各种语言的文本。</p>
</li>
</ul>
<h3 id="字符串的编码"><a class="header" href="#字符串的编码">字符串的编码</a></h3>
<p>字符串的编码是将字符转换为字节序列的过程，Python 中常用的编码方式包括 ASCII、UTF-8、UTF-16 等。在 Python 中，字符串默认使用 Unicode 编码。</p>
<ul>
<li>
<p><strong><code>ASCII</code> 编码:</strong> 最早的字符编码方式，只能表示英文字母、数字和一些特殊字符，使用<code>7</code>位字节表示一个字符。</p>
</li>
<li>
<p><strong><code>UTF-8</code> 编码:</strong> <code>Unicode</code>的一种实现方式，是一种变长编码，能够表示全球范围内的字符集，并且节省存储空间。</p>
</li>
<li>
<p><strong><code>UTF-16</code> 编码:</strong> <code>Unicode</code>的另一种实现方式，使用<code>16</code>位字节表示一个字符，适用于需要大量使用非<code>ASCII</code>字符的情况。</p>
</li>
</ul>
<p>在<code>Python</code>中，你可以使用<code>encode()</code>方法将字符串编码为字节序列，使用<code>decode()</code>方法将字节序列解码为字符串。</p>
<h2 id="基本操作-1"><a class="header" href="#基本操作-1">基本操作</a></h2>
<h3 id="构造字符串"><a class="header" href="#构造字符串">构造字符串</a></h3>
<p>在Python中，以引号包围的内容均可认为是字符串：</p>
<pre><code class="language-python">&gt;&gt;&gt; s = &quot;jfdlasjlfewoi23u8ro23uokl&quot;
&gt;&gt;&gt; s1 = 'r32oodsalhf8oweohesalhfla'
&gt;&gt;&gt; s2 = '''abcdefg
hijklmn
'''
</code></pre>
<h3 id="索引和切片"><a class="header" href="#索引和切片">索引和切片</a></h3>
<h4 id="索引"><a class="header" href="#索引">索引</a></h4>
<p>可以把索引理解成每个字符在字符串中的位置，只是从前面索引时，索引值是从<code>0</code>开始，比如<code>a</code>在字符串<code>abcdefgh</code>中的索引值为0， 从后面索引时，索引值从<code>-1</code>开始，索引的操作符为<code>[]</code>。</p>
<p><img src="11.%E5%AD%97%E7%AC%A6%E4%B8%B2/./images/index.png" alt="index" /></p>
<pre><code class="language-python">&gt;&gt;&gt; s = 'abcdefgh'
&gt;&gt;&gt; s[0]
'a'
</code></pre>
<h4 id="切片"><a class="header" href="#切片">切片</a></h4>
<p>在<code>Python</code>中，切片<code>（slice）</code>是一种从序列（如列表、元组、字符串等）中获取子序列的方法。切片允许你通过指定起始索引、终止索引和步长来选择序列中的一部分元素，并将它们返回为一个新的序列。</p>
<p>切片的语法为</p>
<pre><code class="language-python">sequence[start:stop:step]
</code></pre>
<p>在执行切片时，<code>Python</code>遵循的是数学里区间的左闭右开原则，即<code>[start, stop)</code>, 也就是说<code>stop</code>索引位置的元素是取不到的。</p>
<ul>
<li><code>start</code>为切片的起始索引，即从哪个索引开始切片;</li>
<li><code>stop</code>为切片的终止索引，但是切不到这个索引位置，只到它之前结束;</li>
<li><code>step</code>为步长，即切片时间隔多少个元素，默认为<code>1</code>。</li>
</ul>
<p>正向切片时，<code>stop</code>的值要大于<code>start</code>的值，并且步长<code>step</code>要必须为正数，否则切片结果为一个空列表<code>[]</code>。</p>
<pre><code class="language-python">&gt;&gt;&gt; s = &quot;abcdefghijklmn&quot;
&gt;&gt;&gt; s[1:4] 
'bcd'
&gt;&gt;&gt; s[0:9:2]
'acegi'
</code></pre>
<p>反向切片时，<code>stop</code>的值要小于<code>start</code>的值，并且步长<code>step</code>要必须为负数，否则切片结果为一个空列表<code>[]</code>。</p>
<pre><code class="language-python">&gt;&gt;&gt; s = &quot;abcdefghijklmn&quot;
&gt;&gt;&gt; s[-3:-9:-1]
'lkjihg'
</code></pre>
<p><code>start</code>和<code>stop</code>也可以省略不写。</p>
<pre><code class="language-python">&gt;&gt;&gt; s = &quot;abcdefghijklmn&quot;
&gt;&gt;&gt; s[:8:]
'abcdefg'
&gt;&gt;&gt; s[8:]
'hijklmn'
&gt;&gt;&gt; s[::-1]
'nmlkjihgfedcba'
</code></pre>
<h3 id="成员运算"><a class="header" href="#成员运算">成员运算</a></h3>
<p>成员运算就是要判断某一个元素是否存在于一个数据结构中， 所用到的运算符为<code>in</code>和<code>not in</code>；成员运算返回的结果为<code>bool</code>型的数据，即<code>True</code>和<code>False</code>：</p>
<pre><code class="language-python">&gt;&gt;&gt; s = &quot;hello, world&quot;
&gt;&gt;&gt; 'h' in s
True
&gt;&gt;&gt; 'Hello' in s
False
&gt;&gt;&gt; 'a' not in s
True
</code></pre>
<p>由于成员运算返回的结果为<code>bool</code>数据，所以可以用在条件语句和循环语句中：</p>
<pre><code class="language-python">if __name__ == '__main__':
    s = &quot;abcdefg&quot;
    if 'a' in s:
        print(s)
</code></pre>
<p>或：</p>
<pre><code class="language-python">if __name__ == '__main__':
    s = 'abcdefg'
    sub = input(&quot;Please input a sub string:&quot;)
    while sub in s:
        sub = input(&quot;Please input a sub string:&quot;)
    s = s + sub
</code></pre>
<h3 id="删除字符串"><a class="header" href="#删除字符串">删除字符串</a></h3>
<p>Python中只能完全删除字符串。</p>
<pre><code class="language-python">&gt;&gt;&gt; del s
&gt;&gt;&gt; print(s)
Traceback (most recent call last):
  File &quot;&lt;pyshell#0&gt;&quot;, line 1, in &lt;module&gt;
    print(s)
NameError: name 's' is not defined
</code></pre>
<h3 id="格式化"><a class="header" href="#格式化">格式化</a></h3>
<ul>
<li><strong><code>%</code>格式化</strong>，使用<code>%</code>运算符和格式化字符来格式化字符串。</li>
</ul>
<pre><code class="language-python">&gt;&gt;&gt; name = &quot;Alice&quot;
&gt;&gt;&gt;&gt; age = 30
&gt;&gt;&gt; result = &quot;My name is %s and I am %d years old.&quot; % (name, age)
My name is Alice and I am 30 years old.
</code></pre>
<ul>
<li><strong><code>str.format()</code></strong>,是用来格式化字符串里的内容的方法。</li>
</ul>
<pre><code class="language-python">&gt;&gt;&gt; &quot;My name is {}, I am {}.&quot;.format(&quot;Chris&quot;,36)
'My name is Chris, I am 36.'
&gt;&gt;&gt; &quot;I have {0} pens, all are {1}&quot;.format(10, &quot;black&quot;)
'I have 10 pens, all are black'
&gt;&gt;&gt; &quot;I have {1} pens, all are {0}&quot;.format(10, &quot;black&quot;)
'I have black pens, all are 10'
&gt;&gt;&gt; &quot;I am living in {city}, but I was born in {addr}&quot;.format(&quot;Shanghai&quot;, &quot;Jiangsu&quot;)
Traceback (most recent call last):
  File &quot;&lt;pyshell#50&gt;&quot;, line 1, in &lt;module&gt;
    &quot;I am living in {city}, but I was born in {addr}&quot;.format(&quot;Shanghai&quot;, &quot;Jiangsu&quot;)
KeyError: 'city'
&gt;&gt;&gt; &quot;I am living in {city}, but I was born in {addr}&quot;.format(city=&quot;Shanghai&quot;, addr=&quot;Jiangsu&quot;)
'I am living in Shanghai, but I was born in Jiangsu'
</code></pre>
<ul>
<li><strong><code>f-string</code></strong>, 使用<code>f-string</code>来格式化字符串。</li>
</ul>
<pre><code class="language-python">&gt;&gt;&gt; name = &quot;Charlie&quot;
&gt;&gt;&gt; age = 20
&gt;&gt;&gt; result = f&quot;My name is {name} and I am {age} years old.&quot;
My name is Charlie and I am 20 years old.
</code></pre>
<h3 id="遍历字符串"><a class="header" href="#遍历字符串">遍历字符串</a></h3>
<p>用<code>for</code>循环可以对那些可迭代的对象进行遍历，主要有两种方式：</p>
<h4 id="索引遍历"><a class="header" href="#索引遍历">索引遍历</a></h4>
<pre><code class="language-Python">s = &quot;abcdefg&quot;

for j in range(len(s)):
    print(s[j])

for i in s:
    print(i)
</code></pre>
<p>这种方式通过索引来访问字符串中的元素。<code>j</code> 在每次循环中都被赋值为字符串的下一个索引，然后使用这个索引来从字符串中获取元素。</p>
<h4 id="直接遍历"><a class="header" href="#直接遍历">直接遍历</a></h4>
<pre><code class="language-Python">s = &quot;ABCDEFG&quot;

for i in s:
    print(i)
</code></pre>
<p>这种方式直接遍历字符串中的每一个元素。<code>i</code> 在每次循环中都会被赋值为字符串 <code>s</code> 的下一个元素。这种方式效率比索引遍历要高。</p>
<h2 id="函数"><a class="header" href="#函数">函数</a></h2>
<p>在学习函数之前，首先要对函数有一个初步的认识。首先要知道的是<code>Python</code>中函数都是独立的代码块，可以重复调用，用来执行特定的任务或实现特定的功能。我们可以将函数比作一口做饭的大锅<code>cooker</code>，它可以用来炖母鸡<code>hen</code>，需要通过函数名和参数列表来调用：</p>
<pre><code class="language-python">&gt;&gt;&gt; cooker(hen)
&quot;Chicken Soup&quot;
</code></pre>
<p>以下为列表中的三个函数为字符串中经常会使用的函数。</p>
<table><thead><tr><th align="left">名字</th><th align="left">说明</th></tr></thead><tbody>
<tr><td align="left"><code>len</code></td><td align="left">有返回值，返回字符串的长度</td></tr>
<tr><td align="left"><code>min</code></td><td align="left">有返回值，返回字符串中最小的字符</td></tr>
<tr><td align="left"><code>max</code></td><td align="left">有返回值，返回字符串中最大的字符</td></tr>
</tbody></table>
<h3 id="lenstring"><a class="header" href="#lenstring">len(string)</a></h3>
<p><code>len</code>返回字符串<code>string</code>的长度，即元素的个数。</p>
<pre><code class="language-python">&gt;&gt;&gt; len(&quot;abcdefg&quot;)
7
</code></pre>
<h3 id="maxstringminstring"><a class="header" href="#maxstringminstring">max(string)/min(string)</a></h3>
<p><code>max</code>和<code>min</code>分别返回<code>string</code>的中最大和最小的元素，元素的大小以字符在字符集中的位置来判定。</p>
<pre><code class="language-python">&gt;&gt;&gt; max(&quot;ABCDEFG&quot;)
'G'
&gt;&gt;&gt; min(&quot;abCDEFG&quot;)
'C'
</code></pre>
<h2 id="方法"><a class="header" href="#方法">方法</a></h2>
<p>在<code>Python</code>中，方法是要关联在对象中的，需要在一个类的内部定义，去操作对象的属性或者执行对象的特定的功能，所谓的对象可以理解成一个实际的事物，如一只母鸡（母鸡属于鸡这一类）。在这一例子中，母鸡有很多的方法，比如下蛋。</p>
<p>在调用方法时，需要通过对象名和方法名进行，并要传入方法的参数:</p>
<pre><code class="language-python">&gt;&gt;&gt; hen = Chicken()
&gt;&gt;&gt; hen.dropegg(2)
'The hen dropped 2 eggs.'
</code></pre>
<p>对于<code>Python</code>中所有的内置数据类型，我们在创建时，它们都自动被标识成它所属类型的实例对象：</p>
<ul>
<li><code>1</code>是<code>int</code>整型类型的实例对象</li>
<li><code>'hello'</code>是<code>str</code>字符串类型的实例对象</li>
<li><code>[1,2,3]</code>是<code>list</code>列表类型的实例对象</li>
<li>......</li>
</ul>
<p>将这些实际的值赋值给一个变量之后，上述说法也成立。所以我们不需要通过<code>hen = Chicken()</code>这样的方式创建这些类型。这个内容将会在学习面向对象时详细介绍。</p>
<p>在调用这些实例的方法时，可以直接通过值来调用，也可以在赋值给变量后，通过变量来调用：</p>
<pre><code class="language-python">&gt;&gt;&gt; &quot;hello&quot;.upper()
'HELLO'
&gt;&gt;&gt; s = &quot;WORLD&quot;
&gt;&gt;&gt; s.lower()
'world'
</code></pre>
<p>下面我们将对字符串中常用的方法进行学习。</p>
<h3 id="查找与替换"><a class="header" href="#查找与替换">查找与替换</a></h3>
<table><thead><tr><th align="left">方法</th><th align="left">说明</th></tr></thead><tbody>
<tr><td align="left"><code>count</code></td><td align="left">统计子串在字符串中出现的次数</td></tr>
<tr><td align="left"><code>find</code>、<code>index</code></td><td align="left">查找子串在字符串中的位置</td></tr>
<tr><td align="left"><code>replace</code></td><td align="left">替换字符串中的子串</td></tr>
</tbody></table>
<h4 id="countsub-start-end"><a class="header" href="#countsub-start-end">count(sub[, start[, end]])</a></h4>
<p><code>count</code>函数可以查找在<code>[start:end]</code>切片之间，子串<code>sub</code>出现的次数，如果未指定范围则在整个字符串范围内查找。</p>
<pre><code class="language-python">&gt;&gt;&gt; s = &quot;My name is Chris, I am 6 years old, I will go to Primary School this September.&quot;
&gt;&gt;&gt; s.count('I')
2
</code></pre>
<h4 id="findsub-start-end--indexsub-start-end"><a class="header" href="#findsub-start-end--indexsub-start-end">find(sub[, start[, end]]) / index(sub[, start[, end]])</a></h4>
<ul>
<li><code>find</code>返回子字符串<code>sub</code>在 <code>[start:end]</code> 切片内被找到的最小索引。 如果<code>sub</code>未被找到则返回<code>-1</code>。</li>
<li><code>index</code>返回子字符串<code>sub</code>在 <code>[start:end]</code> 切片内被找到的最小索引。 如果<code>sub</code>未被找到则会报错<code>ValueError</code>。</li>
</ul>
<pre><code class="language-python">&gt;&gt;&gt; s = &quot;to be or not to be, that is a question.&quot;
&gt;&gt;&gt; s.find(&quot;to&quot;)
0
&gt;&gt;&gt; s.index(&quot;to&quot;, 3, 20)
13
&gt;&gt;&gt; s.find(&quot;I&quot;)
-1
&gt;&gt;&gt; s.index(&quot;I&quot;)
Traceback (most recent call last):
  File &quot;&lt;pyshell#4&gt;&quot;, line 1, in &lt;module&gt;
    s.index(&quot;I&quot;)
ValueError: substring not found
</code></pre>
<h4 id="replaceold-new-count"><a class="header" href="#replaceold-new-count">replace(old, new[, count])</a></h4>
<p><code>replace</code>返回字符串的副本，其中出现的所有子字符串<code>old</code>都将被替换为<code>new</code>。 如果给出了可选参数<code>count</code>，则只替换前<code>count</code>次出现；并不会改变原来的字符串。</p>
<pre><code class="language-python">&gt;&gt;&gt; s = &quot;My name is Chris.&quot;
&gt;&gt;&gt; s.replace(&quot;Chris&quot;, &quot;Eris&quot;)
'My name is Eris.'
&gt;&gt;&gt; print(s)
'My name is Chris.'
</code></pre>
<h3 id="分割和连接"><a class="header" href="#分割和连接">分割和连接</a></h3>
<table><thead><tr><th align="left">方法</th><th align="left">说明</th></tr></thead><tbody>
<tr><td align="left"><code>split</code></td><td align="left">将字符串分割成子串列表</td></tr>
<tr><td align="left"><code>join</code></td><td align="left">连接字符串列表成为一个字符串</td></tr>
</tbody></table>
<h4 id="splitsep"><a class="header" href="#splitsep">split(sep)</a></h4>
<p><code>split</code>使用<code>sep</code>作为分隔字符串，返回一个由字符串内单词组成的列表。</p>
<pre><code class="language-python">&gt;&gt;&gt; '1,2,3'.split(',')
['1', '2', '3']
&gt;&gt;&gt; '1,2,3'.split(',', maxsplit=1)
['1', '2,3']
&gt;&gt;&gt; '1,2,,3,'.split(',')
['1', '2', '', '3', '']
&gt;&gt;&gt; '1&lt;&gt;2&lt;&gt;3'.split('&lt;&gt;') 
['1', '2', '3']
</code></pre>
<h4 id="joiniterable"><a class="header" href="#joiniterable">join(iterable)</a></h4>
<p><code>join</code>返回一个由<code>iterable</code>中的字符串拼接而成的字符串，<code>iterable</code>可以为任何高级数据类型，如列表、元组等。</p>
<pre><code class="language-python">&gt;&gt;&gt; '-'.join(['a', 'b', 'c'])
'a-b-c'
&gt;&gt;&gt; ','.join(&quot;abcdefg&quot;)
'a,b,c,d,e,f,g'
</code></pre>
<h3 id="大小写转换"><a class="header" href="#大小写转换">大小写转换</a></h3>
<table><thead><tr><th align="left">方法</th><th align="left">说明</th></tr></thead><tbody>
<tr><td align="left"><code>lower</code></td><td align="left">将字符串中的字符全部转换成小写</td></tr>
<tr><td align="left"><code>upper</code></td><td align="left">将字符串中的字符全部转换成大写</td></tr>
</tbody></table>
<pre><code class="language-python">&gt;&gt;&gt; s = 'hello world'
&gt;&gt;&gt; print(s.upper())  
'HELLO WORLD'
&gt;&gt;&gt; print(s.lower())  
'hello world'
</code></pre>
<h3 id="去除左右的子串"><a class="header" href="#去除左右的子串">去除左右的子串</a></h3>
<table><thead><tr><th align="left">方法</th><th align="left">说明</th></tr></thead><tbody>
<tr><td align="left"><code>strip</code></td><td align="left">去除字符串两端的子串</td></tr>
<tr><td align="left"><code>lstrip</code>、<code>rstrip</code></td><td align="left">去除字符串左侧或右侧的子串</td></tr>
</tbody></table>
<h4 id="stripchars"><a class="header" href="#stripchars">strip(chars)</a></h4>
<p><code>strip</code>将去除字符串中左右两端的所有的子串，这个子串为所有由<code>chars</code>中指定字符的组合，并返回去除后字符串的副本。如果未指定<code>sub</code>，则默认去除左右两端的空格；不会改变原来的字符串值。</p>
<pre><code class="language-python">&gt;&gt;&gt; &quot;   good    &quot;.strip()
'good'
&gt;&gt;&gt; website = 'www.google.com'
&gt;&gt;&gt; website.strip('cowm.')
'google'
&gt;&gt;&gt; print(website)
www.google.com
&gt;&gt;&gt; comment_string = '#....... Section 3.2.1 Issue #32 .......'
&gt;&gt;&gt; comment_string.strip('.#! ')
'Section 3.2.1 Issue #32'
</code></pre>
<h3 id="其他常用方法"><a class="header" href="#其他常用方法">其他常用方法</a></h3>
<table><thead><tr><th align="left">方法</th><th align="left">说明</th></tr></thead><tbody>
<tr><td align="left"><code>startswith</code></td><td align="left">判断字符串是否以指定前缀开始</td></tr>
<tr><td align="left"><code>endswith</code></td><td align="left">判断字符串是否以指定后缀结束</td></tr>
<tr><td align="left"><code>isalpha</code></td><td align="left">判断字符串是否只包含字母</td></tr>
<tr><td align="left"><code>isdigit</code></td><td align="left">判断字符串是否只包含数字</td></tr>
<tr><td align="left"><code>isalnum</code></td><td align="left">判断字符串是否只包含字母或数字</td></tr>
<tr><td align="left"><code>isspace</code></td><td align="left">判断字符串是否只包含空白字符</td></tr>
</tbody></table>
<pre><code class="language-python">&gt;&gt;&gt; s = 'hello world'
&gt;&gt;&gt; print(s.startswith('hello'))  # 输出: True
&gt;&gt;&gt; print(s.endswith('world'))  # 输出: True
&gt;&gt;&gt; print(s.isalpha())  # 输出: False
&gt;&gt;&gt; print(s.isdigit())  # 输出: False
&gt;&gt;&gt; print(s.isalnum())  # 输出: False
&gt;&gt;&gt; print(s.isspace())  # 输出: False
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="列表-list"><a class="header" href="#列表-list">列表 List</a></h1>
<p><code>Python</code>中的列表<code>List</code>是一种非常重要和常用的数据结构，它允许我们存储和操作多个元素。在<code>Python</code>中，列表是一种有序的序列，可以包含任意数量的元素，并且可以动态地改变大小。列表是<code>Python</code>中最灵活、最常用的数据类型之一，几乎在每个<code>Python</code>程序中都会被广泛应用。</p>
<h2 id="基本操作-2"><a class="header" href="#基本操作-2">基本操作</a></h2>
<h3 id="创建列表"><a class="header" href="#创建列表">创建列表</a></h3>
<p>在<code>Python</code>中，可以通过简单的方括号<code>[]</code>来创建一个列表，并在其中放入多个元素，元素之间用逗号<code>,</code>分隔。例如：</p>
<pre><code class="language-python">&gt;&gt;&gt; my_list = [1, 2, 3, 4, 5]
</code></pre>
<p>上述代码创建了一个名为<code>my_list</code>的列表，其中包含了整数<code>1</code>到<code>5</code>。列表中的元素可以是任意类型的对象，也可以是不同类型的对象的组合，甚至可以是另一个列表。例如：</p>
<pre><code class="language-python">&gt;&gt;&gt; mixed_list = [1, 'apple', True, [5, 6, 7]]
</code></pre>
<p>这个列表中包含了一个整数、一个字符串、一个布尔值和一个内嵌列表。<code>Python</code>的列表是可以嵌套的，也就是说一个列表可以包含另一个列表作为其元素。</p>
<h3 id="索引-1"><a class="header" href="#索引-1">索引</a></h3>
<p>与字符串一样，列表也可以从正反两个方向来索引</p>
<p>比如：</p>
<pre><code class="language-Python">lst = ['red', 'green', 'blue', 'yellow', 'white', 'black']
</code></pre>
<p>正向索引：
<img src="12.%E5%88%97%E8%A1%A8/./images/positive-indexes-1.png" alt="positive-index" /></p>
<p>反向索引:
<img src="12.%E5%88%97%E8%A1%A8/./images/negative-indexes.png" alt="negative-index" /></p>
<pre><code class="language-python">&gt;&gt;&gt; print(lst[0])
red
&gt;&gt;&gt; print(lst[-2])
white
</code></pre>
<p>同样列表也不能越界访问其中的元素：</p>
<pre><code class="language-python">&gt;&gt;&gt; print(lst[10])
Traceback (most recent call last):
  File &quot;&lt;pyshell#3&gt;&quot;, line 1, in &lt;module&gt;
    print(lst[10])
IndexError: list index out of range
</code></pre>
<h3 id="切片-1"><a class="header" href="#切片-1">切片</a></h3>
<p>与字符串一样，列表也可以进行切片，所用的运算符也是<code>[]</code>, 它的语法与字符串类似：</p>
<pre><code class="language-python">list_name[start:stop:step]

```python
&gt;&gt;&gt; numlst = [1,2,3,4,5,6,7,8,9,10]
&gt;&gt;&gt; numlst[1:4] 
[2,3,4]
&gt;&gt;&gt; numlst[6:] #切片从索引6开始，切到最后
[7,8,9,10]
&gt;&gt;&gt; numlst[::2] 
[1,3,5,7,9]
</code></pre>
<p><strong>列表的切片结果还是列表</strong></p>
<p>通常情况下，切片时，<code>stop</code>的值要大于<code>start</code>的值，否则切片结果为一个空列表<code>[]</code>。
但也有例外，如果设置了步长<code>step</code>为负数，那么<code>stop</code>的值一定要小于<code>start</code>的值，如：</p>
<pre><code class="language-python">&gt;&gt;&gt; numlst[5:2:-1]
[6, 5, 4]
</code></pre>
<h4 id="成员运算-1"><a class="header" href="#成员运算-1">成员运算</a></h4>
<p>成员运算可以用在<code>Python</code>中所有的数据结构中，语法一致：</p>
<pre><code class="language-python">&gt;&gt;&gt; lst = [1, 2, 3, 4, 5]
&gt;&gt;&gt; 1 not in lst
False
</code></pre>
<h3 id="修改列表"><a class="header" href="#修改列表">修改列表</a></h3>
<p>可以通过索引和切片来修改列表的元素值：</p>
<pre><code class="language-python">&gt;&gt;&gt; numlst = [1,2,3,4,5,6,7,8,9,10]
&gt;&gt;&gt; numlst[0] = 100
&gt;&gt;&gt; print(numlst)
[100,2,3,4,5,6,7,8,9,10]
&gt;&gt;&gt; numlst[1:4] = ['a','b']
&gt;&gt;&gt; print(numlst)
[100,'a','b',5,6,7,8,9,10]
</code></pre>
<p>这里提到的修改只是修改这个列表里的内容，不会改变列表的对象。</p>
<h3 id="删除列表里的值"><a class="header" href="#删除列表里的值">删除列表里的值</a></h3>
<p>与字符串不同的是，我们可以调用<code>del</code>关键字来删除列表里的元素，或者一段切片。</p>
<pre><code class="language-python">&gt;&gt;&gt; numlst = [1,2,3,4,5,6,7,8,9,10]
&gt;&gt;&gt; del numlst[0]
&gt;&gt;&gt; print(numlst)
[2,3,4,5,6,7,8,9,10]
&gt;&gt;&gt; del numlst[1:4]
&gt;&gt;&gt; print(numlst)
[1,5,6,7,8,9,10]
&gt;&gt;&gt; del numlst #删除整个列表
</code></pre>
<h3 id="列表的加法运算"><a class="header" href="#列表的加法运算">列表的加法运算</a></h3>
<p>列表的加法运算只能发生在两个列表之间，不能与其它类型进行加法运算。</p>
<pre><code class="language-python">&gt;&gt;&gt; lst1 = [1,2,3]
&gt;&gt;&gt; lst2 = [4,5,6]
&gt;&gt;&gt; print(lst1 + lst2)
[1,2,3,4,5,6]
&gt;&gt;&gt; lst3 = lst1 + lst2
</code></pre>
<h3 id="列表的乘法运算"><a class="header" href="#列表的乘法运算">列表的乘法运算</a></h3>
<p>列表的加法运算只能发生在列表和整型之间，不能与其它类型进行乘法运算。</p>
<pre><code class="language-python">&gt;&gt;&gt; lst1 = [1,2,3]
&gt;&gt;&gt; print(lst1 * 2)
[1,2,3,1,2,3]
&gt;&gt;&gt; lst3 = lst1 * 2
</code></pre>
<h2 id="遍历列表"><a class="header" href="#遍历列表">遍历列表</a></h2>
<p>用<code>for</code>循环可以对那些可迭代的对象进行遍历，主要有两种方式：</p>
<h3 id="索引遍历-1"><a class="header" href="#索引遍历-1">索引遍历</a></h3>
<pre><code class="language-Python">lst = [1,2,3,4,5,6,7,8,9,10]

for j in range(len(lst)):
    print(lst[j])
</code></pre>
<p>这种方式通过索引来访问列表中的元素。<code>j</code> 在每次循环中都被赋值为列表的下一个索引，然后使用这个索引来从列表中获取元素。这种方式在处理简单元素（如整数或字符串）的列表时，由于需要额外的索引查找，可能会比第一种方式稍慢一些。</p>
<h3 id="直接遍历-1"><a class="header" href="#直接遍历-1">直接遍历</a></h3>
<pre><code class="language-Python">lst = [1,2,3,4,5,6,7,8,9,10]

for i in lst:
    print(i)
</code></pre>
<p>这种方式直接遍历列表中的每一个元素。<code>i</code> 在每次循环中都会被赋值为列表 <code>lst</code> 的下一个元素。这种方式更简洁，并且当列表的元素是复杂对象（如字典或自定义类的实例）时，效率更高。</p>
<h2 id="函数-1"><a class="header" href="#函数-1">函数</a></h2>
<table><thead><tr><th align="left">名字</th><th align="left">说明</th></tr></thead><tbody>
<tr><td align="left"><code>len</code></td><td align="left">有返回值，返回列表的长度</td></tr>
<tr><td align="left"><code>min</code></td><td align="left">有返回值，返回列表中最小的字符</td></tr>
<tr><td align="left"><code>max</code></td><td align="left">有返回值，返回列表中最大的字符</td></tr>
</tbody></table>
<h2 id="方法-1"><a class="header" href="#方法-1">方法</a></h2>
<h3 id="内容查找"><a class="header" href="#内容查找">内容查找</a></h3>
<table><thead><tr><th align="left">方法</th><th align="left">说明</th></tr></thead><tbody>
<tr><td align="left"><code>count</code></td><td align="left">统计在列表中某个元素出现的次数</td></tr>
<tr><td align="left"><code>index</code></td><td align="left">查找在列表中某个元素的位置</td></tr>
</tbody></table>
<h4 id="countvalue"><a class="header" href="#countvalue">count(value)</a></h4>
<p><code>count</code> 返回在列表中有几个<code>value</code></p>
<pre><code class="language-python">&gt;&gt;&gt; lst = [2,3,4,65,1,34,5,2,5,7,10]
&gt;&gt;&gt; lst.count(5)
2
</code></pre>
<h4 id="indexvalue-start0-stop"><a class="header" href="#indexvalue-start0-stop">index(value, start=0, stop)</a></h4>
<p>列表的<code>index(value,start, stop)</code>方法有三个参数，其中后面两个是可以省略的。
其作用为返回<code>value</code>在整个列表或给定范围内第一次出现的索引，如果不存在则报错。</p>
<pre><code class="language-python">&gt;&gt;&gt; lst = [1, 2, 3, 4, 5, 'a', 'b', 'c']
&gt;&gt;&gt; lst.index(2)
1
&gt;&gt;&gt; lst.index(2,1,5)
1
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; lst.index(2,2,5)
Traceback (most recent call last):
  File &quot;&lt;pyshell#6&gt;&quot;, line 1, in &lt;module&gt;
    lst.index(2,2,5)
ValueError: 2 is not in list
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; lst.index('a',2,5)
Traceback (most recent call last):
  File &quot;&lt;pyshell#7&gt;&quot;, line 1, in &lt;module&gt;
    lst.index('a',2,5)
ValueError: 'a' is not in list
&gt;&gt;&gt; lst.index(5,2,5)
4
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; lst.index(2,2)
Traceback (most recent call last):
  File &quot;&lt;pyshell#9&gt;&quot;, line 1, in &lt;module&gt;
    lst.index(2,2)
ValueError: 2 is not in list
&gt;&gt;&gt; lst.index(2,1)
1
</code></pre>
<h3 id="扩展新的元素"><a class="header" href="#扩展新的元素">扩展新的元素</a></h3>
<table><thead><tr><th align="left">方法</th><th align="left">说明</th></tr></thead><tbody>
<tr><td align="left"><code>append</code></td><td align="left">将一个新的元素插入在列表的末尾</td></tr>
<tr><td align="left"><code>extend</code></td><td align="left">将一个可迭代对象中的元素逐个插入到列表的末尾</td></tr>
<tr><td align="left"><code>insert</code></td><td align="left">将一个元素插入到列表的指定位置</td></tr>
</tbody></table>
<h4 id="appendobject-与-extenditerable"><a class="header" href="#appendobject-与-extenditerable">append(object) 与 extend(iterable)</a></h4>
<p><code>append</code>，这个方法无返回值，其作用为将<code>object</code>做为一个元素，插入到列表的最后一位。</p>
<pre><code class="language-python">&gt;&gt;&gt; lst = [1,2,3,4,5]
&gt;&gt;&gt; lst.append('a')
&gt;&gt;&gt; print(lst)
[1,2,3,4,5,'a']
&gt;&gt;&gt; lst.append([7,8,9])
&gt;&gt;&gt; print(lst)
[1,2,3,4,5,'a',[7,8,9]]
</code></pre>
<p><code>extend</code>，这个方法也无返回值，要求输入的参数必须为一个序列，它的作用为将<code>iterable</code>中的所有元素，都单独作为一个元素按顺序插入到列表的后面。</p>
<pre><code class="language-python">&gt;&gt;&gt; lst = [1,2,3,4,5]
&gt;&gt;&gt; lst.extend('abc')
&gt;&gt;&gt; print(lst)
[1,2,3,4,5,'a','b','c']
&gt;&gt;&gt; lst.extend(1)
Traceback (most recent call last):
  File &quot;&lt;pyshell#1&gt;&quot;, line 1, in &lt;module&gt;
    lst.extend(1)
TypeError: 'int' object is not iterable
</code></pre>
<h4 id="insertindex-object"><a class="header" href="#insertindex-object">insert(index, object)</a></h4>
<p><code>insert</code>无返回值，它会将值<code>value</code>插入到列表的索引位置<code>index</code>上。</p>
<pre><code class="language-python">&gt;&gt;&gt; lst.insert(2,6)
&gt;&gt;&gt; lst
[1, 2, 6, 3, 4, 5, 'a', 'b', 'c']
&gt;&gt;&gt; lst.insert(9,7)
&gt;&gt;&gt; lst
[1, 2, 6, 3, 4, 5, 'a', 'b', 'c', 7]
&gt;&gt;&gt; lst.insert(100, 8)
&gt;&gt;&gt; lst
[1, 2, 6, 3, 4, 5, 'a', 'b', 'c', 7, 8]
</code></pre>
<h3 id="删除列表的元素"><a class="header" href="#删除列表的元素">删除列表的元素</a></h3>
<table><thead><tr><th align="left">方法</th><th align="left">说明</th></tr></thead><tbody>
<tr><td align="left"><code>pop</code></td><td align="left">删除列表中指定索引位置的元素</td></tr>
<tr><td align="left"><code>remove</code></td><td align="left">删除列表中第一次出现值为指定内容的元素</td></tr>
<tr><td align="left"><code>clear</code></td><td align="left">清空整个列表</td></tr>
</tbody></table>
<h4 id="popindex-1"><a class="header" href="#popindex-1">pop(index=-1)</a></h4>
<p><code>pop(index)</code>，如果给定<code>index</code>一个索引值，则移除列表中这个索引下的元素，如未给定则移除最后一个元素，最后将这个被移除的元素返回。</p>
<pre><code class="language-python">&gt;&gt;&gt; lst.pop()
8
&gt;&gt;&gt; lst
[1, 2, 6, 3, 4, 5, 'a', 'b', 'c', 7]
&gt;&gt;&gt; lst.pop(2)
6
&gt;&gt;&gt; lst
[1, 2, 3, 4, 5, 'a', 'b', 'c', 7]
</code></pre>
<h4 id="removevalue"><a class="header" href="#removevalue">remove(value)</a></h4>
<p><code>remove</code>无返回值，其作用为移除掉第一个值为<code>value</code>的元素。</p>
<pre><code class="language-python">&gt;&gt;&gt; lst = [1,2,3,4,5,2,7]
&gt;&gt;&gt; lst.remove(2)
&gt;&gt;&gt; print(lst)
[1,3,4,5,2,7]
</code></pre>
<h4 id="clear"><a class="header" href="#clear">clear()</a></h4>
<p><code>clear</code>清空列表，将其变成一个空列表<code>[]</code></p>
<pre><code class="language-python">&gt;&gt;&gt; lst = [1,2,3,4,5]
&gt;&gt;&gt; lst.clear()
&gt;&gt;&gt; print(lst)
[]
</code></pre>
<h3 id="改变元素的排列"><a class="header" href="#改变元素的排列">改变元素的排列</a></h3>
<table><thead><tr><th align="left">方法</th><th align="left">说明</th></tr></thead><tbody>
<tr><td align="left"><code>sort</code></td><td align="left">将列表的元素按升序或降序排列</td></tr>
<tr><td align="left"><code>reverse</code></td><td align="left">将列表的元素反序，但是并使列表元素有序</td></tr>
</tbody></table>
<h4 id="sortreversefalse"><a class="header" href="#sortreversefalse">sort(reverse=False)</a></h4>
<p><code>sort</code>对原列表的元素进行排序，将列表生成一个新的有序的列表。 参数<code>reverse</code>被传入的值为<code>True</code>，则倒序排列；否则正序排列。</p>
<pre><code class="language-python">&gt;&gt;&gt; lst = [5,7,2,3,6,10]
&gt;&gt;&gt; lst.sort()
&gt;&gt;&gt; print(lst)
[2,3,5,6,7,10]
&gt;&gt;&gt; lst = [5,7,2,3,6,10]
&gt;&gt;&gt; lst.sort(reverse=True)
&gt;&gt;&gt; print(lst)
[10,7,6,5,3,2]
</code></pre>
<h4 id="reverse"><a class="header" href="#reverse">reverse()</a></h4>
<p><code>reverse</code>将列表中元素按索引的位置反序排列。</p>
<pre><code class="language-python">&gt;&gt;&gt; lst = [5,7,2,3,6,10]
&gt;&gt;&gt; lst.reverse()
&gt;&gt;&gt; print(lst)
[10, 6, 3, 2, 7, 5]
</code></pre>
<h3 id="复制列表"><a class="header" href="#复制列表">复制列表</a></h3>
<table><thead><tr><th align="left">方法</th><th align="left">说明</th></tr></thead><tbody>
<tr><td align="left"><code>copy</code></td><td align="left">将列表进行浅复制并返回</td></tr>
</tbody></table>
<h4 id="copy"><a class="header" href="#copy">copy()</a></h4>
<p><code>copy</code>浅复制列表并返回。</p>
<pre><code class="language-python">&gt;&gt;&gt; lst = [1,2,3,4,5]
&gt;&gt;&gt; new_lst = lst.copy()
&gt;&gt;&gt; print(new_lst)
[1, 2, 3, 4, 5]
</code></pre>
<p>在这里简单区分一下<code>Python</code>中的有一种复制方式：</p>
<ul>
<li><strong>引用赋值:</strong> 将一个对象的引用赋给另一个变量，不复制对象的任何内容。这也意味着，这两个变量指向同一个对象。</li>
</ul>
<p><img src="12.%E5%88%97%E8%A1%A8/images/reference.png" alt="reference" /></p>
<ul>
<li><strong>浅复制:</strong> 创建一个新的对象，并将原始对象中的元素的引用复制到新对象中。如果原始对象中的元素是不可变的，那么浅复制和引用赋值的效果是一样的，因为不可变对象的引用和值是一样的。但如果原始对象中包含可变对象（例如列表中嵌套列表），那么浅复制只会复制最外层的元素的引用，内部元素仍然共享。</li>
</ul>
<p><img src="12.%E5%88%97%E8%A1%A8/images/shadowcopy.png" alt="shadowcopy" /></p>
<ul>
<li><strong>深复制:</strong> 创建一个全新的对象，同时递归地复制原始对象中的所有元素及其子元素，这样就完全脱离了原始对象。深复制会创建一个独立的对象，不论原始对象中的元素是不可变还是可变，它们都不会共享内存。</li>
</ul>
<p><img src="12.%E5%88%97%E8%A1%A8/images/deepcopy.png" alt="deepcopy" /></p>
<p>根据上面的介绍，我们可以进行如下的测试：</p>
<pre><code class="language-python">from copy import deepcopy # 导入copy模块中的深复制函数

if __name__ == '__main__':
    
    seed = [1,2,3,4,5,[6,7,8,9]]
    
    lst1 = seed
    lst2 = seed.copy()
    lst3 = deepcopy(seed)
    
    seed.append(10)
    print('lst1:', lst1)
    print('lst2:', lst2)
    print('lst3:', lst2)
    
    &quot;&quot;&quot;
    上面print 语句输出的内容为：
    list1: [1, 2, 3, 4, 5, [6, 7, 8, 9], 10]
    list2: [1, 2, 3, 4, 5, [6, 7, 8, 9]]
    list3: [1, 2, 3, 4, 5, [6, 7, 8, 9]]
    &quot;&quot;&quot;
    seed[5].append('a')
    print('lst1:', lst1)
    print('lst2:', lst2)
    print('lst3:', lst2)
    
    &quot;&quot;&quot;
    上面print 语句输出的内容为：
    list1: [1, 2, 3, 4, 5, [6, 7, 8, 9, 'a'], 10]
    list2: [1, 2, 3, 4, 5, [6, 7, 8, 9], 10]
    list3: [1, 2, 3, 4, 5, [6, 7, 8, 9]]
    &quot;&quot;&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="元组"><a class="header" href="#元组">元组</a></h1>
<p>元组<code>Tuple</code>是<code>Python</code>中的一种有序、不可变的数据类型，用于存储多个元素。与列表类似，元组也可以包含任意数量的元素，但一旦创建后，元组中的元素不能被修改、删除或添加。</p>
<h2 id="基本操作-3"><a class="header" href="#基本操作-3">基本操作</a></h2>
<h3 id="创建元组"><a class="header" href="#创建元组">创建元组</a></h3>
<pre><code class="language-python">&gt;&gt;&gt; tp = (1,2,3,4,5)
&gt;&gt;&gt; tp1 = (1, 'a', [3,4,5], True)
</code></pre>
<p>只有一个元素时，需要在第一个元素后加上一个<code>,</code>。如果不加<code>,</code>，系统会认为创建的不是元组，这个元素是什么类型，就会被认为创建的是什么类型</p>
<pre><code class="language-python">&gt;&gt;&gt; tp2 = ('A',) 
&gt;&gt;&gt; tp3 = ([1,2,3],)
</code></pre>
<h3 id="索引和切片-1"><a class="header" href="#索引和切片-1">索引和切片</a></h3>
<p>索引和切片的操作与列表和字符串一致。</p>
<h2 id="探讨"><a class="header" href="#探讨">探讨</a></h2>
<p>元组真的是不可变的吗？我们先看下面的例子：</p>
<pre><code class="language-python">&gt;&gt;&gt; tp = (1, 'a', [3,4,5], True)
&gt;&gt;&gt; tp[0] = 2
Traceback (most recent call last):
  File &quot;&lt;pyshell#14&gt;&quot;, line 1, in &lt;module&gt;
    tp[0] = 2
TypeError: 'tuple' object does not support item assignment
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; tp[2][0] = 6
&gt;&gt;&gt; print(tp)
(1, 'a', [6, 4, 5], True)
</code></pre>
<p>由上可知，元组本身是不能被改变的，但是如果其内部的元素是可变对象时，可以对这个元素进行修改。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="集合"><a class="header" href="#集合">集合</a></h1>
<p>集合<code>Set</code>是一个无序且元素唯一的数据结构，可用于存储不重复的元素，并且可以进行交集、并集、差集等常见的集合操作。</p>
<p>集合一旦创建后里面的内容是不能被修改的，所以列表等能被修改的数据结构对象不能作为集合的元素。</p>
<h2 id="基本操作-4"><a class="header" href="#基本操作-4">基本操作</a></h2>
<h3 id="创建集合"><a class="header" href="#创建集合">创建集合</a></h3>
<p>可以使用大括号 <code>{}</code> 创建集合，元素之间用逗号 <code>,</code> 分隔， 或者也可以使用 <code>set()</code> 函数创建集合。</p>
<pre><code class="language-python">&gt;&gt;&gt; s = {1,2,3,4,5}
&gt;&gt;&gt; print(s)
{1, 2, 3, 4, 5}
&gt;&gt;&gt; st = set()
&gt;&gt;&gt; print(st)
set()
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; {[1,2,3,4]}
Traceback (most recent call last):
  File &quot;&lt;pyshell#18&gt;&quot;, line 1, in &lt;module&gt;
    {[1,2,3,4]}
TypeError: unhashable type: 'list'
</code></pre>
<p>对于空集合，在<code>Python</code>中的表示为<code>set()</code>，并不是<code>{}</code>。</p>
<h3 id="添加元素"><a class="header" href="#添加元素">添加元素</a></h3>
<table><thead><tr><th align="left">名字</th><th align="left">说明</th></tr></thead><tbody>
<tr><td align="left"><code>add</code></td><td align="left">向集合中添加新的元素</td></tr>
<tr><td align="left"><code>update</code></td><td align="left">更新集合，添加的元素来自其它的<code>other</code>对象</td></tr>
</tbody></table>
<h4 id="addelem"><a class="header" href="#addelem">add(elem)</a></h4>
<p><code>add</code>函数用于向集合中添加新的元素，<code>elem</code>必须是不可变的对象。</p>
<pre><code class="language-python">&gt;&gt;&gt; s = {1,2,3,4,5}
&gt;&gt;&gt; s.add(6)
&gt;&gt;&gt; s.add((1,2,3))
&gt;&gt;&gt; print(s)
{1, 2, 3, 4, 5, 6, (1, 2, 3)}
</code></pre>
<h4 id="updateother"><a class="header" href="#updateother">update(other)</a></h4>
<p><code>update</code>函数可以更新集合，添加的元素来自其它的<code>other</code>对象。</p>
<pre><code class="language-python">&gt;&gt;&gt; s = {'A', 'B'}
&gt;&gt;&gt; s.update('abcdefg')
&gt;&gt;&gt; print(s)
{'c', 'a', 'f', 'B', 'A', 'd', 'g', 'e', 'b'}
</code></pre>
<h3 id="移除元素"><a class="header" href="#移除元素">移除元素</a></h3>
<table><thead><tr><th align="left">名字</th><th align="left">说明</th></tr></thead><tbody>
<tr><td align="left"><code>remove</code></td><td align="left">移除一个元素，如果这个元素不在集合里，则报错</td></tr>
<tr><td align="left"><code>discard</code></td><td align="left">移除一个元素，如果这个元素不在集合里，不会报错</td></tr>
<tr><td align="left"><code>pop</code></td><td align="left">移除任意一个元素，并返回这个元素</td></tr>
</tbody></table>
<h4 id="removeelemdiscardelem"><a class="header" href="#removeelemdiscardelem">remove(elem)/discard(elem)</a></h4>
<p><code>remove</code>要求被移除的元素<code>elem</code>必须在集合中，否则会报错。相反，<code>discard</code>不会报错。</p>
<pre><code class="language-python">&gt;&gt;&gt; s = {1, 2, 3, 4, 5}
&gt;&gt;&gt; s.remove(1)
&gt;&gt;&gt; print(s)
{2, 3, 4, 5}
&gt;&gt;&gt; s.remove(7)
Traceback (most recent call last):
  File &quot;&lt;pyshell#31&gt;&quot;, line 1, in &lt;module&gt;
    s.remove(7)
KeyError: 7
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; s.discard(2)
&gt;&gt;&gt; print(s)
{3, 4, 5}
&gt;&gt;&gt; s.discard(7)
&gt;&gt;&gt;
</code></pre>
<h4 id="pop"><a class="header" href="#pop">pop()</a></h4>
<p><code>pop</code>随机移除集合中的任意一个元素。</p>
<pre><code class="language-python">&gt;&gt;&gt; s = {'c', 'a', 'f', 'B', 'A', 'd', 'g', 'e', 'b'}
&gt;&gt;&gt; s.pop()
'c'
&gt;&gt;&gt; print(s)
{'a', 'f', 'B', 'A', 'd', 'g', 'e', 'b'}
</code></pre>
<h3 id="集合运算"><a class="header" href="#集合运算">集合运算</a></h3>
<table><thead><tr><th align="left">名字</th><th align="left">说明</th></tr></thead><tbody>
<tr><td align="left"><code>union</code></td><td align="left">返回集合与另一个数据结构的并集</td></tr>
<tr><td align="left"><code>intersaction</code></td><td align="left">返回集合与另一个数据结构的交集</td></tr>
<tr><td align="left"><code>difference</code></td><td align="left">返回集合与另一个数据结构的差集</td></tr>
</tbody></table>
<h4 id="unionothers"><a class="header" href="#unionothers">union(others)</a></h4>
<p><code>union</code>返回一个新集合，其中包含来自原集合以及<code>others</code>指定的所有集合中的元素，也就是数学中的并集。 这里在的<code>others</code>必须为一个<code>iterable</code>。</p>
<pre><code class="language-python">&gt;&gt;&gt; s= {1,2,3,4}
&gt;&gt;&gt; s1 = {4,5,6,7}
&gt;&gt;&gt; s.union(s1)
{1, 2, 3, 4, 5, 6, 7}
&gt;&gt;&gt; s.union(['a', 'b'])
{1, 2, 3, 4, 'a', 'b'}
</code></pre>
<h4 id="intersectionothers"><a class="header" href="#intersectionothers">intersection(others)</a></h4>
<p><code>intersection</code>返回一个新集合，其中包含原集合以及 others 指定的所有集合中共有的元素，也就是数学中的交集。</p>
<pre><code class="language-python">&gt;&gt;&gt; s= {1,2,3,4}
&gt;&gt;&gt; s1 = {4,5,6,7}
&gt;&gt;&gt; s.intersection(s1)
{4}
</code></pre>
<h3 id="differenceothers"><a class="header" href="#differenceothers">difference(others)</a></h3>
<p><code>intersection</code>返回一个新集合，其中包含原集合中在 others 指定的其他集合中不存在的元素，也就是数学中的差集。</p>
<pre><code class="language-python">&gt;&gt;&gt; s= {1,2,3,4}
&gt;&gt;&gt; s1 = {4,5,6,7}
&gt;&gt;&gt; s.difference(s1)
{1, 2, 3}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="字典"><a class="header" href="#字典">字典</a></h1>
<p>字典是<code>Python</code>中的一种映射类型<code>Mapping Type</code>，是一种无序的、可变的、可迭代的数据类型。它由一系列键-值对组成，其中每个键都是唯一的。与列表<code>List</code>和元组<code>Tuple</code>等序列类型不同，字典是通过键来访问值的，而不是通过索引。字典的基本特性包括：</p>
<ul>
<li><strong>无序性:</strong> 字典中的键-值对是无序的，即插入顺序和遍历顺序不一定相同。</li>
<li><strong>可变性:</strong> 字典是可变的，可以通过增加、删除和修改键值对来改变字典的内容。</li>
<li><strong>动态性:</strong> 字典的大小是可变的，可以根据需要动态增加或减少键值对。</li>
</ul>
<h2 id="基本操作-5"><a class="header" href="#基本操作-5">基本操作</a></h2>
<h3 id="创建字典"><a class="header" href="#创建字典">创建字典</a></h3>
<p>Python中可以使用大括号 <code>{}</code>来创建一个字典，在<code>{}</code>内输入<code>key:value</code>，每个键值对之间用逗号<code>,</code>隔开:</p>
<pre><code class="language-python">&gt;&gt;&gt; my_dict = {'name': 'Alice', 'age': 30, 'city': 'New York'}
</code></pre>
<p>由于字典中键是唯一的，所以在用<code>{}</code>直接创建字典时，如果<code>key</code>重复了，那么它对应的<code>value</code>会被最后一次输入的覆盖：</p>
<pre><code class="language-python">&gt;&gt;&gt; new_dict = {'name': 'Alice', 'age': 30, 'city': 'New York', 'name': 'Chris', 'name': 'Eris'}
&gt;&gt;&gt; print(new_dict)
{'name': 'Eris', 'age': 30, 'city': 'New York'}
</code></pre>
<h3 id="访问字典中的值"><a class="header" href="#访问字典中的值">访问字典中的值</a></h3>
<p>可以使用键<code>key</code>来访问字典中的值<code>value</code>：</p>
<pre><code class="language-python">&gt;&gt;&gt; print(my_dict['name'])  
'Alice'
&gt;&gt;&gt; print(my_dict['age'])   
30
</code></pre>
<h3 id="成员运算-2"><a class="header" href="#成员运算-2">成员运算</a></h3>
<p>可以使用 <code>in</code> 和 <code>not in</code> 运算符执行成员运算，检查键是否存在于字典中：</p>
<pre><code class="language-python"># 检查键是否存在
if 'name' in my_dict:
    print('Name exists in the dictionary')
</code></pre>
<h3 id="更新字典中的值"><a class="header" href="#更新字典中的值">更新字典中的值</a></h3>
<p>可以直接对指定的键赋新值来更新字典中的值：</p>
<pre><code class="language-python">&gt;&gt;&gt; my_dict['name'] = 'Bob'
&gt;&gt;&gt; my_dict['age'] += 1
&gt;&gt;&gt; print(my_dict)
{'name': 'Bob', 'age': 31, 'city': 'New York'}
</code></pre>
<h3 id="添加新的键值对"><a class="header" href="#添加新的键值对">添加新的键值对</a></h3>
<p>可以通过直接赋值来添加新的键值对：</p>
<pre><code class="language-python">&gt;&gt;&gt; my_dict['gender'] = 'Male'
&gt;&gt;&gt; print(my_dict)
{'name': 'Bob', 'age': 31, 'city': 'New York', 'gender': 'Male'}
</code></pre>
<h3 id="删除指定的键值对"><a class="header" href="#删除指定的键值对">删除指定的键值对</a></h3>
<p>可以使用 <code>del</code> 关键字删除指定的键值对：</p>
<pre><code class="language-python">&gt;&gt;&gt; del my_dict['age']
&gt;&gt;&gt; print(my_dict)
{'name': 'Bob', 'city': 'New York', 'gender': 'Male'}
</code></pre>
<h2 id="函数-2"><a class="header" href="#函数-2">函数</a></h2>
<table><thead><tr><th align="left">名字</th><th align="left">说明</th></tr></thead><tbody>
<tr><td align="left"><code>len</code></td><td align="left">有返回值，返回字典的长度，即键值对的个数</td></tr>
<tr><td align="left"><code>min</code></td><td align="left">有返回值，返回字典中最小的字符</td></tr>
<tr><td align="left"><code>max</code></td><td align="left">有返回值，返回字典中最大的字符</td></tr>
</tbody></table>
<h2 id="方法-2"><a class="header" href="#方法-2">方法</a></h2>
<h3 id="获取字典中的键值和键值对"><a class="header" href="#获取字典中的键值和键值对">获取字典中的键、值和键值对</a></h3>
<table><thead><tr><th align="left">名字</th><th align="left">说明</th></tr></thead><tbody>
<tr><td align="left"><code>get</code></td><td align="left">根据键获取其对应的值</td></tr>
<tr><td align="left"><code>keys</code></td><td align="left">返回字典中所有键</td></tr>
<tr><td align="left"><code>values</code></td><td align="left">返回字典中所有值</td></tr>
<tr><td align="left"><code>items</code></td><td align="left">返回字典中所有键键对(key, value)</td></tr>
</tbody></table>
<h4 id="getkey-default"><a class="header" href="#getkey-default">get(key[, default])</a></h4>
<p><code>get</code>方法可以通过传入的参数<code>key</code>来获取在字典中它所对应的值，如果<code>key</code>不存在则返回<code>default</code>的值，若未给出<code>default</code>则默认为<code>None</code>。</p>
<pre><code class="language-python">&gt;&gt;&gt; my_dict.get('name')
'Bob'
&gt;&gt;&gt; my_dict.get('height', 170)
170
&gt;&gt;&gt; my_dict.get('weight')
&gt;&gt;&gt;
</code></pre>
<h4 id="keysvaluesitems"><a class="header" href="#keysvaluesitems">keys()/values()/items()</a></h4>
<p><code>keys</code>、<code>values</code>和<code>items</code>三个方法没有参数，调用之后分别返回字典中所有的键、值和键值对：</p>
<pre><code class="language-python">&gt;&gt;&gt; my_dict = {'name': 'Bob', 'city': 'New York', 'gender': 'Male'}
&gt;&gt;&gt; keys = my_dict.keys()
&gt;&gt;&gt; print(keys)
dict_keys(['name', 'city', 'gender'])
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; values = my_dict.values()
&gt;&gt;&gt; print(values)
dict_values(['Bob', 'New York', 'Male'])
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; items = my_dict.items()
&gt;&gt;&gt; print(items)
dict_items([('name', 'Bob'), ('city', 'New York'), ('gender', 'Male')])
</code></pre>
<p>通过观察上述三个方法的结束可以发现，它们都是可以迭代的对象，所以可以使用 <code>for</code> 循环遍历字典中的所有键、值和键值对：</p>
<pre><code class="language-python"># 遍历所有键
for key in my_dict:
    print(key)

# 遍历所有值
for value in my_dict.values():
    print(value)

# 遍历所有键值对
for key, value in my_dict.items():
    print(key, value)
</code></pre>
<h3 id="更新与删除"><a class="header" href="#更新与删除">更新与删除</a></h3>
<table><thead><tr><th align="left">名字</th><th align="left">说明</th></tr></thead><tbody>
<tr><td align="left"><code>update</code></td><td align="left">使用其它字典更新当前字典</td></tr>
<tr><td align="left"><code>pop</code></td><td align="left">根据键删除字典中的键值对</td></tr>
<tr><td align="left"><code>popitem</code></td><td align="left">根据值删除字典中的键值对</td></tr>
</tbody></table>
<h4 id="updateother-1"><a class="header" href="#updateother-1">update(other)</a></h4>
<p>调用<code>update</code>之后，<code>Python</code>用使用<code>other</code>中的健值对更新当前字典。如果在<code>other</code>中有当前字典中不存在的<code>key</code>，则直接将这个健值对添加到当前字典中，否则用<code>other</code>中的值更新当前字典中键所对应的值。</p>
<pre><code class="language-python">&gt;&gt;&gt; new_dict = {'name': 'Jacky', 'height': 170, 'weight': 55}
&gt;&gt;&gt; my_dict.update(new_dict)
&gt;&gt;&gt; print(my_dict)
{'name': 'Jacky', 'city': 'New York', 'gender': 'Male', 'height': 170, 'weight': 55}
</code></pre>
<h4 id="popkey-default"><a class="header" href="#popkey-default">pop(key[, default])</a></h4>
<p>调用<code>pop</code>后，如果<code>key</code>存在于字典中则将其移除并返回其值，否则返回<code>default</code>。 如果<code>default</code>未给出且<code>key</code>不存在于字典中，则会报错：</p>
<pre><code class="language-python">&gt;&gt;&gt; my_dict.pop('height')
170
&gt;&gt;&gt; my_dict.pop('grade', 6)
6
&gt;&gt;&gt; my_dict.pop('Address')
Traceback (most recent call last):
  File &quot;&lt;pyshell#57&gt;&quot;, line 1, in &lt;module&gt;
    my_dict.pop('Address')
KeyError: 'Address'
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; print(my_dict)
{'name': 'Jacky', 'city': 'New York', 'gender': 'Male', 'weight': 55}
</code></pre>
<h4 id="popitem"><a class="header" href="#popitem">popitem()</a></h4>
<p><code>popitem</code>会以后进先出的方式将字典中的键值对弹出并返回：</p>
<pre><code class="language-python">&gt;&gt;&gt; my_dict.popitem()
('weight', 55)
&gt;&gt;&gt; print(my_dict)
{'name': 'Jacky', 'city': 'New York', 'gender': 'Male'}
</code></pre>
<h3 id="复制与清空"><a class="header" href="#复制与清空">复制与清空</a></h3>
<table><thead><tr><th align="left">名字</th><th align="left">说明</th></tr></thead><tbody>
<tr><td align="left"><code>copy</code></td><td align="left">复制并返回字典浅复制的副本</td></tr>
<tr><td align="left"><code>clear</code></td><td align="left">清空字典中所有的键值对</td></tr>
</tbody></table>
<h4 id="copy-1"><a class="header" href="#copy-1">copy()</a></h4>
<p>可以使用 <code>copy</code> 方法或者使用字典的构造函数来复制字典：</p>
<pre><code class="language-python">&gt;&gt;&gt; new_dict = my_dict.copy()
&gt;&gt;&gt; print(new_dict)
{'name': 'Bob', 'city': 'New York', 'gender': 'Male'}
</code></pre>
<h4 id="clear-1"><a class="header" href="#clear-1">clear()</a></h4>
<p><code>clear()</code>方法可以清空字典中的所有键值对，将它变成一个空字典：</p>
<pre><code class="language-python">&gt;&gt;&gt; my_dict.clear()
&gt;&gt;&gt; print(my_dict)
{}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="推导式与函数"><a class="header" href="#推导式与函数">推导式与函数</a></h1>
<p>我们在前面五个章节中对<code>Python</code>中的内置数据结构做了详细的介绍，其中包括最基本的操作、函数和内置方法的调用。这些数据结构都有很强大的功能，用以解决相对较复杂的问题。</p>
<p>除了直接创建各种数据类型之外，<code>Python</code>也提供推导式和函数高效地生成高级数据类型。</p>
<h2 id="推导式"><a class="header" href="#推导式">推导式</a></h2>
<p>推导式<code>Comprehension</code>是一种在<code>Python</code>中用于创建新的数据结构（例如列表、集合、字典等）的简洁方法。推导式可以将循环和条件语句结合起来，以一种简洁、可读性高的方式生成新的数据结构。</p>
<p><code>Python</code>中有三种类型的推导式：列表推导式<code>List Comprehension</code>、集合推导式<code>Set Comprehension</code>和字典推导式<code>Dictionary Comprehension</code>。每种推导式都有其特定的语法形式，但它们的基本思想都是类似的。</p>
<p>通过推导式可以生成元素个数较多的数据结构对象。</p>
<h3 id="列表推导式list-comprehension"><a class="header" href="#列表推导式list-comprehension">列表推导式（List Comprehension）</a></h3>
<p>列表推导式是用于生成列表的推导式，其语法形式为：</p>
<pre><code class="language-python">[expression for item in iterable if condition]
</code></pre>
<p>其中：</p>
<ul>
<li><code>expression</code>：对每个 <code>item</code> 计算得到的结果。</li>
<li><code>item</code>：可迭代对象中的每个元素。</li>
<li><code>iterable</code>：可迭代对象，如列表、元组、字符串等。</li>
<li><code>condition</code>（可选）：对 <code>item</code> 的筛选条件。</li>
</ul>
<p>例如，生成一个由 1 到 10 的平方组成的列表：</p>
<pre><code class="language-python">&gt;&gt;&gt; squares = [x**2 for x in range(1, 11)]
&gt;&gt;&gt; print(squares)
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
</code></pre>
<h3 id="集合推导式set-comprehension"><a class="header" href="#集合推导式set-comprehension">集合推导式（Set Comprehension）</a></h3>
<p>集合推导式用于生成集合，其语法形式为：</p>
<pre><code class="language-python">{expression for item in iterable if condition}
</code></pre>
<p>其中的语法和列表推导式类似，只是使用了大括号 <code>{}</code>。</p>
<p>例如，生成一个由 1 到 10 的平方组成的集合：</p>
<pre><code class="language-python">&gt;&gt;&gt; squares_set = {x**2 for x in range(1, 11)}
&gt;&gt;&gt; print(squares_set)
{1, 4, 9, 16, 25, 36, 49, 64, 81, 100}
</code></pre>
<h3 id="字典推导式dictionary-comprehension"><a class="header" href="#字典推导式dictionary-comprehension">字典推导式（Dictionary Comprehension）</a></h3>
<p>字典推导式用于生成字典，其语法形式为：</p>
<pre><code class="language-python">{key_expression: value_expression for item in iterable if condition}
</code></pre>
<p>其中：</p>
<ul>
<li><code>key_expression</code>：对每个 <code>item</code> 计算得到的键。</li>
<li><code>value_expression</code>：对每个 <code>item</code> 计算得到的值。</li>
</ul>
<p>例如，生成一个将名字转换为对应长度的字典：</p>
<pre><code class="language-python">&gt;&gt;&gt; names = [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;]
&gt;&gt;&gt; name_lengths = {name: len(name) for name in names}
&gt;&gt;&gt; print(name_lengths)
{'Alice':5, 'Bob':3, 'Charlie':7}
</code></pre>
<p>推导式是 Python 中的一个非常强大和常用的特性，能够以简洁、高效的方式生成新的数据结构，提高了代码的可读性和可维护性。</p>
<h2 id="函数-3"><a class="header" href="#函数-3">函数</a></h2>
<p><code>Python</code>提供丰富的内置函数将传入的参数转换并返回各种高级数据类型， 这里我们用到的词语是<code>“转换”</code>而不是<code>”生成”</code>是因为在<code>Python</code>中有<code>生成器对象(Generator)</code>，所以为了避免在未来的学习过程中产生歧义，我们在这里只用<code>“转换”</code>一词:</p>
<table><thead><tr><th align="left">函数名</th><th align="left">说明</th></tr></thead><tbody>
<tr><td align="left"><code>str</code></td><td align="left">将参数转换成字符串并返回</td></tr>
<tr><td align="left"><code>list</code></td><td align="left">将参数转换成列表并返回</td></tr>
<tr><td align="left"><code>tuple</code></td><td align="left">将参数转换成元组并返回</td></tr>
<tr><td align="left"><code>set</code></td><td align="left">将参数转换成集合并返回</td></tr>
<tr><td align="left"><code>dict</code></td><td align="left">将参数转换成字典并返回</td></tr>
</tbody></table>
<h3 id="strobject"><a class="header" href="#strobject">str(object)</a></h3>
<p>将<code>object</code>转换成字符串文本并返回, 如果没有传参数则返回空字符串<code>&quot;&quot;</code>。</p>
<p>这个函数我们并不陌生，在<a href="16.%E6%8E%A8%E5%AF%BC%E5%BC%8F%E4%B8%8E%E5%87%BD%E6%95%B0/../06.%E5%B8%B8%E7%94%A8%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0/%E5%B8%B8%E7%94%A8%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0.html">常用内置函数</a>一章中就已经学习过了，它的功能很简单，就是将传入的参数转换成字符串，如：</p>
<pre><code class="language-python">&gt;&gt;&gt; str(1)
'1'
</code></pre>
<p>上面例子中，我们传入的参数只是基本的整型，但是对于更复杂的高级数据类型，它的作用不是将其中的元素进行拼接再转换成字条串，而是在将其所表现的基础上直接加上引号，如<code>str([1,2,3])</code>的结果不是<code>'123'</code>, 而是<code>'[1,2,3]'</code></p>
<pre><code class="language-python">&gt;&gt;&gt; str([1, 2, 3])
'[1, 2, 3]'
</code></pre>
<p>对于<code>str</code>函数的学习还没完结，我们会在后面继续介绍。</p>
<h3 id="listiterable"><a class="header" href="#listiterable">list(iterable)</a></h3>
<p>返回将<code>iterable</code>转换之后生成的列表, 如果没有传参数则返回空列表<code>[]</code>。</p>
<pre><code class="language-python">&gt;&gt;&gt; list(&quot;abcdefg&quot;)
['a','b','c','d','e','f','g']
&gt;&gt;&gt; list(1)
Traceback (most recent call last):
  File &quot;&lt;pyshell#4&gt;&quot;, line 1, in &lt;module&gt;
    list(1)
TypeError: 'int' object is not iterable

&gt;&gt;&gt; list()
[]
&gt;&gt;&gt; list({1:2,3:4,5:6})
[1, 3, 5]
</code></pre>
<h3 id="tupleiterable"><a class="header" href="#tupleiterable">tuple(iterable)</a></h3>
<p>返回将<code>iterable</code>转换之后生成的元组，如果没有传参数则返回空元组<code>()</code>。</p>
<pre><code class="language-python">&gt;&gt;&gt; tuple([1,2,3,4,5,6,7])
(1, 2, 3, 4, 5, 6, 7)
&gt;&gt;&gt; tuple(&quot;abcdefg&quot;)
('a', 'b', 'c', 'd', 'e', 'f', 'g')
&gt;&gt;&gt; tuple()
()
</code></pre>
<h3 id="setiterable"><a class="header" href="#setiterable">set(iterable)</a></h3>
<p>返回将<code>iterable</code>转换之后生成的集合，如果没有传参数则返回空集合<code>set()</code>。</p>
<pre><code class="language-python">&gt;&gt;&gt; set([1,2,3,4,5,5,6,1,4])
{1, 2, 3, 4, 5, 6}
&gt;&gt;&gt; set()
set()
</code></pre>
<h3 id="dictkwargs"><a class="header" href="#dictkwargs">dict(**kwargs)</a></h3>
<p>返回一个字典，字典内每个键值对由关键字参数中一对<code>参数名=值</code>组成，无参数则返回一个空字典<code>{}</code>。</p>
<pre><code class="language-python">&gt;&gt;&gt; dict(one=1, two=2, three=3, F=1111)
{'one': 1, 'two': 2, 'three': 3, 'F': 1111}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="内置函数"><a class="header" href="#内置函数">内置函数</a></h1>
<h2 id="数学运算"><a class="header" href="#数学运算">数学运算</a></h2>
<table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody>
<tr><td><code>abs(x)</code></td><td>求x的绝对值</td></tr>
<tr><td><code>divmod(x, y)</code></td><td>求两个数的整除和求余结果(x//y, x%y)</td></tr>
<tr><td>round(a, b)</td><td>对a进行四舍五入操作，进位到b</td></tr>
<tr><td>pow(x, y)</td><td>求x的y次幂的结果</td></tr>
<tr><td>sum(x, start=b)</td><td>对x中所有元素求和, x必须是可迭代的，如列表</td></tr>
<tr><td>min/max</td><td>求最小/最大值</td></tr>
</tbody></table>
<pre><code class="language-python">&gt;&gt;&gt; abs(-4)
4
&gt;&gt;&gt; divmod(10, 3)
(3, 1)
&gt;&gt;&gt; divmod(-10, 3)
(-4, 2)
&gt;&gt;&gt; round(3.1415926,3)
3.142
&gt;&gt;&gt; round(3.1415926) # round(3.1415926, 0)
3
&gt;&gt;&gt; round(12306.78, 1)
12310
&gt;&gt;&gt; pow(2, 4)
16
&gt;&gt;&gt; sum([1,2,3,4])
10
&gt;&gt;&gt; sum([1,2,3,4],start=10)
20
&gt;&gt;&gt; min(1,2,3,4,5)
1
&gt;&gt;&gt; max([3,4,5])
5
</code></pre>
<h2 id="进制转换-1"><a class="header" href="#进制转换-1">进制转换</a></h2>
<table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody>
<tr><td><code>bin(x)</code></td><td>将x转换成二进制</td></tr>
<tr><td><code>oct(x)</code></td><td>将x转换成八进制</td></tr>
<tr><td><code>hex(x)</code></td><td>将x转换成十六进制</td></tr>
<tr><td><code>int(x,base)</code></td><td>将x转换成十进制</td></tr>
</tbody></table>
<pre><code class="language-python">&gt;&gt;&gt; bin(432)
'0b110110000'
&gt;&gt;&gt; oct(432)
'0o660'
&gt;&gt;&gt; hex(432)
'0x1b0'
&gt;&gt;&gt; int('32baf', 16)
207791
&gt;&gt;&gt; int('32bag', 17)
263754
</code></pre>
<h2 id="类型转换"><a class="header" href="#类型转换">类型转换</a></h2>
<table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody>
<tr><td><code>bool(x)</code></td><td>将x转换成布尔型，如果x为真值，则返回True</td></tr>
<tr><td><code>str(x)</code></td><td>将x转换成字符串，可以直接理解为在x左右两边加<code>&quot;</code>或<code>'</code></td></tr>
<tr><td><code>list(iterable)</code></td><td>将iterable转换成列表</td></tr>
<tr><td><code>tuple(iterable)</code></td><td>将iterable转换成元组</td></tr>
<tr><td><code>set(iterable)</code></td><td>将iterable转换成集合</td></tr>
<tr><td><code>dict(**kwargs)</code></td><td>返回一个字典，字典中的键值对中kwargs里的<code>参数名=值</code>组成</td></tr>
</tbody></table>
<p>假值：<code>0</code>, <code>''</code>, <code>None</code>, <code>0.000</code>, <code>[]</code>, <code>(,)</code>, <code>{}</code>, <code>set()</code></p>
<pre><code class="language-python">&gt;&gt;&gt; bool(-1)
True
&gt;&gt;&gt; str([1,2,3,4,5])
'[1, 2, 3, 4, 5]'
&gt;&gt;&gt; list(&quot;abcde&quot;)
['a', 'b', 'c', 'd', 'e']
&gt;&gt;&gt; tuple(&quot;abcde&quot;)
('a', 'b', 'c', 'd', 'e')
&gt;&gt;&gt; set(&quot;aabbccddee&quot;)
{'a', 'b', 'c', 'd', 'e'}
&gt;&gt;&gt; dict(one=1, two=2, three=3)
{'one': 1, 'two': 2, 'three': 3}
</code></pre>
<h2 id="字符与码位的转换"><a class="header" href="#字符与码位的转换">字符与码位的转换</a></h2>
<table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody>
<tr><td><code>ord(x)</code></td><td>返回x在字符集中的位置， x必须为字符</td></tr>
<tr><td><code>chr(x)</code></td><td>返回字符集中第x位上的字符，x必须为整型</td></tr>
</tbody></table>
<pre><code class="language-python">&gt;&gt;&gt; ord('陈')
38472
&gt;&gt;&gt; chr(38471)
'陇'
</code></pre>
<h2 id="检查空值"><a class="header" href="#检查空值">检查空值</a></h2>
<table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody>
<tr><td><code>all(iterable)</code></td><td>如果iterable中所有元素都是真值或为空，返回True,否则返回False</td></tr>
<tr><td><code>any(iterable)</code></td><td>如果iterable中任一元素为真值返回True,否则返回False</td></tr>
</tbody></table>
<pre><code class="language-python">def all(iterable):
    for element in iterable:
        if not element:
            return False
    return True

def any(iterable):
    for element in iterable:
        if element:
            return True
    return False

&gt;&gt;&gt; all([])
True
&gt;&gt;&gt; any([])
False
&gt;&gt;&gt; all([1,2,3,4])
True
&gt;&gt;&gt; all([0,1,2,3])
False
</code></pre>
<h2 id="批量处理迭代对象"><a class="header" href="#批量处理迭代对象">批量处理迭代对象</a></h2>
<table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody>
<tr><td><code>filter(func, iterable)</code></td><td>将iterable中所有元素作为参数传值给func函数，如果结果为False,则这个元素会被忽略，没有给Func函数传值时默认调用bool()</td></tr>
<tr><td><code>map(func, iterable)</code></td><td>将iterable中所有元素作为参数传值给func函数，将这些新的值放在一个新的可迭代对象里</td></tr>
</tbody></table>
<pre><code class="language-python">&gt;&gt;&gt; lst = [0, 1, 2, 3, 4]
&gt;&gt;&gt; f = filter(None, lst)
&gt;&gt;&gt; print(f)
&lt;filter object at 0x00000255BAAF4E20&gt;
&gt;&gt;&gt; list(f)
[1, 2, 3, 4]

&gt;&gt;&gt; m = map(str, lst)
&gt;&gt;&gt; print(m)
&lt;map object at 0x00000255BAAF4EE0&gt;
&gt;&gt;&gt; list(m)
['0', '1', '2', '3', '4']
</code></pre>
<h2 id="枚举迭代对象"><a class="header" href="#枚举迭代对象">枚举迭代对象</a></h2>
<p><code>enumerate(iterable)</code> 枚举iterable中的元素的索引和值，并放在一个新的迭代器中</p>
<pre><code class="language-python">
my_dict = {'A': 1, 'B': 2}

for i in enumerate(my_dict):
    print(i)

&quot;&quot;&quot;
(0, 'A')
(1, 'B')
&quot;&quot;&quot;

lst = ['a', 'b']

for i in enumerate(lst):
    print(i)

&quot;&quot;&quot;
(0, 'a')
(1, 'b')
&quot;&quot;&quot;
</code></pre>
<h2 id="执行语句"><a class="header" href="#执行语句">执行语句</a></h2>
<table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody>
<tr><td><code>eval()</code></td><td>执行一个表达式，并返回表达式的结果</td></tr>
<tr><td><code>exec()</code></td><td>执行段语句，没有返回值</td></tr>
</tbody></table>
<pre><code class="language-python">&gt;&gt;&gt; a = 5
&gt;&gt;&gt; eval(&quot;a+6&quot;)
11
&gt;&gt;&gt; eval(&quot;'a'*10&quot;)
'aaaaaaaaaa'
</code></pre>
<pre><code class="language-python">cycle = &quot;&quot;&quot;
import turtle as t
t.circle(100)
&quot;&quot;&quot;
exec(cycle)
</code></pre>
<h2 id="对象类型"><a class="header" href="#对象类型">对象类型</a></h2>
<table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody>
<tr><td><code>type(obj)</code></td><td>返回obj的类名</td></tr>
<tr><td><code>isinstance(obj, type)</code></td><td>查验obj是不是type类型</td></tr>
</tbody></table>
<pre><code class="language-python">&gt;&gt;&gt; type(1)
&lt;class 'int'&gt;

a = input(&quot;input a number:&quot;)

if type(a) == int:
    print('Yes')
</code></pre>
<pre><code class="language-python">&gt;&gt;&gt; isinstance(1, int)
True
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="内置函数-1"><a class="header" href="#内置函数-1">内置函数</a></h1>
<h2 id="数学运算-1"><a class="header" href="#数学运算-1">数学运算</a></h2>
<table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody>
<tr><td><code>abs(x)</code></td><td>求x的绝对值</td></tr>
<tr><td><code>divmod(x, y)</code></td><td>求两个数的整除和求余结果(x//y, x%y)</td></tr>
<tr><td>round(a, b)</td><td>对a进行四舍五入操作，进位到b</td></tr>
<tr><td>pow(x, y)</td><td>求x的y次幂的结果</td></tr>
<tr><td>sum(x, start=b)</td><td>对x中所有元素求和, x必须是可迭代的，如列表</td></tr>
<tr><td>min/max</td><td>求最小/最大值</td></tr>
</tbody></table>
<pre><code class="language-python">&gt;&gt;&gt; abs(-4)
4
&gt;&gt;&gt; divmod(10, 3)
(3, 1)
&gt;&gt;&gt; divmod(-10, 3)
(-4, 2)
&gt;&gt;&gt; round(3.1415926,3)
3.142
&gt;&gt;&gt; round(3.1415926) # round(3.1415926, 0)
3
&gt;&gt;&gt; round(12306.78, 1)
12310
&gt;&gt;&gt; pow(2, 4)
16
&gt;&gt;&gt; sum([1,2,3,4])
10
&gt;&gt;&gt; sum([1,2,3,4],start=10)
20
&gt;&gt;&gt; min(1,2,3,4,5)
1
&gt;&gt;&gt; max([3,4,5])
5
</code></pre>
<h2 id="进制转换-2"><a class="header" href="#进制转换-2">进制转换</a></h2>
<table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody>
<tr><td><code>bin(x)</code></td><td>将x转换成二进制</td></tr>
<tr><td><code>oct(x)</code></td><td>将x转换成八进制</td></tr>
<tr><td><code>hex(x)</code></td><td>将x转换成十六进制</td></tr>
<tr><td><code>int(x,base)</code></td><td>将x转换成十进制</td></tr>
</tbody></table>
<pre><code class="language-python">&gt;&gt;&gt; bin(432)
'0b110110000'
&gt;&gt;&gt; oct(432)
'0o660'
&gt;&gt;&gt; hex(432)
'0x1b0'
&gt;&gt;&gt; int('32baf', 16)
207791
&gt;&gt;&gt; int('32bag', 17)
263754
</code></pre>
<h2 id="类型转换-1"><a class="header" href="#类型转换-1">类型转换</a></h2>
<table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody>
<tr><td><code>bool(x)</code></td><td>将x转换成布尔型，如果x为真值，则返回True</td></tr>
<tr><td><code>str(x)</code></td><td>将x转换成字符串，可以直接理解为在x左右两边加<code>&quot;</code>或<code>'</code></td></tr>
<tr><td><code>list(iterable)</code></td><td>将iterable转换成列表</td></tr>
<tr><td><code>tuple(iterable)</code></td><td>将iterable转换成元组</td></tr>
<tr><td><code>set(iterable)</code></td><td>将iterable转换成集合</td></tr>
<tr><td><code>dict(**kwargs)</code></td><td>返回一个字典，字典中的键值对中kwargs里的<code>参数名=值</code>组成</td></tr>
</tbody></table>
<p>假值：<code>0</code>, <code>''</code>, <code>None</code>, <code>0.000</code>, <code>[]</code>, <code>(,)</code>, <code>{}</code>, <code>set()</code></p>
<pre><code class="language-python">&gt;&gt;&gt; bool(-1)
True
&gt;&gt;&gt; str([1,2,3,4,5])
'[1, 2, 3, 4, 5]'
&gt;&gt;&gt; list(&quot;abcde&quot;)
['a', 'b', 'c', 'd', 'e']
&gt;&gt;&gt; tuple(&quot;abcde&quot;)
('a', 'b', 'c', 'd', 'e')
&gt;&gt;&gt; set(&quot;aabbccddee&quot;)
{'a', 'b', 'c', 'd', 'e'}
&gt;&gt;&gt; dict(one=1, two=2, three=3)
{'one': 1, 'two': 2, 'three': 3}
</code></pre>
<h2 id="字符与码位的转换-1"><a class="header" href="#字符与码位的转换-1">字符与码位的转换</a></h2>
<table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody>
<tr><td><code>ord(x)</code></td><td>返回x在字符集中的位置， x必须为字符</td></tr>
<tr><td><code>chr(x)</code></td><td>返回字符集中第x位上的字符，x必须为整型</td></tr>
</tbody></table>
<pre><code class="language-python">&gt;&gt;&gt; ord('陈')
38472
&gt;&gt;&gt; chr(38471)
'陇'
</code></pre>
<h2 id="检查空值-1"><a class="header" href="#检查空值-1">检查空值</a></h2>
<table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody>
<tr><td><code>all(iterable)</code></td><td>如果iterable中所有元素都是真值或为空，返回True,否则返回False</td></tr>
<tr><td><code>any(iterable)</code></td><td>如果iterable中任一元素为真值返回True,否则返回False</td></tr>
</tbody></table>
<pre><code class="language-python">def all(iterable):
    for element in iterable:
        if not element:
            return False
    return True

def any(iterable):
    for element in iterable:
        if element:
            return True
    return False

&gt;&gt;&gt; all([])
True
&gt;&gt;&gt; any([])
False
&gt;&gt;&gt; all([1,2,3,4])
True
&gt;&gt;&gt; all([0,1,2,3])
False
</code></pre>
<h2 id="批量处理迭代对象-1"><a class="header" href="#批量处理迭代对象-1">批量处理迭代对象</a></h2>
<table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody>
<tr><td><code>filter(func, iterable)</code></td><td>将iterable中所有元素作为参数传值给func函数，如果结果为False,则这个元素会被忽略，没有给Func函数传值时默认调用bool()</td></tr>
<tr><td><code>map(func, iterable)</code></td><td>将iterable中所有元素作为参数传值给func函数，将这些新的值放在一个新的可迭代对象里</td></tr>
</tbody></table>
<pre><code class="language-python">&gt;&gt;&gt; lst = [0, 1, 2, 3, 4]
&gt;&gt;&gt; f = filter(None, lst)
&gt;&gt;&gt; print(f)
&lt;filter object at 0x00000255BAAF4E20&gt;
&gt;&gt;&gt; list(f)
[1, 2, 3, 4]

&gt;&gt;&gt; m = map(str, lst)
&gt;&gt;&gt; print(m)
&lt;map object at 0x00000255BAAF4EE0&gt;
&gt;&gt;&gt; list(m)
['0', '1', '2', '3', '4']
</code></pre>
<h2 id="枚举迭代对象-1"><a class="header" href="#枚举迭代对象-1">枚举迭代对象</a></h2>
<p><code>enumerate(iterable)</code> 枚举iterable中的元素的索引和值，并放在一个新的迭代器中</p>
<pre><code class="language-python">
my_dict = {'A': 1, 'B': 2}

for i in enumerate(my_dict):
    print(i)

&quot;&quot;&quot;
(0, 'A')
(1, 'B')
&quot;&quot;&quot;

lst = ['a', 'b']

for i in enumerate(lst):
    print(i)

&quot;&quot;&quot;
(0, 'a')
(1, 'b')
&quot;&quot;&quot;
</code></pre>
<h2 id="执行语句-1"><a class="header" href="#执行语句-1">执行语句</a></h2>
<table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody>
<tr><td><code>eval()</code></td><td>执行一个表达式，并返回表达式的结果</td></tr>
<tr><td><code>exec()</code></td><td>执行段语句，没有返回值</td></tr>
</tbody></table>
<pre><code class="language-python">&gt;&gt;&gt; a = 5
&gt;&gt;&gt; eval(&quot;a+6&quot;)
11
&gt;&gt;&gt; eval(&quot;'a'*10&quot;)
'aaaaaaaaaa'
</code></pre>
<pre><code class="language-python">cycle = &quot;&quot;&quot;
import turtle as t
t.circle(100)
&quot;&quot;&quot;
exec(cycle)
</code></pre>
<h2 id="对象类型-1"><a class="header" href="#对象类型-1">对象类型</a></h2>
<table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody>
<tr><td><code>type(obj)</code></td><td>返回obj的类名</td></tr>
<tr><td><code>isinstance(obj, type)</code></td><td>查验obj是不是type类型</td></tr>
</tbody></table>
<pre><code class="language-python">&gt;&gt;&gt; type(1)
&lt;class 'int'&gt;

a = input(&quot;input a number:&quot;)

if type(a) == int:
    print('Yes')
</code></pre>
<pre><code class="language-python">&gt;&gt;&gt; isinstance(1, int)
True
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="文件的操作"><a class="header" href="#文件的操作">文件的操作</a></h2>
<p>假设下列文件存放在<code>D:</code>盘，命名为<code>subject.txt</code></p>
<pre><code class="language-text">Chinese
Mathematics
English
Chemistry
Physics
</code></pre>
<h3 id="打开文件"><a class="header" href="#打开文件">打开文件</a></h3>
<p>函数<code>open(&quot;filepath/filename&quot;,&quot;mode&quot;,encoding=&quot;utf-8&quot;)</code></p>
<pre><code class="language-Python">&quot;&quot;&quot;
以只读模式打开文件，文件存储在windows系统中
&quot;&quot;&quot;
f = open(&quot;d:\\subject.txt&quot;,&quot;r&quot;,encoding=&quot;utf-8&quot;)
f.close()
</code></pre>
<p>假如，文件存储在<code>Linux</code>或者<code>MacOS</code>系统中,正确的代码为</p>
<pre><code class="language-Python">&quot;&quot;&quot;
以只读模式打开文件，文件存储在windows系统中
&quot;&quot;&quot;
f = open(&quot;/path/subject.txt&quot;,&quot;r&quot;,encoding=&quot;utf-8&quot;)
f.close()
</code></pre>
<p>用<code>with</code>关键字打开，不需要调用<code>close()</code>方法，但是打开之后，操作文件的语句要缩进</p>
<pre><code class="language-python">with open(&quot;d://score2.csv&quot;, 'r', encoding=&quot;utf-8&quot;) as f:
    print(f.readlines())
</code></pre>
<h3 id="模式"><a class="header" href="#模式">模式</a></h3>
<table><thead><tr><th>模式</th><th>解释</th></tr></thead><tbody>
<tr><td><code>r</code></td><td>只读文件</td></tr>
<tr><td><code>w</code></td><td>写入文件</td></tr>
<tr><td><code>a</code></td><td>追加文件</td></tr>
<tr><td><code>+</code></td><td>和上三种配合使用，让打开的文件可读可写</td></tr>
</tbody></table>
<h4 id="只读"><a class="header" href="#只读">只读</a></h4>
<p><strong>read()</strong></p>
<ul>
<li>当不输入参数时，读取文件内所有内容;</li>
<li>当输入参数时，如read(10)，从第一个字节开始，读取后面10个字符。</li>
</ul>
<pre><code class="language-Python">f = open(&quot;/path/subject.txt&quot;,&quot;r&quot;,encoding=&quot;utf-8&quot;)
print(f.read())
f.close()
&quot;&quot;&quot;
输出结果为：
Chinese
Mathematics
English
Chemistry
Physics

&quot;&quot;&quot;
</code></pre>
<pre><code class="language-Python">f = open(&quot;/path/subject.txt&quot;,&quot;r&quot;,encoding=&quot;utf-8&quot;)
print(f.read(10))
f.close()
&quot;&quot;&quot;
输出结果为：
Chinese
Ma

在Chinese后有一个换行符，也是字符。
&quot;&quot;&quot;
</code></pre>
<p><strong>readline()</strong></p>
<ul>
<li>当不输入参数时，读取数据直到遇到换行或者<code>EOF</code>;</li>
<li>当输入参数时，如readline(10)，从第一个字节开始，读取后面10个字符，但是遇到换行或者<code>EOF</code>立即停止。</li>
</ul>
<pre><code class="language-Python">f = open(&quot;/path/subject.txt&quot;,&quot;r&quot;,encoding=&quot;utf-8&quot;)
print(f.readline())
f.close()
&quot;&quot;&quot;
输出结果为：
Chinese

在Chinese后有一个换行符，并且print以换行结束，所以有一空行。
&quot;&quot;&quot;
</code></pre>
<pre><code class="language-Python">f = open(&quot;/path/subject.txt&quot;,&quot;r&quot;,encoding=&quot;utf-8&quot;)
print(f.readline(5))
print(f.readline())
f.close()
&quot;&quot;&quot;
输出结果为：
Chine
se

&quot;&quot;&quot;
</code></pre>
<p><strong>readlines()</strong></p>
<ul>
<li>没有参数，以文件每一行为元素(包括换行符)，返回一个列表。</li>
</ul>
<pre><code class="language-Python">f = open(&quot;/path/subject.txt&quot;,&quot;r&quot;,encoding=&quot;utf-8&quot;)
print(f.readlines())
f.close()
&quot;&quot;&quot;
输出结果为：
['Chinese\n','Mathematics\n','English\n','Chemistry\n','Physics\n']

&quot;&quot;&quot;
</code></pre>
<h4 id="写入"><a class="header" href="#写入">写入</a></h4>
<p>要写入文件，需要用<code>w</code>或者<code>a</code>两种模式打开文件。两者的区别为：</p>
<ul>
<li><code>w</code>是先清除文件所有内容再写入,清除文件的操作在打开时完成;</li>
<li><code>a</code>是在文件现有内容后追加新的内容，打开文件时，游标被移动到最近。</li>
</ul>
<p>写入的函数是<strong>write()</strong></p>
<pre><code class="language-Python">&quot;&quot;&quot;
以写入的模式打开文件
&quot;&quot;&quot;
f = open(&quot;/path/subject.txt&quot;,'w',encoding=&quot;utf-8&quot;)
f.write(&quot;Biology\n&quot;)
f.write(&quot;History\n&quot;)
f.close()
</code></pre>
<pre><code class="language-Python">&quot;&quot;&quot;
以追加的模式打开文件
&quot;&quot;&quot;
f = open(&quot;/path/subject.txt&quot;,'a',encoding=&quot;utf-8&quot;)
f.write(&quot;Biology\n&quot;)
f.write(&quot;History\n&quot;)
f.close()
</code></pre>
<h4 id="可读可写"><a class="header" href="#可读可写">可读可写</a></h4>
<p>可读可写模式的实现可以将<code>r</code>、<code>w</code>、<code>a</code>三种模式后加上一个<code>+</code>，即<code>r+</code>、<code>w+</code>、<code>a+</code>，三者区别：</p>
<ul>
<li><code>r+</code>:打开文件时，游标在文件开头，但是原本内容还在</li>
<li><code>w+</code>:打开文件时，游标在文件开头，原本内容已经被清除</li>
<li><code>a+</code>:打开文件时，游标在文件最后，且原本内容还在</li>
</ul>
<pre><code class="language-Python">f = open(&quot;/path/subject.txt&quot;,&quot;r+&quot;,encoding=&quot;utf-8&quot;)
f.write(&quot;Geography&quot;)
print(f.read())
f.close()
&quot;&quot;&quot;
输出结果为：

&quot;&quot;&quot;
</code></pre>
<p>当写入之后，游标的位置位于刚刚写入内容的后面，所以不能读出刚刚写入的内容。
如果要解决这个问题，需要用到<code>seek(0)</code>函数;
<code>seek(0)</code>函数的功能是，将游标移动到指定位置，<code>0</code>即最起始位置。</p>
<p>所以上述代码只需要多加一行，就能读取出写入之后的文件内所有内容，请自行完成代码。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="进制转换-3"><a class="header" href="#进制转换-3">进制转换</a></h1>
<p>在计算机科学中，数值的表示和处理主要使用四种进制：二进制、八进制、十进制和十六进制，这些不同的进制各自有其独特的优势和应用场景。二进制是计算机内部数据存储和处理的基础；八进制和十六进制由于其与二进制的方便转换关系，常用于简化表示和内存地址表示；十进制则是人类最常用的进制系统，方便与计算机进行数据交换和理解。在理解和掌握这些进制系统的转换规则后，可以更高效地进行计算机相关的编程和操作。</p>
<h2 id="介绍"><a class="header" href="#介绍">介绍</a></h2>
<h3 id="二进制-binary"><a class="header" href="#二进制-binary">二进制 (Binary)</a></h3>
<p><strong>基数</strong>：2<br />
<strong>数字</strong>：0, 1</p>
<p>二进制是计算机内部使用的基本数制，因为计算机的底层硬件使用高低电压（通常表示为0和1）来存储和处理数据。二进制数的每一位称为<strong>位</strong>（bit）。</p>
<p>示例：</p>
<ul>
<li>二进制：1011</li>
<li>对应的十进制：\[1 \times 2^3 + 0 \times 2^2 + 1 \times 2^1 + 1 \times 2^0 = 8 + 0 + 2 + 1 = 11\]</li>
</ul>
<h3 id="八进制-octal"><a class="header" href="#八进制-octal">八进制 (Octal)</a></h3>
<p><strong>基数</strong>：8<br />
<strong>数字</strong>：0, 1, 2, 3, 4, 5, 6, 7</p>
<p>八进制数常用于简化二进制数的表示。因为3位二进制数正好可以表示一个八进制数，因此八进制数比二进制数更紧凑，容易阅读。</p>
<p>示例：</p>
<ul>
<li>八进制：13</li>
<li>对应的二进制：001 011（将每个八进制数字转换为3位二进制）</li>
<li>对应的十进制：\[1 \times 8^1 + 3 \times 8^0 = 8 + 3 = 11 \]</li>
</ul>
<h3 id="十进制-decimal"><a class="header" href="#十进制-decimal">十进制 (Decimal)</a></h3>
<p><strong>基数</strong>：10<br />
<strong>数字</strong>：0, 1, 2, 3, 4, 5, 6, 7, 8, 9</p>
<p>十进制是我们日常生活中最常使用的数制，基于10个数字。计算机编程中也经常使用十进制数来表示和输入数据。</p>
<p>示例：</p>
<ul>
<li>十进制：11</li>
<li>对应的值：\[1 \times 10^1 + 1 \times 10^0 = 10 + 1 = 11\]</li>
</ul>
<h3 id="十六进制-hexadecimal"><a class="header" href="#十六进制-hexadecimal">十六进制 (Hexadecimal)</a></h3>
<p><strong>基数</strong>：16<br />
<strong>数字</strong>：0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F</p>
<p>十六进制数常用于计算机科学和数字电子学，因为它比二进制和八进制更紧凑且易于转换。每一个十六进制数字可以表示4位二进制数。</p>
<p>示例：</p>
<ul>
<li>十六进制：B</li>
<li>对应的二进制：1011（将每个十六进制数字转换为4位二进制）</li>
<li>对应的十进制：\[11 \times 16^0 = 11 \]</li>
</ul>
<h2 id="进制转换-4"><a class="header" href="#进制转换-4">进制转换</a></h2>
<h3 id="将十进制转换为二进制的方法"><a class="header" href="#将十进制转换为二进制的方法">将十进制转换为二进制的方法</a></h3>
<p>将十进制转换为二进制可以通过一种称为“除2取余法”的方法实现。该方法包括以下步骤：</p>
<ol>
<li><strong>除以2</strong>：用十进制数除以2，并记录商和余数。</li>
<li><strong>记录余数</strong>：将得到的余数作为二进制数的一位（从右到左）。</li>
<li><strong>更新商</strong>：将商作为新的十进制数，重复步骤1和2，直到商为0。</li>
<li><strong>排列余数</strong>：将记录的余数逆序排列，即从最后一个余数到第一个余数，得到二进制数。</li>
</ol>
<p>举例说明：</p>
<p>假设将十进制数42转换为二进制。</p>
<table><thead><tr><th align="center">          除数          </th><th align="center">          商          </th><th align="center">          余数          </th></tr></thead><tbody>
<tr><td align="center">42 ÷ 2</td><td align="center">21</td><td align="center">0</td></tr>
<tr><td align="center">21 ÷ 2</td><td align="center">10</td><td align="center">1</td></tr>
<tr><td align="center">10 ÷ 2</td><td align="center">5</td><td align="center">0</td></tr>
<tr><td align="center">5 ÷ 2</td><td align="center">2</td><td align="center">1</td></tr>
<tr><td align="center">2 ÷ 2</td><td align="center">1</td><td align="center">0</td></tr>
<tr><td align="center">1 ÷ 2</td><td align="center">0</td><td align="center">1</td></tr>
</tbody></table>
<p>将余数逆序排列：101010</p>
<p>因此，十进制数42的二进制表示为101010。</p>
<p>通过以上步骤，可以将任何十进制数转换为二进制数。这种方法直观且易于理解，是学习进制转换的基础。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="异常处理"><a class="header" href="#异常处理">异常处理</a></h2>
<p>在程序运行过程中，出现一些未能避免的错误，通常这些错误会导致程序不能正常结束，所以异常处理是用来处理这些错误。
比如，我们开发一个计算器程序，从键盘输入数值和运算符来计算结果，但是如果错误输入了字符去运算，那么正常在Python中会报错，从而程序中止运行。那么此时就需要异常处理来保证程序能正常结束：想要计算<code>1/2</code>的结果，在输入<code>/</code>之后，输出了<code>0</code>，那么这时，计算的结果肯定是错误。</p>
<h3 id="语法结构"><a class="header" href="#语法结构">语法结构</a></h3>
<pre><code class="language-Python">try:
    # 可能会发生异常的语句
except:                   
    # 捕获到异常之后要执行的语句
else:
    # 没有异常时要执行的语句
finally:
    # 不论有无异常，都要执行的语句
</code></pre>
<p>在异常处理中，<code>else</code>和<code>finally</code>不是必须的。一旦写了<code>try</code>，那么一定要有<code>except</code>。</p>
<p>尝试运行下列代码：</p>
<pre><code class="language-Python">a = 5
b = 0
c = a / b
&quot;&quot;&quot;
执行上述代码后会有下面错误发生：
Traceback (most recent call last):
  File &quot;&lt;pyshell#3&gt;&quot;, line 1, in &lt;module&gt;
    a/b
ZeroDivisionError: division by zero
&quot;&quot;&quot;
</code></pre>
<p>如果用异常处理，正确的方式为：</p>
<pre><code class="language-python">a = 5
b = 0
try:
    c = a / b
except:
    print(&quot;有异常&quot;)
</code></pre>
<p>假如，我要设计的逻辑是有异常就处理，没有异常则打印c的值，则需要在<code>else</code>的下面填写语句：</p>
<pre><code class="language-python">a = 5
b = 4
try:
    c = a / b
except:
    print(&quot;有异常&quot;)
else:
    print(&quot;c的值为：&quot;,c)
</code></pre>
<p>如果不管有没有异常，我都需要提醒一句&quot;程序结束&quot;，则需要在<code>finally</code>的下面填写语句：</p>
<pre><code class="language-python">a = 5
b = 4
try:
    c = a / b
except:
    print(&quot;有异常&quot;)
else:
    print(&quot;c的值为：&quot;,c)
finally:
    print(&quot;程序结束！&quot;)
</code></pre>
<h3 id="处理不同的异常"><a class="header" href="#处理不同的异常">处理不同的异常</a></h3>
<p>在捕获异常的过程中，可能捕获到的异常有很多种，那么不同的异常的处理方式也应该有所不同，因为一旦提示的异常处理方式秒妥当，对程序的运行不会有帮助。</p>
<p>在<code>except</code>语句的后面可以加上要处理的异常的名字，如<code>ValueError</code>、<code>ZeroDivisionError</code>等等。</p>
<pre><code class="language-python">try:
    a = &quot;a&quot;
    b = 0

    if a+b!=100:
        raise Exception(&quot;a+b is not 100&quot;)
    c = a / b
except ValueError:
    print(&quot;赋值错误！&quot;)
except ZeroDivisionError:
    print(&quot;除数不能为零！&quot;)
except:
    print(&quot;其它异常&quot;)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="排序算法"><a class="header" href="#排序算法">排序算法</a></h2>
<p>常见的排序算法有：冒泡排序，选择排序，插入排序，桶排序，快速排序。</p>
<h3 id="数据准备"><a class="header" href="#数据准备">数据准备</a></h3>
<pre><code class="language-python">import random as r
n = int(input(&quot;请输入列表元素的个数：&quot;))
lst = []
for i in range(n):
    a = r.randint(-200, 200)
    while a in lst:
        a = r.randint(-200, 200)
    lst.append(a)
</code></pre>
<h3 id="冒泡排序"><a class="header" href="#冒泡排序">冒泡排序</a></h3>
<p>冒泡排序（Bubble Sort）是一种简单直观的排序算法。它重复地走访过要排序的列表，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访列表的工作是重复地进行直到没有再需要交换，也就是说该列表已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢&quot;浮&quot;到列表的顶端。</p>
<ol>
<li>需要比较的过程需要 <code>len(lst) - 1</code>轮</li>
<li>每一轮比较，需要从第一位开始，与当前位置的后面一个元素进行比较，如果排序排序错误，则交换</li>
<li>每一轮比较需要到哪一位结束？ 假设列表中有7个数据
len(lst) = 7 <br/>
第一轮 i = 0，比较到第6个元素，即最后遍历的索引 j = len(lst) - 1 - 1 <br/>
第二轮 i = 1，比较到第5个元素，即最后遍历的索引 j = len(lst) - 1 - 2 <br/>
第三轮 i = 2，比较到第4个元素，即最后遍历的索引 j = len(lst) - 1 - 3 <br/>
第四轮 i = 3，比较到第3个元素，即最后遍历的索引 j = len(lst) - 1 - 4 <br/>
第五轮 i = 4，比较到第2个元素，即最后遍历的索引 j = len(lst) - 1 - 5 <br/>
第六轮 i = 5，比较到第1个元素，即最后遍历的索引 j = len(lst) - 1 - 6 <br/></li>
</ol>
<pre><code class="language-python">import random as r
n = int(input(&quot;请输入列表元素的个数：&quot;))
lst = []
for i in range(n):
    a = r.randint(-200, 200)
    while a in lst:
        a = r.randint(-200, 200)
    lst.append(a)
    
for i in range(len(lst) - 1):
    for j in range(len(lst) - 1 - i):
        if lst[j] &gt; lst[j+1]:
           lst[j], lst[j+1] = lst[j+1], lst[j]

</code></pre>
<pre><code class="language-python">def bubble_sort(ls, reverse=False):
    n = len(ls)
    for i in range(n-1):
        for j in range(n-1-i):
            if reverse:
                if ls[j] &lt; ls[j+1]:
                    ls[j], ls[j+1] = ls[j+1], ls[j]
            else:
                if ls[j] &gt; ls[j+1]:
                    ls[j], ls[j+1] = ls[j+1], ls[j]
            print(ls)

if __name__ == '__main__':
    print(lst)
    bubble_sort(lst, True)
    print(lst)

&quot;&quot;&quot;
请输入列表元素的个数：10
[-125, 92, 6, 23, -147, 161, -20, 121, 127, 148]
[161, 148, 127, 121, 92, 23, 6, -20, -125, -147]
&quot;&quot;&quot;
</code></pre>
<h3 id="选择排序"><a class="header" href="#选择排序">选择排序</a></h3>
<p>选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<p>步骤：</p>
<ol>
<li>首先默认第一个位置的值最小(大)；</li>
<li>再依次和后面的数进行比较，如果有比当前最小值还要小(大)的数，则重新定义最小值的位置，直到最后一个位置判断结束；</li>
<li>将最小值位置上的数和第一个位置上的数交换；</li>
<li>依次对后面的位置进行上述操作。</li>
</ol>
<pre><code class="language-python">
for i in range(len(lst) - 1):
   minv = i
   for j in range(i+1, len(lst)):
      if lst[j] &lt; lst[minv]:
         minv = j
   if minv != i:
      lst[minv], lst[i] = lst[i], lst[minv]


</code></pre>
<pre><code class="language-python">def selection_sort(ls, reverse=False):
    n = len(ls)
    for i in range(n - 1):
        flag = i
        for j in range(i + 1, n):
            if reverse:
                if ls[flag] &lt; ls[j]:
                    flag = j
            else:
                if ls[flag] &gt; ls[j]:
                    flag = j
        ls[i], ls[flag] = ls[flag], ls[i]
        print(ls)
</code></pre>
<p>选择排序有另外一种写法，效率会低于上面一种：</p>
<pre><code class="language-python">def selection_sort(ls, reverse=False):
    n = len(ls)
    for i in range(n - 1):
        for j in range(i + 1, n):
            if reverse:
                if ls[i] &lt; ls[j]:
                    ls[i], ls[j] = ls[j], ls[i]
            else:
                if ls[i] &gt; ls[j]:
                    ls[i], ls[j] = ls[j], ls[i]
        print(ls)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="查找"><a class="header" href="#查找">查找</a></h2>
<p>查找要学习的主要内容有两个：顺序查找和二分法查找。</p>
<h3 id="数据准备-1"><a class="header" href="#数据准备-1">数据准备</a></h3>
<pre><code class="language-python">import random as r
n = int(input(&quot;请输入列表元素的个数：&quot;))
lst = []
for i in range(n):
    a = r.randint(-200, 200)
    while a in lst:
        a = r.randint(-200, 200)
    lst.append(a)
</code></pre>
<h3 id="顺序查找"><a class="header" href="#顺序查找">顺序查找</a></h3>
<p>顺序查找也叫线性查找， 是指按一定的顺序检查列表中每一个元素，直到找到所要寻找的特定值为止。
这里需要对列表的值进行循环遍历：</p>
<pre><code class="language-python">def sequence_search(ls, x):
    for i in ls:
        if i == x:
            return True
    return False

if sequence_search(lst, 100):
    print(&quot;100找到了。&quot;)
else:
    print(&quot;没有在列表里找到100&quot;)
</code></pre>
<h3 id="二分法查找"><a class="header" href="#二分法查找">二分法查找</a></h3>
<p>二分法查找的主要思想就是将列表进行折半查找，通过不断折半的过程来确定要查找的关键字所在的区域。</p>
<ol>
<li>先将列表进行正序排序;</li>
<li>设置起始和末尾结点<code>start</code>、<code>end</code>，然后得到中间结点<code>mid</code>， <code>mid = (start + end) // 2</code>;</li>
<li>如果中间结点的值大于要查找的关键字<code>key</code>，则设置<code>end = mid - 1</code>，反之，如果中间结点的值小于要查找的关键字<code>key</code>，则设置<code>start = mid + 1</code>;</li>
<li>再次计算<code>mid = (start + end) // 2</code>;</li>
<li>重复3和4直到找到关键字或者<code>start</code>和<code>end</code>相遇。</li>
</ol>
<pre><code class="language-python">key = 
lst.sort()
start = 0
end = len(lst) - 1
flag = False

while start &lt; end:
    mid = (start + end) // 2
    if lst[mid] &gt; key:
        end = mid - 1
    elif lst[mid] &lt; key:
        start = mid + 1
    else:
        flag = True
        break

if flag:
    print(key)
else:
    print('Not found.')

</code></pre>
<pre><code class="language-python">def binary_search(ls, key):
    ls.sort()
    start = 0
    end = len(ls) - 1
    mid = (start + end) // 2
    while start &lt; end:
        if ls[mid] &gt; key:
            end = mid - 1
        if ls[mid] &lt; key:
            start = mid + 1
        if ls[mid] == key:
            return True
        mid = (start + end) // 2
    return False
</code></pre>
<h4 id="利用二分法查找求平方根"><a class="header" href="#利用二分法查找求平方根">利用二分法查找求平方根</a></h4>
<p>要利用二分法的算法求平方根，需要注意的是一个正数的平方根是一定存在的，假设求一个有<strong>两位</strong>小数的平方根，大致的步骤如下 ：</p>
<ol>
<li>设置起始和末尾节点<code>start</code>、<code>end</code>，如果这个数<code>key</code>大于<code>1</code>, 则<code>start = 1</code>，<code>end = key</code>; 如果<code>key</code>小于1，则<code>start = key</code>， <code>end = 1</code>；</li>
<li>计算<code>mid = (start + end) / 2</code></li>
<li>如果<code>mid * mid</code>的结果与<code>key</code>的差值的绝对值小于<code>0.0001</code>，则确定<code>mid</code>为<code>key</code>的平方根；</li>
<li>如果<code>mid * mid</code>大于<code>key</code>， 则设置<code>end = mid</code>，反之设置<code>start = mid</code>; </li>
<li>再次计算<code>mid = (start + end) / 2</code>; </li>
<li>重复4和5直到找到平方根为止。</li>
</ol>
<pre><code class="language-python">key = float(input(&quot;请输出一个有两位小数的浮点数：&quot;))

if key &gt; 1:
    start = 1
    end = key
else:
    start = key
    end = 1
mid = (start + end) / 2

while abs(mid * mid - key) &gt; 0.0001:
    if mid * mid &gt; key:
        end = mid
    if mid * mid &lt; key:
        start = mid
    mid = (start + end) / 2

print(round(mid, 2))

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="内建模块"><a class="header" href="#内建模块">内建模块</a></h1>
<p>在 <strong>Python</strong> 中，模块（<strong>Module</strong>）是一个包含 <code>Python</code> 代码的文件，它提供了许多有用的函数、类、变量和可执行代码，使得我们能够更高效地进行编程。模块的作用是组织代码，将功能封装起来，便于代码复用和管理。</p>
<h2 id="模块简介"><a class="header" href="#模块简介">模块简介</a></h2>
<ul>
<li><strong>定义</strong>：模块是一个包含 Python 代码的文件，通常以 <code>.py</code> 为文件扩展名。</li>
<li><strong>作用</strong>：模块使得程序更加简洁、可维护和高效。通过模块，可以将不同的功能组织到不同的文件中，从而使代码更加模块化，避免重复代码，并提高可读性。</li>
<li><strong>示例</strong>：<code>math</code>、<code>os</code>、<code>sys</code>、<code>datetime</code>、<code>random</code> 等都是 Python 中的标准库模块。</li>
</ul>
<p><code>Python</code>提供了大量的内建模块供开发者们使用，每一个模块都能在特定的方向上发挥很大的作用。在初级学习阶段，可以先对下面几个相对简单的模块进行学习。</p>
<ol>
<li><strong>math</strong> 模块提供了很多数学函数，比如计算平方根、指数、对数、三角函数等，可以帮助我们做各种数学运算。</li>
<li><strong>random</strong> 模块可以生成随机数，帮助我们在编程中模拟随机事件，比如随机选择一个数字或者打乱一个列表中的元素。</li>
<li><strong>time</strong> 模块帮助我们处理时间相关的操作，比如暂停程序一段时间（<code>sleep()</code>），或者获取当前的时间。</li>
<li><strong>datetime</strong> 模块则更强大一些，它可以让我们处理日期和时间，像是计算两个日期之间的差距，或者格式化显示时间。</li>
<li><strong>csv</strong> 模块用来读写 CSV 文件，这是一种简单的表格数据格式，我们可以通过它来导入和导出数据。</li>
</ol>
<h3 id="模块的导入"><a class="header" href="#模块的导入">模块的导入</a></h3>
<p>在本教程的初期，我们在学习海龟画图模块<code>turtle</code>过程中，在<a href="25.%E5%B8%B8%E7%94%A8%E5%86%85%E5%BB%BA%E6%A8%A1%E5%9D%97/../07.%E6%B5%B7%E9%BE%9F%E7%94%BB%E5%9B%BE/%E6%B5%B7%E9%BE%9F%E7%94%BB%E5%9B%BE%E4%B8%80.html#%E5%AF%BC%E5%85%A5%E6%A8%A1%E5%9D%97">海龟画图一</a>对模块的导入作了介绍。这里以<code>math</code>模块为例，再次回顾一下导入模块的方式。</p>
<ol>
<li>最基本的导入及调用其中的函数或者对象的方式：</li>
</ol>
<pre><code class="language-python">import math
print(math.sqrt(100))
</code></pre>
<ol start="2">
<li>带别名<code>alias</code>的导入及调用其中的函数或者对象的方式：</li>
</ol>
<pre><code class="language-python">import math as m
print(m.sqrt(100))
</code></pre>
<ol start="3">
<li>从模块中导入特定的函数或者对象:</li>
</ol>
<pre><code class="language-python">from math import sqrt
print(sqrt(100))
</code></pre>
<p><strong>这里我们再次建议用第二种方式；不建议用第一种方式的原因是有些模块的名字会很长，在编写代码时应用起来不太方便；而对于第三种方式而言，需要特别注意不要从不同模块导入有相同名字的对象或函数，也不要编写同名的自定义函数，所以在初期学习阶段并不建议。</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="内建模块-1"><a class="header" href="#内建模块-1">内建模块</a></h1>
<p>在 <strong>Python</strong> 中，模块（<strong>Module</strong>）是一个包含 <code>Python</code> 代码的文件，它提供了许多有用的函数、类、变量和可执行代码，使得我们能够更高效地进行编程。模块的作用是组织代码，将功能封装起来，便于代码复用和管理。</p>
<h2 id="模块简介-1"><a class="header" href="#模块简介-1">模块简介</a></h2>
<ul>
<li><strong>定义</strong>：模块是一个包含 Python 代码的文件，通常以 <code>.py</code> 为文件扩展名。</li>
<li><strong>作用</strong>：模块使得程序更加简洁、可维护和高效。通过模块，可以将不同的功能组织到不同的文件中，从而使代码更加模块化，避免重复代码，并提高可读性。</li>
<li><strong>示例</strong>：<code>math</code>、<code>os</code>、<code>sys</code>、<code>datetime</code>、<code>random</code> 等都是 Python 中的标准库模块。</li>
</ul>
<p><code>Python</code>提供了大量的内建模块供开发者们使用，每一个模块都能在特定的方向上发挥很大的作用。在初级学习阶段，可以先对下面几个相对简单的模块进行学习。</p>
<ol>
<li><strong>math</strong> 模块提供了很多数学函数，比如计算平方根、指数、对数、三角函数等，可以帮助我们做各种数学运算。</li>
<li><strong>random</strong> 模块可以生成随机数，帮助我们在编程中模拟随机事件，比如随机选择一个数字或者打乱一个列表中的元素。</li>
<li><strong>time</strong> 模块帮助我们处理时间相关的操作，比如暂停程序一段时间（<code>sleep()</code>），或者获取当前的时间。</li>
<li><strong>datetime</strong> 模块则更强大一些，它可以让我们处理日期和时间，像是计算两个日期之间的差距，或者格式化显示时间。</li>
<li><strong>csv</strong> 模块用来读写 CSV 文件，这是一种简单的表格数据格式，我们可以通过它来导入和导出数据。</li>
</ol>
<h3 id="模块的导入-1"><a class="header" href="#模块的导入-1">模块的导入</a></h3>
<p>在本教程的初期，我们在学习海龟画图模块<code>turtle</code>过程中，在<a href="25.%E5%B8%B8%E7%94%A8%E5%86%85%E5%BB%BA%E6%A8%A1%E5%9D%97/../07.%E6%B5%B7%E9%BE%9F%E7%94%BB%E5%9B%BE/%E6%B5%B7%E9%BE%9F%E7%94%BB%E5%9B%BE%E4%B8%80.html#%E5%AF%BC%E5%85%A5%E6%A8%A1%E5%9D%97">海龟画图一</a>对模块的导入作了介绍。这里以<code>math</code>模块为例，再次回顾一下导入模块的方式。</p>
<ol>
<li>最基本的导入及调用其中的函数或者对象的方式：</li>
</ol>
<pre><code class="language-python">import math
print(math.sqrt(100))
</code></pre>
<ol start="2">
<li>带别名<code>alias</code>的导入及调用其中的函数或者对象的方式：</li>
</ol>
<pre><code class="language-python">import math as m
print(m.sqrt(100))
</code></pre>
<ol start="3">
<li>从模块中导入特定的函数或者对象:</li>
</ol>
<pre><code class="language-python">from math import sqrt
print(sqrt(100))
</code></pre>
<p><strong>这里我们再次建议用第二种方式；不建议用第一种方式的原因是有些模块的名字会很长，在编写代码时应用起来不太方便；而对于第三种方式而言，需要特别注意不要从不同模块导入有相同名字的对象或函数，也不要编写同名的自定义函数，所以在初期学习阶段并不建议。</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="math"><a class="header" href="#math">math</a></h1>
<p><code>Python</code> 的 <code>math</code> 模块是一个提供数学运算函数和常量的标准库。它提供了广泛的数学功能，从基本的算术运算到更复杂的高级数学函数，如三角函数、对数函数、复数运算等。对于需要进行数值计算的程序来说，<code>math</code> 模块是一个非常有用的工具。</p>
<p>本教程面向的年龄段偏低，所以这里只介绍一些简单的函数和常量。</p>
<h3 id="常量"><a class="header" href="#常量">常量</a></h3>
<ul>
<li><code>math.pi</code>: 圆周率，值约为<code>3.141592653589793</code></li>
<li><code>math.e</code>: 自然对数的底数，也叫自然常数，值约为<code>2.718281828459045</code></li>
<li><code>math.inf</code>：表示无穷大</li>
<li><code>math.nan</code>: 表示<code>不是一个数字（NAN）</code></li>
</ul>
<h3 id="基本算术运算"><a class="header" href="#基本算术运算">基本算术运算</a></h3>
<p>在下面介绍的<code>math</code>模块中的函数，基本的算术运算都是在实数范围内的，即所有的数 <code>x</code>都属于 <code>R</code>.</p>
<p>$$ x \in \mathbb{R} $$</p>
<table><thead><tr><th>函数名</th><th>说明</th><th>返回值</th></tr></thead><tbody>
<tr><td><code>sqrt(x)</code></td><td>返回<code>x</code>的平方根，如果<code>x</code>是负数，会抛出 <code>ValueError</code></td><td>浮点型</td></tr>
<tr><td><code>pow(x, y)</code></td><td>返回<code>x</code>的<code>y</code>次方。</td><td>浮点型</td></tr>
<tr><td><code>fmod(x, y)</code></td><td>返回<code>x</code>除以<code>y</code>的余数。</td><td>浮点型</td></tr>
<tr><td><code>ceil(x)</code></td><td>返回大于等于<code>x</code>的最小整数，向上取整</td><td>整型</td></tr>
<tr><td><code>floor(x)</code></td><td>返回小于等于<code>x</code>的最大整数，向下取整</td><td>整型</td></tr>
<tr><td><code>trunc(x)</code></td><td>返回<code>x</code>的整数部分，去掉小数部分</td><td>整型</td></tr>
</tbody></table>
<h4 id="sqrt"><a class="header" href="#sqrt">sqrt</a></h4>
<p>上面已经提到过了，<code>math</code>模块只针对实数范围内的数，所以<code>sqrt</code>的参数<code>x</code>必须为正数才可以得出一个返回值。</p>
<pre><code class="language-python">&gt;&gt;&gt; import math as m
&gt;&gt;&gt; print(m.sqrt(100))
10.0
</code></pre>
<h4 id="pow"><a class="header" href="#pow">pow</a></h4>
<p><code>pow</code>的功能与运算符<code>**</code>相同，但是它只会返回浮点数。</p>
<pre><code class="language-python">&gt;&gt;&gt; import math as m
&gt;&gt;&gt; print(m.pow(10, 2))
100.0
&gt;&gt;&gt; print(10**2)
100
</code></pre>
<h4 id="fmod"><a class="header" href="#fmod">fmod</a></h4>
<p><code>fmod</code>的功能与<code>%</code>相同，但是它也只会返回浮点数。</p>
<pre><code class="language-python">&gt;&gt;&gt; import math as m
&gt;&gt;&gt; print(m.fmod(10, 4))
2.0
&gt;&gt;&gt; print(10%4)
2
</code></pre>
<p>另外，运算符<code>%</code>的结果符号是要与除数保持一致的，但<code>fmod</code>则正好相反，返回值的符号与被除数一致。</p>
<pre><code class="language-python">&gt;&gt;&gt; print(m.fmod(10, -3))
1.0
&gt;&gt;&gt; print(m.fmod(-10, 3))
-1.0
&gt;&gt;&gt; print(10 % (-3))
-2
&gt;&gt;&gt; print(-10 % 3)
2
</code></pre>
<h4 id="取整函数-ceil--floor--trunc"><a class="header" href="#取整函数-ceil--floor--trunc">取整函数 ceil / floor / trunc</a></h4>
<p>需要特别注意的是，这几个对数值取整的函数并不是进行四舍五入，所以不要与内置函数<code>round</code>混淆。</p>
<pre><code class="language-python">&gt;&gt;&gt; import math as m
&gt;&gt;&gt; print(m.ceil(4.3))
5
&gt;&gt;&gt; print(m.floor(4.7))
4
&gt;&gt;&gt; print(m.trunc(4.22))
4
</code></pre>
<h3 id="三角函数"><a class="header" href="#三角函数">三角函数</a></h3>
<p>在<code>math</code>模块的三角函数中，参数<code>x</code>以弧度为单位。</p>
<p>常量<code>math.pi</code>代表了数学中的<code>π</code>，一个<code>π</code> 表示角度中的180度。</p>
<table><thead><tr><th>函数名</th><th>说明</th><th>返回值</th></tr></thead><tbody>
<tr><td><code>sin(x)</code></td><td>返回<code>x</code>的正弦值</td><td>浮点型</td></tr>
<tr><td><code>cos(x)</code></td><td>返回<code>x</code>的余弦值</td><td>浮点型</td></tr>
<tr><td><code>tan(x)</code></td><td>返回<code>x</code>的正切值</td><td>浮点型</td></tr>
<tr><td><code>degrees(x)</code></td><td>将弧度<code>x</code>转换为角度</td><td>浮点型</td></tr>
<tr><td><code>radians(x)</code></td><td>将角度<code>x</code>转换为弧度</td><td>浮点数</td></tr>
</tbody></table>
<pre><code class="language-python">&gt;&gt;&gt; import math as m
&gt;&gt;&gt; print(m.sin(m.pi / 6)) # 30度角的正弦
0.49999999999999994
&gt;&gt;&gt; print(m.cos(m.pi / 3)) # 60度角的余弦
0.5000000000000001
&gt;&gt;&gt; print(m.tan(m.pi / 4)) # 45度角的正切
0.9999999999999999
&gt;&gt;&gt; print(m.degrees(m.pi))
180.0
&gt;&gt;&gt; print(m.radians(180))
3.141592653589793
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="time"><a class="header" href="#time">time</a></h1>
<p><code>time</code>模块提供了一些与系统时间、操作系统和时间相关的函数，主要用于执行低级别的时间操作，比如等待或者暂停。</p>
<h2 id="主要函数"><a class="header" href="#主要函数">主要函数</a></h2>
<h3 id="time-1"><a class="header" href="#time-1">time()</a></h3>
<p>返回当前时间的时间戳（以秒为单位）。表示从1970年1月1日以来的秒数。具体的起始小时以时区为主.</p>
<pre><code class="language-python">import time as t
print(t.time())
</code></pre>
<h3 id="sleepseconds"><a class="header" href="#sleepseconds">sleep(seconds)</a></h3>
<p>使程序暂停指定的秒数。在编写程序时常用于模拟延时、等待某些操作。这个函数没有返回值。</p>
<pre><code class="language-python">import time as t
print(&quot;Start&quot;)
t.sleep(2)
print(&quot;End&quot;)
</code></pre>
<h3 id="localtimeseconds"><a class="header" href="#localtimeseconds">localtime([seconds])</a></h3>
<p>返回当前本地时间的<code>struct_time</code>对象。如果给定了<code>seconds</code>参数，则将其转换为本地时间，否则返回当前时间。</p>
<pre><code class="language-python">import time as t
local_time = t.localtime()
print(local_time)
ca_time = t.localtime(1734689541.446833)
print(ca_time)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p><code>os</code>模块提供了与操作系统交互的功能，能够处理文件和目录的创建、删除、路径操作等。</p>
<h2 id="常用功能"><a class="header" href="#常用功能">常用功能</a></h2>
<ul>
<li><strong>os.name</strong>： 获取操作系统的名称。<code>posix</code>表示类<code>Unix</code>系统，<code>nt</code>表示<code>Windows</code>系统。</li>
</ul>
<pre><code class="language-python">&gt;&gt;&gt; import os
&gt;&gt;&gt; print(os.name)
</code></pre>
<ul>
<li><strong>os.getcwd()</strong>：获取当前工作目录。</li>
</ul>
<pre><code class="language-python">&gt;&gt;&gt; print(os.getcwd())
</code></pre>
<ul>
<li><strong>os.chdir(path)</strong>：改变当前的工作目录，<code>chdir</code>即<code>change directory</code>.</li>
</ul>
<pre><code class="language-python">&gt;&gt;&gt; os.chdir('/Users/chris/Downloads')
</code></pre>
<ul>
<li><strong>os.listdir(path)</strong>：列出指定路径下的文件和目录。</li>
</ul>
<pre><code class="language-python">&gt;&gt;&gt; print(os.listdir('/Users/chris/Downloads'))
</code></pre>
<ul>
<li><strong>os.mkdir(path)和 os.makedirs(path)</strong>：创建单个目录和创建级联目录（递归创建）</li>
</ul>
<pre><code class="language-python">&gt;&gt;&gt; os.mkdir(&quot;ABC&quot;)
&gt;&gt;&gt; os.makedirs(&quot;A/B/C&quot;)
</code></pre>
<ul>
<li><strong>os.remove(path)和os.rmdir(path)</strong>：<code>os.remove</code>用于删除文件，<code>os.rmdir</code>用于删除空目录</li>
</ul>
<pre><code class="language-python">&gt;&gt;&gt; os.remove('C/testing.txt')
&gt;&gt;&gt; os.rmdir('C')
</code></pre>
<ul>
<li><strong>os.rename(old_name, new_name)</strong>：重命名文件或目录</li>
</ul>
<pre><code class="language-python">&gt;&gt;&gt; os.rename('ABC', 'DEF')
</code></pre>
<ul>
<li><strong>os.system(command)</strong>：执行操作系统的命令。返回值是命令的退出状态码。</li>
</ul>
<pre><code class="language-python">&gt;&gt;&gt; os.system(&quot;shutdown -h&quot;)
&gt;&gt;&gt; os.system(&quot;echo Hello World&quot;)
&gt;&gt;&gt; os.system(&quot;mkdir HIJ&quot;)
</code></pre>
<ul>
<li><strong>os.path</strong> 模块
<code>os.path</code>模块是<code>os</code>模块的子模块，提供了处理路径的函数。
-<code>os.path.join()</code>: 拼接路径。
-<code>os.path.exists()</code>：检查路径是否存在。
-<code>os.path.isdir()</code>：检查路径是否为目录。
-<code>os.path.isfile()</code>：检查路径是否为文件。
-<code>os.path.abspath()</code>：获取绝对路径。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p><code>Python</code> 中的面向对象编程（<code>Object-Oriented Programming</code>, <code>OOP</code>）是一种编程范式(<code>paradigm</code>)，它通过类和对象的概念来组织代码，使代码更具模块化、可重用性和可扩展性。</p>
<p>比如：一只小猫就是一个对象</p>
<ul>
<li><strong>属性</strong>：毛色、名字、年龄</li>
<li><strong>行为</strong>：喵喵叫、跳跃、吃饭</li>
</ul>
<h2 id="1-面向对象编程的核心概念"><a class="header" href="#1-面向对象编程的核心概念">1. 面向对象编程的核心概念</a></h2>
<p>面向对象编程的核心概念在于<strong>类</strong>和<strong>对象</strong></p>
<p><strong>类</strong>：模具的说明书，比如<code>汽车类</code>、<code>动物类</code>、<code>学生类</code>
<strong>对象</strong>：就像通过模具的说明书制造的实际汽车，每一辆车都是一个对象。</p>
<h3 id="类-class"><a class="header" href="#类-class">类 Class</a></h3>
<ul>
<li>类是创建对象的模板或蓝图，用来定义对象的属性和行为</li>
<li>使用关键字<code>class</code>定义类</li>
</ul>
<h3 id="对象-object"><a class="header" href="#对象-object">对象 object</a></h3>
<ul>
<li>对象是类的实例或实体，是类实际创建出来的实体。</li>
<li>对象包含了属性和方法</li>
</ul>
<h2 id="2-创建第一个类人物类"><a class="header" href="#2-创建第一个类人物类">2. 创建第一个类：人物类</a></h2>
<h3 id="定义类"><a class="header" href="#定义类">定义类</a></h3>
<pre><code class="language-python">class Person:
	pass
</code></pre>
<h3 id="创建对象"><a class="header" href="#创建对象">创建对象</a></h3>
<pre><code class="language-python">person1 = Person()
person2 = Person()
</code></pre>
<p>类就是模板<code>Model</code>， <code>person1</code>和 <code>person2</code>是由这个<code>Model</code> 创建的对象</p>
<h3 id="为类添加属性"><a class="header" href="#为类添加属性">为类添加属性</a></h3>
<p><strong>类的属性（Class Attributes）</strong> 是指类内部定义的变量，它可以被类的所有对象(<code>object</code>&lt;实例<code>instance</code>&gt;)共享。对于一个<code>Person</code>来说，它需要有的具体属性有<strong>名字</strong>、<strong>年龄</strong>等。</p>
<pre><code class="language-python">class Person:

	def __init__(self, name, age):
		self.name = name
		self.age = age
</code></pre>
<ul>
<li><code>__init__</code>是类的<strong>构造方法</strong>（<code>constrctor</code>), 用于在类的对象被创建时自动调用，完成对象的初始化操作。<code>init</code>是<code>initialize</code>的缩写。</li>
<li><code>self</code>表示这个对象本身， 主要作用是允许类的对象访问和修改对象的属性。</li>
</ul>
<pre><code class="language-python">class Person:

	def __init__(self, name, age):
		self.name = name
		self.age = age

	def greet(self):
		print(f&quot;Nice to meet you. My name is {self.name} and I'm {self.age} years old.&quot;)
</code></pre>
<h4 id="示例"><a class="header" href="#示例">示例</a></h4>
<h4 id="题目-1计算圆的属性"><a class="header" href="#题目-1计算圆的属性"><strong>题目 1：计算圆的属性</strong></a></h4>
<p><strong>要求：</strong><br />
创建一个类 <code>Circle</code>，用来表示一个圆。该类应包含以下功能：</p>
<ol>
<li>初始化方法，接受半径作为参数。</li>
<li>一个方法 <code>area()</code>，返回圆的面积（用 <code>math.pi</code>）。</li>
<li>一个方法 <code>circumference()</code>，返回圆的周长。</li>
</ol>
<p><strong>提示：</strong><br />
使用 <code>random.randint()</code> 生成随机数。</p>
<pre><code class="language-python">from math import pi

class Circle:

	def __init__(self, radius):
		self._radius_ = radius

	def area(self):
		a = pi * self._radius_ * self._radius_
		return a

	def circumference(self):
		return 2 * pi * self._radius_
</code></pre>
<h4 id="题目-2计时器类"><a class="header" href="#题目-2计时器类"><strong>题目 2：计时器类</strong></a></h4>
<p><strong>要求：</strong><br />
创建一个类 <code>Timer</code>，实现以下功能：</p>
<ol>
<li>初始化方法，不需要参数。</li>
<li>一个方法 <code>start()</code>，记录当前时间为开始时间。</li>
<li>一个方法 <code>stop()</code>，记录当前时间为结束时间，并计算间隔时间。</li>
<li>一个方法 <code>elapsed()</code>，返回计时器运行的总时长，单位为秒。</li>
</ol>
<p><strong>提示：</strong><br />
使用 <code>time.time()</code> 获取当前时间戳。</p>
<pre><code class="language-python">import time

class Timer:

    def __init__(self):

        self.stime = 0
        self.etime = 0
        self.duration = 0
    
    def start(self):
        self.stime = time.time()

    def stop(self):
        self.etime = time.time()
        self.duration = self.etime - self.stime
          
    def elapsed(self):
        return self.duration



t = Timer()

t.start()
time.sleep(2)
t.stop()
print(t.elapsed())

</code></pre>
<h4 id="题目-3倒计时工具"><a class="header" href="#题目-3倒计时工具"><strong>题目 3：倒计时工具</strong></a></h4>
<p><strong>要求：</strong><br />
创建一个类 <code>Countdown</code>，实现一个简单的倒计时功能：</p>
<ol>
<li>初始化方法，接受倒计时的秒数作为参数。</li>
<li>一个方法 <code>start()</code>，从指定的秒数开始倒计时到 0，每秒打印当前剩余秒数（用 <code>time.sleep(1)</code>）。</li>
<li>倒计时结束后打印 <code>&quot;Time's up!&quot;</code>。</li>
</ol>
<p><strong>提示：</strong><br />
使用 <code>time.sleep()</code> 来暂停 1 秒。</p>
<pre><code class="language-python">import time

class Countdown:

	def __init__(self, sec):
		self.second = sec

	def start(self):
		for i in range(self.second, -1, -1):
			print(i)
			time.sleep(1)
		print(&quot;Time's up!&quot;)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p><code>Python</code> 中的面向对象编程（<code>Object-Oriented Programming</code>, <code>OOP</code>）是一种编程范式(<code>paradigm</code>)，它通过类和对象的概念来组织代码，使代码更具模块化、可重用性和可扩展性。</p>
<p>比如：一只小猫就是一个对象</p>
<ul>
<li><strong>属性</strong>：毛色、名字、年龄</li>
<li><strong>行为</strong>：喵喵叫、跳跃、吃饭</li>
</ul>
<h2 id="1-面向对象编程的核心概念-1"><a class="header" href="#1-面向对象编程的核心概念-1">1. 面向对象编程的核心概念</a></h2>
<p>面向对象编程的核心概念在于<strong>类</strong>和<strong>对象</strong></p>
<p><strong>类</strong>：模具的说明书，比如<code>汽车类</code>、<code>动物类</code>、<code>学生类</code>
<strong>对象</strong>：就像通过模具的说明书制造的实际汽车，每一辆车都是一个对象。</p>
<h3 id="类-class-1"><a class="header" href="#类-class-1">类 Class</a></h3>
<ul>
<li>类是创建对象的模板或蓝图，用来定义对象的属性和行为</li>
<li>使用关键字<code>class</code>定义类</li>
</ul>
<h3 id="对象-object-1"><a class="header" href="#对象-object-1">对象 object</a></h3>
<ul>
<li>对象是类的实例或实体，是类实际创建出来的实体。</li>
<li>对象包含了属性和方法</li>
</ul>
<h2 id="2-创建第一个类人物类-1"><a class="header" href="#2-创建第一个类人物类-1">2. 创建第一个类：人物类</a></h2>
<h3 id="定义类-1"><a class="header" href="#定义类-1">定义类</a></h3>
<pre><code class="language-python">class Person:
	pass
</code></pre>
<h3 id="创建对象-1"><a class="header" href="#创建对象-1">创建对象</a></h3>
<pre><code class="language-python">person1 = Person()
person2 = Person()
</code></pre>
<p>类就是模板<code>Model</code>， <code>person1</code>和 <code>person2</code>是由这个<code>Model</code> 创建的对象</p>
<h3 id="为类添加属性-1"><a class="header" href="#为类添加属性-1">为类添加属性</a></h3>
<p><strong>类的属性（Class Attributes）</strong> 是指类内部定义的变量，它可以被类的所有对象(<code>object</code>&lt;实例<code>instance</code>&gt;)共享。对于一个<code>Person</code>来说，它需要有的具体属性有<strong>名字</strong>、<strong>年龄</strong>等。</p>
<pre><code class="language-python">class Person:

	def __init__(self, name, age):
		self.name = name
		self.age = age
</code></pre>
<ul>
<li><code>__init__</code>是类的<strong>构造方法</strong>（<code>constrctor</code>), 用于在类的对象被创建时自动调用，完成对象的初始化操作。<code>init</code>是<code>initialize</code>的缩写。</li>
<li><code>self</code>表示这个对象本身， 主要作用是允许类的对象访问和修改对象的属性。</li>
</ul>
<pre><code class="language-python">class Person:

	def __init__(self, name, age):
		self.name = name
		self.age = age

	def greet(self):
		print(f&quot;Nice to meet you. My name is {self.name} and I'm {self.age} years old.&quot;)
</code></pre>
<h4 id="示例-1"><a class="header" href="#示例-1">示例</a></h4>
<h4 id="题目-1计算圆的属性-1"><a class="header" href="#题目-1计算圆的属性-1"><strong>题目 1：计算圆的属性</strong></a></h4>
<p><strong>要求：</strong><br />
创建一个类 <code>Circle</code>，用来表示一个圆。该类应包含以下功能：</p>
<ol>
<li>初始化方法，接受半径作为参数。</li>
<li>一个方法 <code>area()</code>，返回圆的面积（用 <code>math.pi</code>）。</li>
<li>一个方法 <code>circumference()</code>，返回圆的周长。</li>
</ol>
<p><strong>提示：</strong><br />
使用 <code>random.randint()</code> 生成随机数。</p>
<pre><code class="language-python">from math import pi

class Circle:

	def __init__(self, radius):
		self._radius_ = radius

	def area(self):
		a = pi * self._radius_ * self._radius_
		return a

	def circumference(self):
		return 2 * pi * self._radius_
</code></pre>
<h4 id="题目-2计时器类-1"><a class="header" href="#题目-2计时器类-1"><strong>题目 2：计时器类</strong></a></h4>
<p><strong>要求：</strong><br />
创建一个类 <code>Timer</code>，实现以下功能：</p>
<ol>
<li>初始化方法，不需要参数。</li>
<li>一个方法 <code>start()</code>，记录当前时间为开始时间。</li>
<li>一个方法 <code>stop()</code>，记录当前时间为结束时间，并计算间隔时间。</li>
<li>一个方法 <code>elapsed()</code>，返回计时器运行的总时长，单位为秒。</li>
</ol>
<p><strong>提示：</strong><br />
使用 <code>time.time()</code> 获取当前时间戳。</p>
<pre><code class="language-python">import time

class Timer:

    def __init__(self):

        self.stime = 0
        self.etime = 0
        self.duration = 0
    
    def start(self):
        self.stime = time.time()

    def stop(self):
        self.etime = time.time()
        self.duration = self.etime - self.stime
          
    def elapsed(self):
        return self.duration



t = Timer()

t.start()
time.sleep(2)
t.stop()
print(t.elapsed())

</code></pre>
<h4 id="题目-3倒计时工具-1"><a class="header" href="#题目-3倒计时工具-1"><strong>题目 3：倒计时工具</strong></a></h4>
<p><strong>要求：</strong><br />
创建一个类 <code>Countdown</code>，实现一个简单的倒计时功能：</p>
<ol>
<li>初始化方法，接受倒计时的秒数作为参数。</li>
<li>一个方法 <code>start()</code>，从指定的秒数开始倒计时到 0，每秒打印当前剩余秒数（用 <code>time.sleep(1)</code>）。</li>
<li>倒计时结束后打印 <code>&quot;Time's up!&quot;</code>。</li>
</ol>
<p><strong>提示：</strong><br />
使用 <code>time.sleep()</code> 来暂停 1 秒。</p>
<pre><code class="language-python">import time

class Countdown:

	def __init__(self, sec):
		self.second = sec

	def start(self):
		for i in range(self.second, -1, -1):
			print(i)
			time.sleep(1)
		print(&quot;Time's up!&quot;)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p><code>Python</code> 中的面向对象编程（<code>Object-Oriented Programming</code>, <code>OOP</code>）是一种编程范式(<code>paradigm</code>)，它通过类和对象的概念来组织代码，使代码更具模块化、可重用性和可扩展性。</p>
<p>比如：一只小猫就是一个对象</p>
<ul>
<li><strong>属性</strong>：毛色、名字、年龄</li>
<li><strong>行为</strong>：喵喵叫、跳跃、吃饭</li>
</ul>
<h2 id="1-面向对象编程的核心概念-2"><a class="header" href="#1-面向对象编程的核心概念-2">1. 面向对象编程的核心概念</a></h2>
<p>面向对象编程的核心概念在于<strong>类</strong>和<strong>对象</strong></p>
<p><strong>类</strong>：模具的说明书，比如<code>汽车类</code>、<code>动物类</code>、<code>学生类</code>
<strong>对象</strong>：就像通过模具的说明书制造的实际汽车，每一辆车都是一个对象。</p>
<h3 id="类-class-2"><a class="header" href="#类-class-2">类 Class</a></h3>
<ul>
<li>类是创建对象的模板或蓝图，用来定义对象的属性和行为</li>
<li>使用关键字<code>class</code>定义类</li>
</ul>
<h3 id="对象-object-2"><a class="header" href="#对象-object-2">对象 object</a></h3>
<ul>
<li>对象是类的实例或实体，是类实际创建出来的实体。</li>
<li>对象包含了属性和方法</li>
</ul>
<h2 id="2-创建第一个类人物类-2"><a class="header" href="#2-创建第一个类人物类-2">2. 创建第一个类：人物类</a></h2>
<h3 id="定义类-2"><a class="header" href="#定义类-2">定义类</a></h3>
<pre><code class="language-python">class Person:
	pass
</code></pre>
<h3 id="创建对象-2"><a class="header" href="#创建对象-2">创建对象</a></h3>
<pre><code class="language-python">person1 = Person()
person2 = Person()
</code></pre>
<p>类就是模板<code>Model</code>， <code>person1</code>和 <code>person2</code>是由这个<code>Model</code> 创建的对象</p>
<h3 id="为类添加属性-2"><a class="header" href="#为类添加属性-2">为类添加属性</a></h3>
<p><strong>类的属性（Class Attributes）</strong> 是指类内部定义的变量，它可以被类的所有对象(<code>object</code>&lt;实例<code>instance</code>&gt;)共享。对于一个<code>Person</code>来说，它需要有的具体属性有<strong>名字</strong>、<strong>年龄</strong>等。</p>
<pre><code class="language-python">class Person:

	def __init__(self, name, age):
		self.name = name
		self.age = age
</code></pre>
<ul>
<li><code>__init__</code>是类的<strong>构造方法</strong>（<code>constrctor</code>), 用于在类的对象被创建时自动调用，完成对象的初始化操作。<code>init</code>是<code>initialize</code>的缩写。</li>
<li><code>self</code>表示这个对象本身， 主要作用是允许类的对象访问和修改对象的属性。</li>
</ul>
<pre><code class="language-python">class Person:

	def __init__(self, name, age):
		self.name = name
		self.age = age

	def greet(self):
		print(f&quot;Nice to meet you. My name is {self.name} and I'm {self.age} years old.&quot;)
</code></pre>
<h4 id="示例-2"><a class="header" href="#示例-2">示例</a></h4>
<h4 id="题目-1计算圆的属性-2"><a class="header" href="#题目-1计算圆的属性-2"><strong>题目 1：计算圆的属性</strong></a></h4>
<p><strong>要求：</strong><br />
创建一个类 <code>Circle</code>，用来表示一个圆。该类应包含以下功能：</p>
<ol>
<li>初始化方法，接受半径作为参数。</li>
<li>一个方法 <code>area()</code>，返回圆的面积（用 <code>math.pi</code>）。</li>
<li>一个方法 <code>circumference()</code>，返回圆的周长。</li>
</ol>
<p><strong>提示：</strong><br />
使用 <code>random.randint()</code> 生成随机数。</p>
<pre><code class="language-python">from math import pi

class Circle:

	def __init__(self, radius):
		self._radius_ = radius

	def area(self):
		a = pi * self._radius_ * self._radius_
		return a

	def circumference(self):
		return 2 * pi * self._radius_
</code></pre>
<h4 id="题目-2计时器类-2"><a class="header" href="#题目-2计时器类-2"><strong>题目 2：计时器类</strong></a></h4>
<p><strong>要求：</strong><br />
创建一个类 <code>Timer</code>，实现以下功能：</p>
<ol>
<li>初始化方法，不需要参数。</li>
<li>一个方法 <code>start()</code>，记录当前时间为开始时间。</li>
<li>一个方法 <code>stop()</code>，记录当前时间为结束时间，并计算间隔时间。</li>
<li>一个方法 <code>elapsed()</code>，返回计时器运行的总时长，单位为秒。</li>
</ol>
<p><strong>提示：</strong><br />
使用 <code>time.time()</code> 获取当前时间戳。</p>
<pre><code class="language-python">import time

class Timer:

    def __init__(self):

        self.stime = 0
        self.etime = 0
        self.duration = 0
    
    def start(self):
        self.stime = time.time()

    def stop(self):
        self.etime = time.time()
        self.duration = self.etime - self.stime
          
    def elapsed(self):
        return self.duration



t = Timer()

t.start()
time.sleep(2)
t.stop()
print(t.elapsed())

</code></pre>
<h4 id="题目-3倒计时工具-2"><a class="header" href="#题目-3倒计时工具-2"><strong>题目 3：倒计时工具</strong></a></h4>
<p><strong>要求：</strong><br />
创建一个类 <code>Countdown</code>，实现一个简单的倒计时功能：</p>
<ol>
<li>初始化方法，接受倒计时的秒数作为参数。</li>
<li>一个方法 <code>start()</code>，从指定的秒数开始倒计时到 0，每秒打印当前剩余秒数（用 <code>time.sleep(1)</code>）。</li>
<li>倒计时结束后打印 <code>&quot;Time's up!&quot;</code>。</li>
</ol>
<p><strong>提示：</strong><br />
使用 <code>time.sleep()</code> 来暂停 1 秒。</p>
<pre><code class="language-python">import time

class Countdown:

	def __init__(self, sec):
		self.second = sec

	def start(self):
		for i in range(self.second, -1, -1):
			print(i)
			time.sleep(1)
		print(&quot;Time's up!&quot;)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>继承<code>inherit</code>是对现有的类的扩展(<code>extension</code>)，实现对代码的重用和重写。</p>
<p>被继承的类叫作<code>父类（Super Class 或 Parent Class）</code>, 继承的类叫<code>子类(Subclass 或 Child)</code>.</p>
<ul>
<li><strong>父类</strong>就像是一个<code>基础模板 base model</code>或者<code>蓝图 blue print</code>，比如<code>动物类</code></li>
<li><strong>子类</strong>继承父类后，它自动拥有了父类的特性，但是可以添加更多的特性，或者修改父类的特性。例如<code>动物类</code>的子类可以<code>猫类</code>或<code>狗类</code>，它们都继承了<code>动物类</code>的行为，但是也有自己独特的行为。</li>
</ul>
<p>对于已经创建好的并开始被使用的类 <code>ClassA</code> 来说，有了新的要求需要做更改，但是对于<code>ClassA</code>来说，已经有对象创建了，并且这些对象并不需要新加的功能，所以需要用到继承来解决问题。</p>
<h2 id="继承动物类"><a class="header" href="#继承动物类">继承动物类</a></h2>
<p>在继承动物类之前，首先要有一个动物类才可以继承：</p>
<pre><code class="language-python">class Animal:

	def __init__(self, name, sound):
		self.name = name
		self.sound = sound

	def speak(self):
		print(f&quot;{self.name} makes a {self.sound} sound.&quot;)

animal = Animal('Tony', 'roar')
animal.speak()
</code></pre>
<p>有了动物类之后，就可以实现继承了，下面用<code>小狗类</code>举例</p>
<pre><code class="language-python">class Dog(Animal):
    pass

dog = Dog('Odie', 'bark')
dog.speak()
</code></pre>
<h3 id="子类对父类的扩展"><a class="header" href="#子类对父类的扩展">子类对父类的扩展</a></h3>
<p>在上面的例子中，<code>Dog</code>类完全继承了父类的属性和方法，在这个基础上， <code>Dog</code>也可以对父类进行扩展，比如新一个功能<code>catch</code>。</p>
<pre><code class="language-python">class Dog(Animal):

	def catch(self, obj):
		print(f&quot;I caught a {obj} that thrown by my master.&quot;)

dog = Dog('Odie', 'bark')
dog.speak()
</code></pre>
<p>``</p>
<h3 id="方法的重写"><a class="header" href="#方法的重写">方法的重写</a></h3>
<p>有时候，子类需要对父类的行为（方法）进行修改，这叫做<code>重写(Override)</code>。</p>
<pre><code class="language-python">class Cat(Animal):

	def speak(self):
		print(f&quot;{self.sound}, {self.sound}&quot;)	
</code></pre>
<p>重写之后，<code>Cat</code>的<code>speak</code>方法与父类已经完全不一样了</p>
<pre><code class="language-python">cat = Cat(&quot;Garfield&quot;, 'Meow~')
cat.speak()

# 打印结果为：Meow~, Meow~
</code></pre>
<p>重写可以针对父类的所有资源：</p>
<pre><code class="language-python">class Cat(Animal):

	def __init__(self, color):
		self.color = color

	def speak(self):
		print(f&quot;{self.sound}, {self.sound}&quot;)
</code></pre>
<p>对于上面的继承方式，<code>Cat</code>类放弃了父类的两个属性<code>name</code>和<code>sound</code>, 这样一来，<code>Cat</code>类里的<code>speak</code>方法就不能被成功调用。</p>
<p>如果在重写时想要保留父类原有的功能或属性，需要用到<code>super</code>关键字。</p>
<pre><code class="language-python">class Cat(Animal):

	def __init__(self, name, sound, color):
		super().__init__(name, sound)
		self.color = color

	def speak(self):
		super().speak()
		print(f&quot;{self.sound}, {self.sound}&quot;)
</code></pre>
<p><strong>方法的重写需要特别注意两个点：</strong></p>
<ol>
<li>重写时，需要完全继承父类方法，super()的<code>.</code>之后的名字要写正确。</li>
<li>不要忘记需要带入的参数，以及传值顺序。</li>
</ol>
<p>完整的例子如下：</p>
<pre><code class="language-python">class Animal:

    def __init__(self, name, sound):
        self.name = name
        self.sound = sound

    def speak(self):
        print(f&quot;{self.name} makes a {self.sound} sound.&quot;)

    def run(self):
        print(&quot;I am running.&quot;)

    def eat(self, food):
        print(f&quot;I am eating {food}.&quot;)


class Cat(Animal):
    
    def __init__(self, name, sound, color):
	super().__init__(name, sound)
	self.color = color

    def speak(self):
	super().speak()
	print(f&quot;{self.sound}, {self.sound}&quot;)
    
    def eat(self, food):
        super().run()
        print(&quot;Clean my face and hand&quot;)
        super().eat(food)
        print(&quot;Drink water.&quot;)
</code></pre>
<h2 id="多继承"><a class="header" href="#多继承">多继承</a></h2>
<p>多继承指的是一个类可以从多个父类继承属性和方法。</p>
<p>多继承的语法为：</p>
<pre><code class="language-python">class ChildClass(ParentClass1, ParentClass2, ...):
	pass
</code></pre>
<p>下面是一个全新的<code>动物类</code></p>
<pre><code class="language-python">class Animal:

	def alive(self):
		print(&quot;I am alive&quot;)

	def eat(self, food):
		print(&quot;I must eat to be alive.&quot;)

</code></pre>
<p>然后创建一个<code>鸟类</code>:</p>
<pre><code class="language-python">class Bird:

	def __init__(self):
		self.wings = 2
		self.legs = 2

	def fly(self):
		print(&quot;I can fly.&quot;)
</code></pre>
<p>对于小鸡，它既是动物又是鸟类，所以它可以多继承上面两个父类</p>
<pre><code class="language-python">
class Chicken(Animal, Bird):
	pass
</code></pre>
<p>在多继承的过程中，如果需要在重写或者扩展函数时，需要用<code>super</code>关键字来调用父类的方法，与单继承类似，但是需要特别注意，如果两个父类有同名方法，要掌握 <code>MRO</code> 的查找逻辑。</p>
<h3 id="mromethod-resolution-order"><a class="header" href="#mromethod-resolution-order">MRO(Method Resolution Order)</a></h3>
<p>当子类调用方法时，Python 会按照<code>MRO</code>中的顺序去查找方法，这样可以保证类的层次结构的正确性。</p>
<p><strong><code>MRO</code>的规则</strong>:</p>
<ol>
<li>深度优先： Python 首先会从左到右查找父类</li>
<li>从子类开始：搜索是从当前类开始的，如果当前类没有该方法或属性，就查找父类</li>
</ol>
<p>在实例应用中，如果对这个顺序不清楚，可以调用<code>mro()</code>或 <code>__mro__</code>查看 MRO顺序</p>
<pre><code class="language-python">print(Chicken.__mro__)

# 打印结果为： (&lt;class '__main__.Chicken'&gt;, &lt;class '__main__.Animal'&gt;, &lt;class '__main__.Bird'&gt;, &lt;class 'object'&gt;)
</code></pre>
<p>如果多继承中的多个父类有同名方法的情况，就需要<code>MRO</code>机制来确定最终执行的是哪个类里的方法：</p>
<pre><code class="language-python">class A:
	def speak(self):
		print('A is speaking.')

class B:
	def speak(self):
		print('B is speaking.')

class C(A, B):
	pass

c = C()
c.speak()

#打印结果： A is speaking.
</code></pre>
<p>如果需要手动改变顺序，也就是说需要强制让子类重写父类里的重名方法，并且不按照<code>MRO</code>规则调用，需要特别写明父类的名字的调用，并且要传递参数<code>self</code>， 这种调用叫做显式<code>Explicit</code>调用：</p>
<pre><code class="language-python">class C(A, B):
	def speak(self):
		B.speak(self)
		A.speak(self)
</code></pre>
<h4 id="钻石继承问题diamond-problem"><a class="header" href="#钻石继承问题diamond-problem">钻石继承问题（Diamond Problem）</a></h4>
<p>在多继承中，如果一个类继承了两个父类，而这个父类又继承自同一个祖先类，可能会遇到所谓的钻石继承问题:</p>
<pre><code class="language-python"># 祖先类 A
class A:
    def speak(self):
        print('A is speaking.')

# 父类 B
class B(A):
    def speak(self):
        super().speak()
        print('B is speaking.')

# 父类 C
class C(A):
    def speak(self):
        super().speak()
        print('C is speaking.')

# 子类 D
class D(B, C):
    def speak(self):
        super().speak()
        print('D is speaking.')


print(D.__mro__)

d = D()
d.speak()

&quot;&quot;&quot;
执行结果为：
A is speaking.
C is speaking.
B is speaking.
D is speaking.
&quot;&quot;&quot;
</code></pre>
<h2 id="练习"><a class="header" href="#练习">练习</a></h2>
<p><img src="26.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/WechatIMG164.jpg" alt="练习1" /></p>
<pre><code class="language-python">class Student:

    def __init__(self, name, scores):
        self.name = name
        self.scores = scores


class Scholar(Student):

    def average_score(self):
        return sum(self.scores)/len(self.scores)


scholar = Scholar('Jack', [100, 98, 92, 97, 99])
print(scholar.average_score())
</code></pre>
<p><img src="26.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/WechatIMG165.jpg" alt="习题2" /></p>
<pre><code class="language-python">class Student:

    def __init__(self, name, scores):
        self.name = name
        self.scores = scores


class AdvancedStudent(Student):

    def average_score(self):
        return sum(self.scores)/len(self.scores)

class Scholar(AdvancedStudent):

    def average_score(self):
        return (sum(self.scores)-min(self.scores))/(len(self.scores)-1)

scholar = Scholar('Jack', [100, 98, 92, 97, 99])
print(scholar.average_score())
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>在<code>Python</code>中，自定义异常是指用户根据需求创建的<strong>异常类</strong>。通常自定义异常会继承自<code>Exception</code>类或其子类。</p>
<h3 id="语法结构-syntax"><a class="header" href="#语法结构-syntax">语法结构 syntax</a></h3>
<ul>
<li>直接抛出异常， 这种方式针对异常一种简单处理，不需要过于复杂地对错误进行处理和提醒。</li>
</ul>
<pre><code class="language-python">raise Exception(&quot;description&quot;)
</code></pre>
<pre><code class="language-python">try:
    a = &quot;a&quot;
    b = 0

    if a+b!=100:
        raise Exception(&quot;a+b is not 100&quot;)
    c = a / b
except ValueError:
    print(&quot;赋值错误！&quot;)
except ZeroDivisionError:
    print(&quot;除数不能为零！&quot;)
except:
    print(&quot;其它异常&quot;)
</code></pre>
<ul>
<li>继承<code>Exception</code>类，还是上面的例子，对于两个数的异常提醒要求比较详细，可以通过继承类来解决</li>
</ul>
<pre><code class="language-python"># 示例
class ValidationError(Exception):

	def __init__(self, message, value):
		self.message = message
		self.value = value
		super().__init__(self.message)

	def __str__(self):
		return f&quot;{self.message}: {self.value}&quot;
</code></pre>
<pre><code class="language-python">class SummaryError(Exception):

	def __init__(self, message, a, b):
		self.message = message
		self.a = a
		self.b = b
		super().__init__(self.message)

	def __str__(self):
		return f&quot;The summary must be 100, but {a}+{b} = {a+b}&quot;

try:
    a = int(input('Input a:'))
    b = int(input('Input b:'))
    if a+b!=100:
        raise SummaryError('a+b must be 100',a, b)
    c = a / b
except TypeError:
    print(&quot;You assigned a wrong type.&quot;)
except ZeroDivisionError:
    print(&quot;Divisor is zero.&quot;)
except Exception as e:
    print(e)
else:
    print(&quot;c的值为：&quot;,c)
finally:
    print(&quot;程序结束！&quot;)

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="模块"><a class="header" href="#模块">模块</a></h1>
<p><strong>模块(module)</strong> 是一个<code>Python</code>文件（扩展名为<code>.py</code>），它包含了<strong>函数、类、变量</strong>以及可执行的代码。模块的作用是<strong>代码复用、结构化管理和减少重复代码</strong>。</p>
<h2 id="创建模块"><a class="header" href="#创建模块">创建模块</a></h2>
<p>要创建一个模块的过程就是写 <code>Python</code>程序的过程。比如，将下面代码保存成文件名为<code>MyModule.py</code>，那么这个文件就是一个模块:</p>
<pre><code class="language-python">print(&quot;hello, world&quot;)
</code></pre>
<p>对于上面的模块来讲，它的内容很简单，并且是可以<strong>立即</strong>执行的一行代码，这意味着，这个模块在被导入时就会执行。</p>
<p>尝试创建另外一个<code>Python</code>文件<code>Testing.py</code>，将这个模块导入：</p>
<pre><code class="language-python">import MyModule
</code></pre>
<p><img src="27.%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85/ModuleTesting.jpg" alt="ModuleTesting" /></p>
<h2 id="导入模块-1"><a class="header" href="#导入模块-1">导入模块</a></h2>
<p>在上一个部分，已经对导入模块有了认识，但是导入模块的方式主要有四种：</p>
<ul>
<li><code>import module</code></li>
</ul>
<pre><code class="language-python">import math
print(math.sqrt(16)) # 4.0
</code></pre>
<ul>
<li><code>from module import item</code> (不推荐)</li>
</ul>
<pre><code class="language-python">from math import sqrt
print(sqrt(16))
</code></pre>
<p>这种方式在调用时不需要通过<code>.</code>去调用。</p>
<ul>
<li><code>from module import *</code> (强烈不推荐)</li>
</ul>
<pre><code class="language-python">from math import *
print(sqrt(16))
print(pi)
print(sin(1))
</code></pre>
<p><strong>⚠️ 注意</strong>：不推荐使用 <code>import *</code>，因为可能会导致名称冲突。</p>
<ul>
<li><code>import module as alias</code> （重命名模块）</li>
</ul>
<pre><code class="language-python">import math as m
from math import sqrt as s
print(m.sqrt(16))
print(s(16))
</code></pre>
<h4 id="如何避免模块导入后执行不必要的代码"><a class="header" href="#如何避免模块导入后执行不必要的代码">如何避免模块导入后，执行不必要的代码。</a></h4>
<ul>
<li>第一种方式就是，在编写可能被导入的模块时，不要写那些可以直接被执行的代码，只写需要被调用的<strong>函数、类、变量</strong>。</li>
</ul>
<pre><code class="language-python">&quot;&quot;&quot;
模块名为 MyModule.py
&quot;&quot;&quot;
pi = 3.14

def area(r):
	return r*r*pi

class Shape:

	def __init__(self, type):
		self.type = type

	def myname(self):
		return self.type
</code></pre>
<pre><code class="language-python">&quot;&quot;&quot;
模块名为 Testing.py
&quot;&quot;&quot;
import MyModule as m
&quot;&quot;&quot;
如果这个文件到些结束，那么不会执行任何导入模块之外的代码，如果要执行模块中的代码，要在下面调用
&quot;&quot;&quot;

print(m.pi)
print(m.area(10))

s = m.Shape(&quot;Circle&quot;)
print(s.myname())
</code></pre>
<ul>
<li>通过<code>if __name__ == '__main__':</code> 方式将被导入模块内可立即执行的代码限制为只在本模块下执行：</li>
</ul>
<pre><code class="language-python">&quot;&quot;&quot;
模块名为 MyModule.py
&quot;&quot;&quot;
pi = 3.14

def area(r):
	return r*r*pi

class Shape:

	def __init__(self, type):
		self.type = type

	def myname(self):
		return self.type

if __name__ == '__main__':
	print(pi)  
	print(area(10))  
  
	s = Shape(&quot;Circle&quot;)  
	print(s.myname())
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="模块-1"><a class="header" href="#模块-1">模块</a></h1>
<p><strong>模块(module)</strong> 是一个<code>Python</code>文件（扩展名为<code>.py</code>），它包含了<strong>函数、类、变量</strong>以及可执行的代码。模块的作用是<strong>代码复用、结构化管理和减少重复代码</strong>。</p>
<h2 id="创建模块-1"><a class="header" href="#创建模块-1">创建模块</a></h2>
<p>要创建一个模块的过程就是写 <code>Python</code>程序的过程。比如，将下面代码保存成文件名为<code>MyModule.py</code>，那么这个文件就是一个模块:</p>
<pre><code class="language-python">print(&quot;hello, world&quot;)
</code></pre>
<p>对于上面的模块来讲，它的内容很简单，并且是可以<strong>立即</strong>执行的一行代码，这意味着，这个模块在被导入时就会执行。</p>
<p>尝试创建另外一个<code>Python</code>文件<code>Testing.py</code>，将这个模块导入：</p>
<pre><code class="language-python">import MyModule
</code></pre>
<p><img src="27.%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85/ModuleTesting.jpg" alt="ModuleTesting" /></p>
<h2 id="导入模块-2"><a class="header" href="#导入模块-2">导入模块</a></h2>
<p>在上一个部分，已经对导入模块有了认识，但是导入模块的方式主要有四种：</p>
<ul>
<li><code>import module</code></li>
</ul>
<pre><code class="language-python">import math
print(math.sqrt(16)) # 4.0
</code></pre>
<ul>
<li><code>from module import item</code> (不推荐)</li>
</ul>
<pre><code class="language-python">from math import sqrt
print(sqrt(16))
</code></pre>
<p>这种方式在调用时不需要通过<code>.</code>去调用。</p>
<ul>
<li><code>from module import *</code> (强烈不推荐)</li>
</ul>
<pre><code class="language-python">from math import *
print(sqrt(16))
print(pi)
print(sin(1))
</code></pre>
<p><strong>⚠️ 注意</strong>：不推荐使用 <code>import *</code>，因为可能会导致名称冲突。</p>
<ul>
<li><code>import module as alias</code> （重命名模块）</li>
</ul>
<pre><code class="language-python">import math as m
from math import sqrt as s
print(m.sqrt(16))
print(s(16))
</code></pre>
<h4 id="如何避免模块导入后执行不必要的代码-1"><a class="header" href="#如何避免模块导入后执行不必要的代码-1">如何避免模块导入后，执行不必要的代码。</a></h4>
<ul>
<li>第一种方式就是，在编写可能被导入的模块时，不要写那些可以直接被执行的代码，只写需要被调用的<strong>函数、类、变量</strong>。</li>
</ul>
<pre><code class="language-python">&quot;&quot;&quot;
模块名为 MyModule.py
&quot;&quot;&quot;
pi = 3.14

def area(r):
	return r*r*pi

class Shape:

	def __init__(self, type):
		self.type = type

	def myname(self):
		return self.type
</code></pre>
<pre><code class="language-python">&quot;&quot;&quot;
模块名为 Testing.py
&quot;&quot;&quot;
import MyModule as m
&quot;&quot;&quot;
如果这个文件到些结束，那么不会执行任何导入模块之外的代码，如果要执行模块中的代码，要在下面调用
&quot;&quot;&quot;

print(m.pi)
print(m.area(10))

s = m.Shape(&quot;Circle&quot;)
print(s.myname())
</code></pre>
<ul>
<li>通过<code>if __name__ == '__main__':</code> 方式将被导入模块内可立即执行的代码限制为只在本模块下执行：</li>
</ul>
<pre><code class="language-python">&quot;&quot;&quot;
模块名为 MyModule.py
&quot;&quot;&quot;
pi = 3.14

def area(r):
	return r*r*pi

class Shape:

	def __init__(self, type):
		self.type = type

	def myname(self):
		return self.type

if __name__ == '__main__':
	print(pi)  
	print(area(10))  
  
	s = Shape(&quot;Circle&quot;)  
	print(s.myname())
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包"><a class="header" href="#包">包</a></h1>
<p><strong><code>包（Package）</code></strong> 是<code>Python</code>组织模块的方式。简单来说，<strong>包就是一个包含多个模块的文件夹</strong>，并且<strong>这个文件夹中必须包含一下<code>__init__.py</code>文件(Python 3.3之前是必须required/mandatory，后面版本变为可选optional)</strong></p>
<p>优点：</p>
<ul>
<li><strong>避免模块命名冲突</strong>：不同的包可以有相同名字的模块</li>
<li><strong>模块组织更清晰</strong>：便于管理大型项目</li>
<li><strong>支持层次结构</strong>：可以创建子包</li>
</ul>
<h2 id="创建包-package"><a class="header" href="#创建包-package">创建包 Package</a></h2>
<p>一个包的架构大致如下：</p>
<pre><code class="language-bash">
mypackage /
|-- __init__.py
|-- module1.py
|-- module2.py
|-- subpackage
	|-- __init__.py
	|-- submodule.py
</code></pre>
<p><img src="27.%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85/Package.jpg" alt="Package" /></p>
<h4 id="__init__py-的作用"><a class="header" href="#__init__py-的作用"><code>__init__.py</code> 的作用</a></h4>
<ul>
<li>使<code>Python</code>识别 identify <code>MyPackage</code>目录为包</li>
<li>可以用于<strong>执行初始化代码</strong>，例如导入包内的特定模块</li>
</ul>
<p>如上图，<code>MyModule.py</code>在<code>MyPackage</code>包内：</p>
<pre><code class="language-python"># __init__.py

print('MyPackage is imported.')
</code></pre>
<ul>
<li>控制<code>from MyPackage import *</code>的行为</li>
</ul>
<h3 id="如何在一个包中导入另一个包的模块"><a class="header" href="#如何在一个包中导入另一个包的模块">如何在一个包中导入另一个包的模块</a></h3>
<p>需要借助<code>sys</code>和<code>os</code>两个模块</p>
<pre><code class="language-python">import sys  
import os  
sys.path.append(os.path.dirname(os.path.dirname(__file__)))  
  
import MyPackage.MyModule as m  
  
print(m.__name__)  
print(__name__)  
print(m.pi)  
print(m.area(10))  
  
s = m.Shape(&quot;Circle&quot;)  
print(s.myname())
</code></pre>
<h2 id="安装pip"><a class="header" href="#安装pip">安装pip</a></h2>
<ul>
<li>安装第三方包，第三方是指除了开发人员本身和已经下载的<code>Python</code>之外的人提供的包</li>
</ul>
<pre><code class="language-python">pip install requests	
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="一填空题fill-in-the-blanks"><a class="header" href="#一填空题fill-in-the-blanks"><strong>一、填空题（Fill in the Blanks）</strong></a></h3>
<ol>
<li>在 Python 中，<code>print(10 // 3)</code> 的结果是 <code>__3__</code>。</li>
<li><code>list.append(x)</code> 方法的作用是将 <code>x</code> 添加到列表的 <code>__末尾（tail）__</code>。</li>
<li>在 Python 中，<code>__def__</code> 关键字用 append于定义一个函数。</li>
<li><code>lambda x: x * 2</code> 定义了一个 <code>__函数（function）__</code>。</li>
<li><code>my_dict = {}</code> 创建的是一个 <code>__字典（dict/dictionary）__</code> 类型的数据结构。</li>
<li><code>try-except</code> 结构用于 <code>__异常(exception)__</code> 处理。</li>
<li>Python 的 <code>for</code> 循环可以用于 <code>__可迭代（iterable）__</code> 数据结构，如列表、字符串等。</li>
<li><code>my_tuple = (1, 2, 3)</code>，<code>my_tuple[0] = 10</code> 会 <code>__失败__</code>（成功 / 失败）。</li>
<li><code>is</code> 运算符用于比较两个对象的 <code>__identity__</code>，而 <code>==</code> 运算符用于比较两个对象的 <code>__值（value）__</code>。</li>
<li><code>import random</code> 用于导入 <code>__随机(random)__</code> 模块，该模块提供随机数生成功能。</li>
</ol>
<pre><code class="language-bash">1. 考核运算符的应用；
    对于除法运算的结果都是浮点数，只有一种例外，就是参与整除运算的两个都是 int 类型的数据，结果一定是 int 类型。
2. 考核的是列表的方法
3. 关键字
4. 匿名函数
5. 考核的点为空字典与空集合的区别；
   空字典的表示方式为`{}`，而空集合的表式方式为`set()`
6. 异常
7. 对于可迭代对象的理解
8. 对于元组的理解，是否改更新
9. is 比较两个对象的身份，或者直接理解的话，就是检验两个对象是不是使用了同一块内存
   但是Python 有一个特殊的机制，叫小整数池 （small integer pool)，范围在`-5 ~256`之间的整数会被认为成小整数，它们的取值都是从缓存里取的。
   也就是说，对于1来讲，假设它在缓存的地址为 `0xabcd`,那么当有变量被赋值为1时，都是将这个1从小整数池里取出来赋值，再将1赋值给后来的变量时，会将新的变量指向缓存中的1。
10. 模块的导入。
</code></pre>
<hr />
<h3 id="二选择题multiple-choice-questions"><a class="header" href="#二选择题multiple-choice-questions"><strong>二、选择题（Multiple Choice Questions）</strong></a></h3>
<ol>
<li>
<p><strong>以下哪个 Python 代码会导致 SyntaxError？</strong>  B
A) <code>print(&quot;Hello, World!&quot;)</code><br />
B) <code>x = 5 +</code><br />
C) <code>if x == 10:</code><br />
D) <code>list.append(10)</code></p>
</li>
<li>
<p><strong>在 Python 中，哪种数据结构是不可变的？</strong>   B
A) <code>list</code><br />
B) <code>tuple</code><br />
C) <code>set</code><br />
D) <code>dictionary</code></p>
</li>
<li>
<p><strong>以下代码的输出是什么？</strong> B</p>
<pre><code class="language-python">x = [1, 2, 3]
y = x
y.append(4)
print(x)
</code></pre>
<p>A) <code>[1, 2, 3]</code><br />
B) <code>[1, 2, 3, 4]</code><br />
C) <code>Error</code><br />
D) <code>[1, 2]</code></p>
</li>
<li>
<p><strong>下面哪个方法用于从字典 <code>my_dict</code> 中安全地获取键 <code>key</code> 的值，如果键不存在，则返回 <code>None</code>？</strong>  B
A) <code>my_dict[key]</code><br />
B) <code>my_dict.get(key)</code><br />
C) <code>my_dict.fetch(key)</code><br />
D) <code>my_dict.retrieve(key)</code></p>
</li>
<li>
<p><strong><code>bool([])</code> 的值是什么？</strong>  B
A) <code>True</code><br />
B) <code>False</code><br />
C) <code>None</code><br />
D) <code>Error</code>
Python中所有的假值：
a). <code>None</code>
b). <code>False</code>
c). <code>0</code> -- 所有数值类型的<code>0</code> (包括<code>int</code>、<code>float</code>)
d).  空的序列：<code>&quot;&quot;</code>、<code>[]</code>、<code>()</code>
e).  空的集合：<code>{}</code>、 <code>set()</code> 、<code>dict()</code>
f).   空的 <code>range</code>，如<code>range(0)</code>, <code>range(10, 0)</code>
g).  <code>bytes</code>和<code>bytearry</code>的空对象
<code>b&quot;&quot;</code> 和<code>bytearry(b&quot;&quot;)</code></p>
</li>
<li>
<p><strong>哪条语句用于创建一个继承自 <code>Person</code> 类的新类 <code>Student</code>？</strong>  B
A) <code>class Student inherits Person:</code><br />
B) <code>class Student(Person):</code><br />
C) <code>Student = class(Person):</code><br />
D) <code>def Student(Person):</code></p>
</li>
<li>
<p><strong>以下代码的输出是什么？</strong> B</p>
<pre><code class="language-python">def func(a, b=2, c=3):
    return a + b + c

print(func(1, c=4))
</code></pre>
<p>A) <code>6</code><br />
B) <code>7</code><br />
C) <code>8</code><br />
D) <code>Error</code></p>
</li>
<li>
<p><strong>Python 中的 <code>with open('file.txt', 'r') as f:</code> 语句的作用是？</strong>  C
A) 打开文件并锁定，直到程序结束<br />
B) 读取整个文件内容到变量 <code>f</code><br />
C) 确保文件在 <code>with</code> 代码块执行完后自动关闭<br />
D) 以二进制模式打开文件</p>
</li>
</ol>
<hr />
<h3 id="三编程题coding-questions"><a class="header" href="#三编程题coding-questions"><strong>三、编程题（Coding Questions）</strong></a></h3>
<h4 id="1-交换两个变量的值pcep-级别"><a class="header" href="#1-交换两个变量的值pcep-级别"><strong>1. 交换两个变量的值（PCEP 级别）</strong></a></h4>
<p><strong>问题：</strong><br />
编写一个 Python 程序，在不使用第三个变量的情况下交换两个变量的值。</p>
<p><strong>示例输入</strong>：</p>
<pre><code class="language-python">a = 5
b = 10
a = a+b  # 15
b = a-b  # 5
a = a-b  # 10
print(a,b)
</code></pre>
<p><strong>示例输出</strong>：</p>
<pre><code class="language-python">a = 10, b = 5
</code></pre>
<hr />
<h4 id="2-计算-fibonacci-数列pcep-级别"><a class="header" href="#2-计算-fibonacci-数列pcep-级别"><strong>2. 计算 Fibonacci 数列（PCEP 级别）</strong></a></h4>
<p><strong>问题：</strong><br />
编写一个函数 <code>fibonacci(n)</code>，返回第 <code>n</code> 个 Fibonacci 数。</p>
<p><strong>示例输入</strong>：</p>
<pre><code class="language-python">print(fibonacci(6))
</code></pre>
<p><strong>示例输出</strong>：</p>
<pre><code class="language-python">8
</code></pre>
<hr />
<h4 id="3-统计字符串中字母出现的次数pcap-级别"><a class="header" href="#3-统计字符串中字母出现的次数pcap-级别"><strong>3. 统计字符串中字母出现的次数（PCAP 级别）</strong></a></h4>
<p><strong>问题：</strong><br />
编写一个 Python 程序，统计用户输入的字符串中每个字母出现的次数，并按字母顺序输出。</p>
<p><strong>示例输入</strong>：</p>
<pre><code class="language-python">&quot;hello world&quot;
</code></pre>
<p><strong>示例输出</strong>：</p>
<pre><code class="language-python">d: 1
e: 1
h: 1
l: 3
o: 2
r: 1
w: 1
</code></pre>
<hr />
<h4 id="4-解析-json-并提取数据pcap-级别"><a class="header" href="#4-解析-json-并提取数据pcap-级别"><strong>4. 解析 JSON 并提取数据（PCAP 级别）</strong></a></h4>
<p><strong>问题：</strong><br />
Python 提供了 <code>json</code> 模块用于解析 JSON 数据。请编写一个程序，从以下 JSON 数据中提取 <code>name</code> 和 <code>age</code> 信息，并打印出来。</p>
<p><strong>示例 JSON 数据</strong>：</p>
<pre><code class="language-json">{
    &quot;name&quot;: &quot;Alice&quot;,
    &quot;age&quot;: 25,
    &quot;city&quot;: &quot;New York&quot;
}
</code></pre>
<p><strong>示例输出</strong>：</p>
<pre><code class="language-python">Name: Alice, Age: 25
</code></pre>
<hr />
<h4 id="5-继承与方法重写pcap-级别"><a class="header" href="#5-继承与方法重写pcap-级别"><strong>5. 继承与方法重写（PCAP 级别）</strong></a></h4>
<p><strong>问题：</strong><br />
创建一个 <code>Animal</code> 类，它有一个 <code>speak</code> 方法，默认返回 <code>&quot;Some sound&quot;</code>。然后创建一个 <code>Dog</code> 类，继承 <code>Animal</code>，并重写 <code>speak</code> 方法，使其返回 <code>&quot;Bark!&quot;</code>。</p>
<p><strong>示例输入</strong>：</p>
<pre><code class="language-python">a = Animal()
d = Dog()
print(a.speak())
print(d.speak())
</code></pre>
<p><strong>示例输出</strong>：</p>
<pre><code class="language-python">Some sound
Bark!
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h3 id="一填空题fill-in-the-blanks-1"><a class="header" href="#一填空题fill-in-the-blanks-1"><strong>一、填空题（Fill in the Blanks）</strong></a></h3>
<ol>
<li>在 Python 中，<code>print(10 // 3)</code> 的结果是 <code>__3__</code>。</li>
<li><code>list.append(x)</code> 方法的作用是将 <code>x</code> 添加到列表的 <code>__末尾（tail）__</code>。</li>
<li>在 Python 中，<code>__def__</code> 关键字用 append于定义一个函数。</li>
<li><code>lambda x: x * 2</code> 定义了一个 <code>__函数（function）__</code>。</li>
<li><code>my_dict = {}</code> 创建的是一个 <code>__字典（dict/dictionary）__</code> 类型的数据结构。</li>
<li><code>try-except</code> 结构用于 <code>__异常(exception)__</code> 处理。</li>
<li>Python 的 <code>for</code> 循环可以用于 <code>__可迭代（iterable）__</code> 数据结构，如列表、字符串等。</li>
<li><code>my_tuple = (1, 2, 3)</code>，<code>my_tuple[0] = 10</code> 会 <code>__失败__</code>（成功 / 失败）。</li>
<li><code>is</code> 运算符用于比较两个对象的 <code>__identity__</code>，而 <code>==</code> 运算符用于比较两个对象的 <code>__值（value）__</code>。</li>
<li><code>import random</code> 用于导入 <code>__随机(random)__</code> 模块，该模块提供随机数生成功能。</li>
</ol>
<pre><code class="language-bash">1. 考核运算符的应用；
    对于除法运算的结果都是浮点数，只有一种例外，就是参与整除运算的两个都是 int 类型的数据，结果一定是 int 类型。
2. 考核的是列表的方法
3. 关键字
4. 匿名函数
5. 考核的点为空字典与空集合的区别；
   空字典的表示方式为`{}`，而空集合的表式方式为`set()`
6. 异常
7. 对于可迭代对象的理解
8. 对于元组的理解，是否改更新
9. is 比较两个对象的身份，或者直接理解的话，就是检验两个对象是不是使用了同一块内存
   但是Python 有一个特殊的机制，叫小整数池 （small integer pool)，范围在`-5 ~256`之间的整数会被认为成小整数，它们的取值都是从缓存里取的。
   也就是说，对于1来讲，假设它在缓存的地址为 `0xabcd`,那么当有变量被赋值为1时，都是将这个1从小整数池里取出来赋值，再将1赋值给后来的变量时，会将新的变量指向缓存中的1。
10. 模块的导入。
</code></pre>
<hr />
<h3 id="二选择题multiple-choice-questions-1"><a class="header" href="#二选择题multiple-choice-questions-1"><strong>二、选择题（Multiple Choice Questions）</strong></a></h3>
<ol>
<li>
<p><strong>以下哪个 Python 代码会导致 SyntaxError？</strong>  B
A) <code>print(&quot;Hello, World!&quot;)</code><br />
B) <code>x = 5 +</code><br />
C) <code>if x == 10:</code><br />
D) <code>list.append(10)</code></p>
</li>
<li>
<p><strong>在 Python 中，哪种数据结构是不可变的？</strong>   B
A) <code>list</code><br />
B) <code>tuple</code><br />
C) <code>set</code><br />
D) <code>dictionary</code></p>
</li>
<li>
<p><strong>以下代码的输出是什么？</strong> B</p>
<pre><code class="language-python">x = [1, 2, 3]
y = x
y.append(4)
print(x)
</code></pre>
<p>A) <code>[1, 2, 3]</code><br />
B) <code>[1, 2, 3, 4]</code><br />
C) <code>Error</code><br />
D) <code>[1, 2]</code></p>
</li>
<li>
<p><strong>下面哪个方法用于从字典 <code>my_dict</code> 中安全地获取键 <code>key</code> 的值，如果键不存在，则返回 <code>None</code>？</strong>  B
A) <code>my_dict[key]</code><br />
B) <code>my_dict.get(key)</code><br />
C) <code>my_dict.fetch(key)</code><br />
D) <code>my_dict.retrieve(key)</code></p>
</li>
<li>
<p><strong><code>bool([])</code> 的值是什么？</strong>  B
A) <code>True</code><br />
B) <code>False</code><br />
C) <code>None</code><br />
D) <code>Error</code>
Python中所有的假值：
a). <code>None</code>
b). <code>False</code>
c). <code>0</code> -- 所有数值类型的<code>0</code> (包括<code>int</code>、<code>float</code>)
d).  空的序列：<code>&quot;&quot;</code>、<code>[]</code>、<code>()</code>
e).  空的集合：<code>{}</code>、 <code>set()</code> 、<code>dict()</code>
f).   空的 <code>range</code>，如<code>range(0)</code>, <code>range(10, 0)</code>
g).  <code>bytes</code>和<code>bytearry</code>的空对象
<code>b&quot;&quot;</code> 和<code>bytearry(b&quot;&quot;)</code></p>
</li>
<li>
<p><strong>哪条语句用于创建一个继承自 <code>Person</code> 类的新类 <code>Student</code>？</strong>  B
A) <code>class Student inherits Person:</code><br />
B) <code>class Student(Person):</code><br />
C) <code>Student = class(Person):</code><br />
D) <code>def Student(Person):</code></p>
</li>
<li>
<p><strong>以下代码的输出是什么？</strong> B</p>
<pre><code class="language-python">def func(a, b=2, c=3):
    return a + b + c

print(func(1, c=4))
</code></pre>
<p>A) <code>6</code><br />
B) <code>7</code><br />
C) <code>8</code><br />
D) <code>Error</code></p>
</li>
<li>
<p><strong>Python 中的 <code>with open('file.txt', 'r') as f:</code> 语句的作用是？</strong>  C
A) 打开文件并锁定，直到程序结束<br />
B) 读取整个文件内容到变量 <code>f</code><br />
C) 确保文件在 <code>with</code> 代码块执行完后自动关闭<br />
D) 以二进制模式打开文件</p>
</li>
</ol>
<hr />
<h3 id="三编程题coding-questions-1"><a class="header" href="#三编程题coding-questions-1"><strong>三、编程题（Coding Questions）</strong></a></h3>
<h4 id="1-交换两个变量的值pcep-级别-1"><a class="header" href="#1-交换两个变量的值pcep-级别-1"><strong>1. 交换两个变量的值（PCEP 级别）</strong></a></h4>
<p><strong>问题：</strong><br />
编写一个 Python 程序，在不使用第三个变量的情况下交换两个变量的值。</p>
<p><strong>示例输入</strong>：</p>
<pre><code class="language-python">a = 5
b = 10
a = a+b  # 15
b = a-b  # 5
a = a-b  # 10
print(a,b)
</code></pre>
<p><strong>示例输出</strong>：</p>
<pre><code class="language-python">a = 10, b = 5
</code></pre>
<hr />
<h4 id="2-计算-fibonacci-数列pcep-级别-1"><a class="header" href="#2-计算-fibonacci-数列pcep-级别-1"><strong>2. 计算 Fibonacci 数列（PCEP 级别）</strong></a></h4>
<p><strong>问题：</strong><br />
编写一个函数 <code>fibonacci(n)</code>，返回第 <code>n</code> 个 Fibonacci 数。</p>
<p><strong>示例输入</strong>：</p>
<pre><code class="language-python">print(fibonacci(6))
</code></pre>
<p><strong>示例输出</strong>：</p>
<pre><code class="language-python">8
</code></pre>
<hr />
<h4 id="3-统计字符串中字母出现的次数pcap-级别-1"><a class="header" href="#3-统计字符串中字母出现的次数pcap-级别-1"><strong>3. 统计字符串中字母出现的次数（PCAP 级别）</strong></a></h4>
<p><strong>问题：</strong><br />
编写一个 Python 程序，统计用户输入的字符串中每个字母出现的次数，并按字母顺序输出。</p>
<p><strong>示例输入</strong>：</p>
<pre><code class="language-python">&quot;hello world&quot;
</code></pre>
<p><strong>示例输出</strong>：</p>
<pre><code class="language-python">d: 1
e: 1
h: 1
l: 3
o: 2
r: 1
w: 1
</code></pre>
<hr />
<h4 id="4-解析-json-并提取数据pcap-级别-1"><a class="header" href="#4-解析-json-并提取数据pcap-级别-1"><strong>4. 解析 JSON 并提取数据（PCAP 级别）</strong></a></h4>
<p><strong>问题：</strong><br />
Python 提供了 <code>json</code> 模块用于解析 JSON 数据。请编写一个程序，从以下 JSON 数据中提取 <code>name</code> 和 <code>age</code> 信息，并打印出来。</p>
<p><strong>示例 JSON 数据</strong>：</p>
<pre><code class="language-json">{
    &quot;name&quot;: &quot;Alice&quot;,
    &quot;age&quot;: 25,
    &quot;city&quot;: &quot;New York&quot;
}
</code></pre>
<p><strong>示例输出</strong>：</p>
<pre><code class="language-python">Name: Alice, Age: 25
</code></pre>
<hr />
<h4 id="5-继承与方法重写pcap-级别-1"><a class="header" href="#5-继承与方法重写pcap-级别-1"><strong>5. 继承与方法重写（PCAP 级别）</strong></a></h4>
<p><strong>问题：</strong><br />
创建一个 <code>Animal</code> 类，它有一个 <code>speak</code> 方法，默认返回 <code>&quot;Some sound&quot;</code>。然后创建一个 <code>Dog</code> 类，继承 <code>Animal</code>，并重写 <code>speak</code> 方法，使其返回 <code>&quot;Bark!&quot;</code>。</p>
<p><strong>示例输入</strong>：</p>
<pre><code class="language-python">a = Animal()
d = Dog()
print(a.speak())
print(d.speak())
</code></pre>
<p><strong>示例输出</strong>：</p>
<pre><code class="language-python">Some sound
Bark!
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h3 id="pcep--pcap-认证相关-python-题目中等难度"><a class="header" href="#pcep--pcap-认证相关-python-题目中等难度"><strong>PCEP &amp; PCAP 认证相关 Python 题目（中等难度）</strong></a></h3>
<hr />
<h3 id="填空题5-题"><a class="header" href="#填空题5-题"><strong>填空题（5 题）</strong></a></h3>
<ol>
<li>在 Python 中，<code>def my_func(*args):</code> 语法表示 <code>args</code> 是一个 <code>__可变__</code> 类型的参数，用于接收多个位置参数。</li>
<li>在 Python 中，<code>break</code> 语句用于 <code>__结束/跳出(exit/terminate)__</code> 循环，而 <code>continue</code> 语句用于 <code>__跳过(skip)__</code> 当前循环的一次执行。</li>
<li><code>open('data.txt', 'w')</code> 以 <code>__写入(write)__</code> 模式打开文件，如果文件已存在，它会 <code>__清空(clear)__</code> 之前的内容。</li>
<li>在 <code>for</code> 循环中，如果没有使用 <code>break</code> 退出循环，则 <code>__else__</code> 代码块将执行。</li>
<li>使用 <code>import math</code> 导入 <code>math</code> 模块后，可以使用 <code>__sqrt__</code> 计算平方根，例如 <code>math.sqrt(9)</code> 返回 <code>__3.0__</code>。</li>
</ol>
<hr />
<h3 id="选择题5-题"><a class="header" href="#选择题5-题"><strong>选择题（5 题）</strong></a></h3>
<ol start="6">
<li>
<p><strong>以下哪一项不是 Python 中的合法变量名？</strong>   B
A) <code>_my_var</code><br />
B) <code>3variable</code><br />
C) <code>myVar3</code><br />
D) <code>var_3</code></p>
</li>
<li>
<p><strong>在 Python 中，<code>x = [1, 2, 3]</code> 和 <code>y = x</code>，执行 <code>y.append(4)</code> 后，<code>x</code> 变成了什么？</strong>  B
A) <code>[1, 2, 3]</code><br />
B) <code>[1, 2, 3, 4]</code><br />
C) <code>[1, 2, 3]</code>（但 <code>y</code> 变成 <code>[1, 2, 3, 4]</code>）<br />
D) 代码报错</p>
</li>
<li>
<p><strong>关于 Python 的 <code>range(5)</code>，以下说法正确的是？</strong>  D
A) <code>range(5)</code> 生成 <code>[0, 1, 2, 3, 4]</code><br />
B) <code>range(5)</code> 生成 <code>[1, 2, 3, 4, 5]</code><br />
C) <code>range(5)</code> 生成 <code>[0, 1, 2, 3, 4, 5]</code><br />
D) <code>range(5)</code> 生成 <code>(0, 1, 2, 3, 4)</code></p>
</li>
<li>
<p><strong>以下 Python 代码的输出是什么？</strong> A</p>
<pre><code class="language-python">def test(a, b=2, c=3):
    return a + b + c
print(test(1, c=4))
</code></pre>
<p>A) <code>7</code><br />
B) <code>8</code><br />
C) <code>9</code><br />
D) 代码报错</p>
</li>
<li>
<p><strong>在 Python 中，以下哪种方式可以正确读取 <code>data.txt</code> 文件的所有内容？</strong>  D
A) <code>content = open('data.txt').read()</code><br />
B) <code>with open('data.txt') as f: content = f.read()</code><br />
C) <code>with open('data.txt', 'r') as f: content = f.read()</code><br />
D) 以上都正确</p>
<pre><code>A选项相当于：
f = open('data.txt')
content = f.read()
</code></pre>
</li>
</ol>
<hr />
<h3 id="编程题3-题"><a class="header" href="#编程题3-题"><strong>编程题（3 题）</strong></a></h3>
<ol start="11">
<li>
<p><strong>请编写一个 Python 函数 <code>count_vowels(s)</code>，计算字符串 <code>s</code> 中的元音字母（a, e, i, o, u）的数量，忽略大小写。</strong><br />
<strong>示例输入：</strong> <code>&quot;Hello World&quot;</code><br />
<strong>示例输出：</strong> <code>3</code></p>
</li>
<li>
<p><strong>请编写一个 Python 函数 <code>factorial(n)</code>，计算正整数 <code>n</code> 的阶乘（<code>n!</code>）。</strong><br />
<strong>示例输入：</strong> <code>factorial(5)</code><br />
<strong>示例输出：</strong> <code>120</code></p>
</li>
<li>
<p><strong>请编写一个 Python 代码，使用 <code>while</code> 循环打印 1 到 10 的所有奇数。</strong><br />
<strong>示例输出：</strong></p>
</li>
</ol>
<pre><code>1
3
5
7
9
</code></pre>
<hr />
<p>这套题目比上一套难度稍低，涵盖了<strong>基本数据类型、循环、函数、默认参数、文件操作</strong>等核心知识点，适合 PCEP 和 PCAP 学习者练习！🚀</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="填空题10-题"><a class="header" href="#填空题10-题"><strong>填空题（10 题）</strong></a></h3>
<ol>
<li><strong>Python 中，<code>input()</code> 函数用于接收用户的 <code>__键盘(keyboard)__</code> 输入，返回的是一个 <code>__字符串(str)__</code> 类型的数据。</strong></li>
<li><strong>在 Python 中，<code>//</code> 运算符用于执行 <code>__整除（floor division）__</code> 除法，返回一个整数结果。</strong></li>
<li><strong>在 Python 中，<code>is</code> 运算符用于比较两个对象的 <code>__身份(identity)__</code>，而 <code>==</code> 运算符用于比较对象的 <code>__值(value)__</code>。</strong></li>
<li><strong>Python 中，<code>None</code> 是一个特殊的常量，表示 <code>__空值(no value)__</code>。</strong></li>
<li><strong>Python 中，<code>__init__()</code> 是 <code>__构造(Constructor)__</code> 方法，在创建对象时会自动调用。</strong></li>
<li><strong>在 Python 中，<code>len()</code> 函数用于返回对象的 <code>__长度(length)__</code>，例如字符串的长度或列表的元素数量。</strong></li>
<li><strong>Python 中，<code>range(1, 5)</code> 生成的序列为 <code>__1,2,3,4__</code>，包含数字 1 到 4。</strong></li>
<li><strong>Python 中，<code>str()</code> 函数可以将其他数据类型转换为 <code>__字符串(str)__</code> 类型。</strong></li>
<li><strong>Python 中，<code>del</code> 关键字用于删除对象或变量，删除的对象会 <code>__被回收(garbage collected)__</code>。</strong></li>
<li><strong>Python 中，<code>import</code> 语句用于 <code>__加载(load)__</code> 模块或包。</strong></li>
</ol>
<hr />
<h3 id="选择题10-题"><a class="header" href="#选择题10-题"><strong>选择题（10 题）</strong></a></h3>
<ol start="11">
<li>
<p><strong>以下哪项是 Python 中的合法标识符？</strong>  C 
A) <code>1variable</code><br />
B) <code>my_var!</code><br />
C) <code>_myVar</code><br />
D) <code>my-var</code></p>
</li>
<li>
<p><strong>在 Python 中，<code>range(2, 10, 2)</code> 生成的序列是？</strong>  A
A) <code>[2, 4, 6, 8]</code><br />
B) <code>[2, 4, 6, 8, 10]</code><br />
C) <code>[0, 2, 4, 6, 8]</code><br />
D) <code>[1, 3, 5, 7, 9]</code></p>
</li>
<li>
<p><strong>以下哪个是 Python 中的布尔值类型？</strong>  A
A) <code>True</code><br />
B) <code>Yes</code><br />
C) <code>1</code><br />
D) <code>Boolean</code></p>
</li>
<li>
<p><strong>在 Python 中，<code>x = 5</code> 和 <code>y = 5</code>，执行 <code>x == y</code> 时，结果是？</strong>  A
A) <code>True</code><br />
B) <code>False</code><br />
C) <code>Error</code><br />
D) <code>None</code></p>
</li>
<li>
<p><strong>在 Python 中，如何定义一个空集合？</strong> B<br />
A) <code>{}</code><br />
B) <code>set()</code><br />
C) <code>[]</code><br />
D) <code>None</code></p>
</li>
<li>
<p><strong>在 Python 中，以下哪项会返回 <code>True</code>？</strong>  D
A) <code>bool(0)</code><br />
B) <code>bool([])</code><br />
C) <code>bool(None)</code><br />
D) <code>bool(&quot;True&quot;)</code></p>
</li>
<li>
<p><strong>以下代码的输出是什么？</strong> C</p>
<pre><code class="language-python">x = &quot;Python&quot;
print(x[2:])
</code></pre>
<p>A) <code>Pyt</code><br />
B) <code>Py</code><br />
C) <code>thon</code><br />
D) <code>Python</code></p>
</li>
<li>
<p><strong>以下代码中，<code>append()</code> 函数的作用是？</strong> B</p>
<pre><code class="language-python">list = [1, 2, 3]
list.append(4)
</code></pre>
<p>A) 将数字 4 添加到列表的开头<br />
B) 将数字 4 添加到列表的末尾<br />
C) 删除列表中的数字 4<br />
D) 将数字 4 替换列表中的最后一个元素</p>
</li>
<li>
<p><strong>在 Python 中，<code>is</code> 运算符检查两个对象是否具有相同的 <code>__B__</code>。</strong><br />
A) 值<br />
B) 地址<br />
C) 类型<br />
D) 长度</p>
</li>
<li>
<p><strong>以下哪一项是 Python 中的内建函数？</strong>  B
A) <code>add()</code><br />
B) <code>list()</code><br />
C) <code>print_all()</code><br />
D) <code>sum_all()</code></p>
</li>
</ol>
<hr />
<h3 id="编程题10-题"><a class="header" href="#编程题10-题"><strong>编程题（10 题）</strong></a></h3>
<ol start="21">
<li><strong>编写一个 Python 函数 <code>reverse_string(s)</code>，返回字符串 <code>s</code> 的反转结果。</strong><br />
<strong>示例输入：</strong> <code>&quot;hello&quot;</code><br />
<strong>示例输出：</strong> <code>&quot;olleh&quot;</code></li>
</ol>
<pre><code class="language-python">def reverse_string(s):
	return s[::-1]
</code></pre>
<ol start="22">
<li><strong>编写一个 Python 函数 <code>is_prime(n)</code>，判断给定整数 <code>n</code> 是否为质数。</strong><br />
<strong>示例输入：</strong> <code>5</code><br />
<strong>示例输出：</strong> <code>True</code></li>
</ol>
<pre><code class="language-python">def is_prime(n):
    if n&lt;2:
        return False
    for i in range(2,n):
        if n % i == 0:
            return False
    return True

num = int(input(&quot;Input a number:&quot;))
if is_prime(num):
    print(&quot;Yes&quot;)
else:
    print(&quot;No&quot;)

flag = True
if n&lt;2:
    flag = False
else:
    for i in range(2,n):
        if n % i == 0:
            flag = False
            break

if flag:
    print(&quot;Yes&quot;)
else:
    print(&quot;No&quot;)
</code></pre>
<ol start="23">
<li><strong>编写一个 Python 函数 <code>sum_of_digits(n)</code>，计算一个正整数 <code>n</code> 的各个数字的和。</strong><br />
<strong>示例输入：</strong> <code>123</code><br />
<strong>示例输出：</strong> <code>6</code></li>
</ol>
<pre><code class="language-python">def sum_of_digits(n):
    total = 0

    for i in str(n):
        total = total + int(i)

    return total
</code></pre>
<ol start="24">
<li>
<p><strong>编写一个 Python 函数 <code>fibonacci(n)</code>，返回 Fibonacci 序列中第 <code>n</code> 个数字。</strong><br />
<strong>示例输入：</strong> <code>fibonacci(6)</code><br />
<strong>示例输出：</strong> <code>8</code></p>
</li>
<li>
<p><strong>编写一个 Python 函数 <code>find_max(nums)</code>，返回给定数字列表 <code>nums</code> 中的最大值。</strong><br />
<strong>示例输入：</strong> <code>[3, 5, 2, 8, 6]</code><br />
<strong>示例输出：</strong> <code>8</code></p>
</li>
</ol>
<pre><code class="language-python">def find_max(nums):
	return max(nums)
</code></pre>
<ol start="26">
<li><strong>编写一个 Python 函数 <code>even_numbers(nums)</code>，返回一个列表，包含列表 <code>nums</code> 中的所有偶数。</strong><br />
<strong>示例输入：</strong> <code>[1, 2, 3, 4, 5, 6]</code><br />
<strong>示例输出：</strong> <code>[2, 4, 6]</code></li>
</ol>
<pre><code class="language-python">def even_numbers(nums):
	lst = []
	for i in nums:
		if i % 2 == 0:
			lst.append(i)
	return lst
</code></pre>
<ol start="27">
<li><strong>编写一个 Python 函数 <code>remove_duplicates(nums)</code>，去除列表 <code>nums</code> 中的重复元素并返回新的列表。</strong><br />
<strong>示例输入：</strong> <code>[1, 2, 2, 3, 4, 4, 5]</code><br />
<strong>示例输出：</strong> <code>[1, 2, 3, 4, 5]</code></li>
</ol>
<pre><code class="language-python">def remove_duplicates(nums):
	return list(set(nums))
</code></pre>
<ol start="28">
<li>
<p><strong>编写一个 Python 函数 <code>count_occurrences(lst, item)</code>，返回 <code>item</code> 在列表 <code>lst</code> 中出现的次数。</strong><br />
<strong>示例输入：</strong> <code>[1, 2, 2, 3, 4, 2]</code>, <code>2</code><br />
<strong>示例输出：</strong> <code>3</code></p>
</li>
<li>
<p><strong>编写一个 Python 函数 <code>remove_vowels(s)</code>，返回一个删除了所有元音字母的字符串。</strong><br />
<strong>示例输入：</strong> <code>&quot;hello world&quot;</code><br />
<strong>示例输出：</strong> <code>&quot;hll wrld&quot;</code></p>
</li>
<li>
<p><strong>编写一个 Python 函数 <code>factorial(n)</code>，计算 <code>n!</code> 的阶乘。</strong><br />
<strong>示例输入：</strong> <code>factorial(4)</code><br />
<strong>示例输出：</strong> <code>24</code></p>
</li>
</ol>
<hr />
<h3 id="综合题5-题"><a class="header" href="#综合题5-题"><strong>综合题（5 题）</strong></a></h3>
<ol start="31">
<li>
<p><strong>编写一个 Python 函数 <code>max_diff(nums)</code>，返回给定数字列表中最大和最小值的差值。</strong><br />
<strong>示例输入：</strong> <code>[10, 2, 8, 5, 7]</code><br />
<strong>示例输出：</strong> <code>8</code></p>
</li>
<li>
<p><strong>编写一个 Python 函数 <code>merge_lists(list1, list2)</code>，将两个列表合并为一个并返回。</strong><br />
<strong>示例输入：</strong> <code>[1, 2, 3]</code>, <code>[4, 5, 6]</code><br />
<strong>示例输出：</strong> <code>[1, 2, 3, 4, 5, 6]</code></p>
</li>
<li>
<p><strong>编写一个 Python 函数 <code>is_palindrome(s)</code>，判断一个字符串是否是回文。</strong><br />
<strong>示例输入：</strong> <code>&quot;racecar&quot;</code><br />
<strong>示例输出：</strong> <code>True</code></p>
</li>
<li>
<p><strong>编写一个 Python 函数 <code>common_elements(list1, list2)</code>，返回两个列表中共同的元素。</strong><br />
<strong>示例输入：</strong> <code>[1, 2, 3]</code>, <code>[3, 4, 5]</code><br />
<strong>示例输出：</strong> <code>[3]</code></p>
</li>
<li>
<p><strong>编写一个 Python 函数 <code>sort_list(nums)</code>，返回一个升序排列的数字列表。</strong><br />
<strong>示例输入：</strong> <code>[3, 1, 2, 5, 4]</code><br />
<strong>示例输出：</strong> <code>[1, 2, 3, 4, 5]</code></p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pcep--pcap-certification-practice-questions"><a class="header" href="#pcep--pcap-certification-practice-questions">PCEP &amp; PCAP Certification Practice Questions</a></h1>
<h2 id="一单选题共20题每题仅一个正确答案"><a class="header" href="#一单选题共20题每题仅一个正确答案">一、单选题（共20题，每题仅一个正确答案）</a></h2>
<ol>
<li>
<p>哪一选项可以正确输出字符串的长度？</p>
<ul>
<li>A. <code>len[&quot;hello&quot;]</code></li>
<li>B. <code>size(&quot;hello&quot;)</code></li>
<li>C. <code>length(&quot;hello&quot;)</code></li>
<li>D. <code>len(&quot;hello&quot;)</code> ✅</li>
</ul>
</li>
<li>
<p>以下哪一项是合法的变量名？</p>
<ul>
<li>A. <code>2value</code></li>
<li>B. <code>value_2</code> ✅</li>
<li>C. <code>value-2</code></li>
<li>D. <code>@value</code></li>
</ul>
</li>
<li>
<p>运行以下代码的结果是什么？</p>
<pre><code class="language-python">print(2 ** 3)
</code></pre>
<ul>
<li>A. 5</li>
<li>B. 6</li>
<li>C. 8 ✅</li>
<li>D. 9</li>
</ul>
</li>
<li>
<p>以下哪个关键字用于定义函数？</p>
<ul>
<li>A. <code>func</code></li>
<li>B. <code>def</code> ✅</li>
<li>C. <code>function</code></li>
<li>D. <code>define</code></li>
</ul>
</li>
<li>
<p>若 <code>x = 5</code>，以下哪条语句可判断 x 是否等于 5？</p>
<ul>
<li>A. <code>if x = 5:</code></li>
<li>B. <code>if x == 5:</code> ✅</li>
<li>C. <code>if x === 5:</code></li>
<li>D. <code>if x =&gt; 5:</code></li>
</ul>
</li>
<li>
<p>哪个不是 Python 的逻辑运算符？</p>
<ul>
<li>A. <code>and</code></li>
<li>B. <code>or</code></li>
<li>C. <code>not</code></li>
<li>D. <code>nor</code> ✅</li>
</ul>
</li>
<li>
<p><code>list.append(x)</code> 方法的作用是？</p>
<ul>
<li>A. 返回新的列表</li>
<li>B. 删除 x</li>
<li>C. 在末尾添加 x ✅</li>
<li>D. 在开头插入 x</li>
</ul>
</li>
<li>
<p>以下哪项不是 Python 的数据类型？</p>
<ul>
<li>A. <code>tuple</code></li>
<li>B. <code>list</code></li>
<li>C. <code>map</code> ✅</li>
<li>D. <code>set</code></li>
</ul>
</li>
<li>
<p>以下哪个语句用于捕获异常？</p>
<ul>
<li>A. <code>handle</code></li>
<li>B. <code>try-except</code> ✅</li>
<li>C. <code>error-catch</code></li>
<li>D. <code>check</code></li>
</ul>
</li>
<li>
<p>若有字符串 <code>s = &quot;Python&quot;</code>，执行 <code>s[0]</code> 得到？</p>
<ul>
<li>A. <code>&quot;P&quot;</code> ✅</li>
<li>B. <code>&quot;y&quot;</code></li>
<li>C. <code>&quot;n&quot;</code></li>
<li>D. 报错</li>
</ul>
</li>
<li>
<p>Python 中，哪个是浮点除法？</p>
<ul>
<li>A. <code>//</code></li>
<li>B. <code>/</code> ✅</li>
<li>C. <code>%</code></li>
<li>D. <code>*</code></li>
</ul>
</li>
<li>
<p>以下哪个模块用于生成随机数？</p>
<ul>
<li>A. <code>math</code></li>
<li>B. <code>sys</code></li>
<li>C. <code>random</code> ✅</li>
<li>D. <code>os</code></li>
</ul>
</li>
<li>
<p>在函数内部修改全局变量，应使用哪个关键字？</p>
<ul>
<li>A. <code>local</code></li>
<li>B. <code>static</code></li>
<li>C. <code>global</code> ✅</li>
<li>D. <code>public</code></li>
</ul>
</li>
<li>
<p>如何定义一个字典？</p>
<ul>
<li>A. <code>[]</code></li>
<li>B. <code>()</code></li>
<li>C. <code>{}</code> ✅</li>
<li>D. <code>&lt;&gt;</code></li>
</ul>
</li>
<li>
<p><code>x = [1, 2, 3]</code>，哪条语句可以删除最后一个元素？</p>
<ul>
<li>A. <code>x.remove()</code></li>
<li>B. <code>x.pop()</code> ✅</li>
<li>C. <code>del x[0]</code></li>
<li>D. <code>x.delete()</code></li>
</ul>
</li>
<li>
<p>如果一个模块名为 <code>math</code>，正确的导入方式是？</p>
<ul>
<li>A. <code>import math</code> ✅</li>
<li>B. <code>load math</code></li>
<li>C. <code>using math</code></li>
<li>D. <code>require math</code></li>
</ul>
</li>
<li>
<p>类的构造函数方法名是？</p>
<ul>
<li>A. <code>__build__</code></li>
<li>B. <code>__init__</code> ✅</li>
<li>C. <code>__new__</code></li>
<li>D. <code>__create__</code></li>
</ul>
</li>
<li>
<p>哪个语句用于退出循环？</p>
<ul>
<li>A. <code>exit</code></li>
<li>B. <code>stop</code></li>
<li>C. <code>break</code> ✅</li>
<li>D. <code>return</code></li>
</ul>
</li>
<li>
<p>在类中定义方法时，第一个参数通常是？</p>
<ul>
<li>A. <code>this</code></li>
<li>B. <code>self</code> ✅</li>
<li>C. <code>cls</code></li>
<li>D. <code>obj</code></li>
</ul>
</li>
<li>
<p>若想让某模块只在直接运行时执行某段代码，正确做法是？</p>
<ul>
<li>A. <code>if __main__ == &quot;__name__&quot;:</code></li>
<li>B. <code>if __name__ == &quot;__main__&quot;:</code> ✅</li>
<li>C. <code>if name == &quot;main&quot;:</code></li>
<li>D. <code>if run == True:</code></li>
</ul>
</li>
</ol>
<h2 id="二多选题共10题至少两个选项正确"><a class="header" href="#二多选题共10题至少两个选项正确">二、多选题（共10题，至少两个选项正确）</a></h2>
<ol start="21">
<li>
<p>以下哪些是合法的数据结构？</p>
<ul>
<li>A. <code>list</code> ✅</li>
<li>B. <code>set</code> ✅</li>
<li>C. <code>dict</code> ✅</li>
<li>D. <code>int</code></li>
</ul>
</li>
<li>
<p>以下哪些是 Python 的关键字？</p>
<ul>
<li>A. <code>def</code> ✅</li>
<li>B. <code>class</code> ✅</li>
<li>C. <code>import</code> ✅</li>
<li>D. <code>define</code></li>
</ul>
</li>
<li>
<p>关于字符串的方法，以下哪些是正确的？</p>
<ul>
<li>A. <code>&quot;abc&quot;.upper()</code> ✅</li>
<li>B. <code>&quot;abc&quot;.append(&quot;d&quot;)</code></li>
<li>C. <code>&quot;abc&quot;.replace(&quot;a&quot;, &quot;x&quot;)</code> ✅</li>
<li>D. <code>&quot;abc&quot;.split()</code> ✅</li>
</ul>
</li>
<li>
<p>以下哪些属于布尔值操作？</p>
<ul>
<li>A. <code>not</code> ✅</li>
<li>B. <code>and</code> ✅</li>
<li>C. <code>or</code> ✅</li>
<li>D. <code>xor</code></li>
</ul>
</li>
<li>
<p>以下哪些语句会引发异常？</p>
<ul>
<li>A. <code>int(&quot;abc&quot;)</code> ✅</li>
<li>B. <code>1 / 0</code> ✅</li>
<li>C. <code>open(&quot;nofile.txt&quot;)</code> ✅</li>
<li>D. <code>print(&quot;hello&quot;)</code></li>
</ul>
</li>
<li>
<p>以下哪些函数属于内置函数？</p>
<ul>
<li>A. <code>len()</code> ✅</li>
<li>B. <code>input()</code> ✅</li>
<li>C. <code>sum()</code> ✅</li>
<li>D. <code>main()</code></li>
</ul>
</li>
<li>
<p>关于 <code>for</code> 循环，以下哪些语法是正确的？</p>
<ul>
<li>A. <code>for i in range(5):</code> ✅</li>
<li>B. <code>for i from 1 to 10:</code></li>
<li>C. <code>for item in my_list:</code> ✅</li>
<li>D. <code>foreach item in my_list:</code></li>
</ul>
</li>
<li>
<p>关于异常处理，以下哪些写法是合法的？</p>
<ul>
<li>A.
<pre><code class="language-python">try:
    ...
except:
    ...
``` ✅  
</code></pre>
</li>
<li>B.
<pre><code class="language-python">try:
    ...
catch:
    ...
</code></pre>
</li>
<li>C.
<pre><code class="language-python">try:
    ...
except ValueError:
    ...
``` ✅  
</code></pre>
</li>
<li>D. <code>raise Exception(&quot;Error&quot;)</code> ✅</li>
</ul>
</li>
<li>
<p>以下关于类的说法正确的是？</p>
<ul>
<li>A. 类可以有多个方法 ✅</li>
<li>B. 类可以继承 ✅</li>
<li>C. 类必须有构造方法</li>
<li>D. 类是一种对象模板 ✅</li>
</ul>
</li>
<li>
<p>关于模块的使用，以下哪些是正确的？</p>
<ul>
<li>A. <code>import math</code> ✅</li>
<li>B. <code>from math import sqrt</code> ✅</li>
<li>C. <code>require(math)</code></li>
<li>D. <code>math.sqrt(4)</code> ✅</li>
</ul>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="进制转换-5"><a class="header" href="#进制转换-5">进制转换</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h2 id="完整运算符"><a class="header" href="#完整运算符">完整运算符</a></h2>
<table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody>
<tr><td><code>[]</code> <code>[:]</code></td><td>下标，切片</td></tr>
<tr><td><code>**</code></td><td>指数</td></tr>
<tr><td><code>~</code> <code>+</code> <code>-</code></td><td>按位取反, 正负号</td></tr>
<tr><td><code>*</code> <code>/</code> <code>%</code> <code>//</code></td><td>乘，除，模，整除</td></tr>
<tr><td><code>+</code> <code>-</code></td><td>加，减</td></tr>
<tr><td><code>&gt;&gt;</code> <code>&lt;&lt;</code></td><td>右移，左移</td></tr>
<tr><td><code>&amp;</code></td><td>按位与</td></tr>
<tr><td><code>^</code> <code>\|</code></td><td>按位异或，按位或</td></tr>
<tr><td><code>&lt;=</code> <code>&lt;</code> <code>&gt;</code> <code>&gt;=</code></td><td>小于等于，小于，大于，大于等于</td></tr>
<tr><td><code>==</code> <code>!=</code></td><td>等于，不等于</td></tr>
<tr><td><code>is</code>  <code>is not</code></td><td>身份运算符</td></tr>
<tr><td><code>in</code> <code>not in</code></td><td>成员运算符</td></tr>
<tr><td><code>not</code> <code>or</code> <code>and</code></td><td>逻辑运算符</td></tr>
<tr><td><code>=</code> <code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code> <code>%=</code> <code>//=</code> <code>**=</code> <code>&amp;=</code> `</td><td>=<code> </code>^=<code> </code>&gt;&gt;=<code> </code>&lt;&lt;=`</td></tr>
</tbody></table>
<h2 id="字面量"><a class="header" href="#字面量">字面量</a></h2>
<p><strong>字面量</strong>是用于表达源码中一个固定值的表示法，整数、浮点数和字符串等等都是字符串。比如在下面声名变量语句中:</p>
<pre><code class="language-Python">a = 1
</code></pre>
<p><code>a</code>是声明的变量，那赋值符<code>=</code>后面的<code>1</code>就是字面量。总之，字面量就是没有用标识符封装起来的量，是“值”的原始状态。</p>
<h2 id="按位取反-1"><a class="header" href="#按位取反-1">按位取反</a></h2>
<p>在学习按位取反之前，我们要先了解<strong>原码、反码和补码</strong>。</p>
<p>前面提到过，数值在计算机中的以二进制的方式存储的，但是真正在存储时用的都是二进制补码，且在存储之前先要经过<strong>原码-&gt;反码-&gt;补码</strong>的转换过程：</p>
<p>对于一个有符号数(即正、负)，它的最高位永远是符号位，<code>0</code>为正数，<code>1</code>为负数。假设我们的一台简易计算机只用一个字节(byte，即8位)来存储数值，那么对于5和-5来说:</p>
<p>原码:</p>
<pre><code class="language-shell">5: 0000 0101
-5: 1000 0101
</code></pre>
<p>反码(正数反码即自身，负数则除符号位之外其它各位取反):</p>
<pre><code class="language-shell">5: 0000 0101
-5: 1111 1010
</code></pre>
<p>补码(正数补码还是自身，负数则是在反码基础上加1):</p>
<pre><code class="language-shell">5: 0000 0101
-5: 1111 1011
</code></pre>
<p>这样设计能够解决加减法不正确的问题</p>
<p>首先，计算十进制的表达式： <code>1-1=0</code>，看一下原码的计算:</p>
<pre><code class="language-shell"># 原码计算:
0000 0001 + 1000 0001 = 1000 0010
</code></pre>
<p><code>1000 0010</code>转换成十进制之后为<code>-2</code>，这个结果显然是错误的，所以不能直接用原码进行运算。</p>
<p>那么反码会怎样：</p>
<pre><code class="language-shell"># 原码计算:
0000 0001 + 1000 0001
# 反码计算:
0000 0001 + 1111 1110 = 1111 1111
# 转换回原码结果为
1000 0000
</code></pre>
<p><code>1000 0000</code>转换成十进制之后为<code>-0</code>，结果是正确了，但是这个<code>-0</code>看起来又很奇怪，虽然人们可以理解<code>+0</code>和<code>-0</code>是一样的，然而带符号的<code>0</code>并没有什么意义。</p>
<p>使用补码就可以解决上述问题：</p>
<pre><code class="language-shell"># 原码计算:
0000 0001 + 1000 0001
# 反码计算:
0000 0001 + 1111 1110
# 补码计算:
0000 0001 + 1111 1111 = 0000 0000
# 转换回原码结果为
0000 0000
</code></pre>
<p>这里有些同学会问，结果不应该是<code>1 0000 0000</code>吗？这里是因为我们假设计算机是用一个字节来存储数值的，一个字节是只有8位的，所以多出的1会被移掉。</p>
<p>现在我们来看一下按位取反是怎么实现的:</p>
<pre><code class="language-shell">-5: 原码:1000 0101  反码:1111 1010: 补码:1111 1011
# 按位取反发生在补码上:
0000 0100 
# 由于是正数的补码，和原码是一样的，那么结果就是:
0000 0100 即十进制的4

5: 原码、反码、补码: 0000 0101
# 按位取反后:
1111 1010
# 由于是补码，要先减1得到反码
1111 1001
# 再取反得到原码 
1000 0110 即十进制-6
</code></pre>
<h2 id="海龟的绝对零度"><a class="header" href="#海龟的绝对零度">海龟的绝对零度</a></h2>
<p>海龟的方向有两个模式：</p>
<table><thead><tr><th align="left">standard模式</th><th align="left">logo模式</th></tr></thead><tbody>
<tr><td align="left"><code>0 - 东</code></td><td align="left"><code>0 - 北</code></td></tr>
<tr><td align="left"><code>90 - 北</code></td><td align="left"><code>90 - 东</code></td></tr>
<tr><td align="left"><code>180 - 西</code></td><td align="left"><code>180 - 南</code></td></tr>
<tr><td align="left"><code>270 - 南</code></td><td align="left"><code>270 - 西</code></td></tr>
</tbody></table>
<p>海龟模块中的<code>mode()</code>函数可以设置海龟模式 (<code>standard</code> 或  <code>logo</code>) 并执行重置。</p>
<pre><code class="language-python">import turtle as t
t.seth(45)
t.mode('logo')
</code></pre>
<div align="center">
<img name="mode" src="附录/./images/mode.png" width="350">
</div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
    </body>
</html>
